From dda590844a3467791a8b1cdbcbbc5a49b088f2b0 Mon Sep 17 00:00:00 2001
From: V1tr10l7 <vitriol1744@gmail.com>
Date: Tue, 22 Apr 2025 00:48:01 +0200
Subject: [PATCH] cryptix: make it compile for target cryptix

---
 configure.ac                  |  276 +-
 disk-utils/cfdisk.c           | 4720 ++++++++++++++++---------------
 include/namespace.h           |   86 +-
 include/path.h                |  259 +-
 lib/cpuset.c                  |  614 ++--
 lib/path.c                    | 1648 ++++++-----
 libblkid/src/topology/ioctl.c |   75 +-
 login-utils/logindefs.c       |  800 +++---
 login-utils/lslogins.c        | 2775 +++++++++---------
 misc-utils/lsblk.h            |  311 ++-
 term-utils/agetty.c           | 4939 ++++++++++++++++-----------------
 11 files changed, 8259 insertions(+), 8244 deletions(-)

diff --git a/configure.ac b/configure.ac
index 2ac4c2b..61163aa 100644
--- a/configure.ac
+++ b/configure.ac
@@ -212,6 +212,8 @@ bsd_os=no
 AS_CASE([${host_os}],
   [*linux*],
      [linux_os=yes],
+  [*cryptix*],
+     [linux_os=yes],
   [*darwin*],
      [darwin_os=yes],
   [*bsd*],
@@ -425,7 +427,10 @@ have_pty_h=$ac_cv_header_pty_h
 
 AS_CASE([$linux_os:$have_linux_version_h],
   [yes:no],
-    [AC_MSG_ERROR([kernel headers required on Linux])]
+    AS_CASE([${host_os}],  
+      [*linux*],
+        [AC_MSG_ERROR([kernel headers required on Linux])]
+    )
 )
 
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
@@ -1506,7 +1511,7 @@ AC_ARG_ENABLE([hwclock_cmos],
   [], [enable_hwclock_cmos=check]
 )
 UL_BUILD_INIT([hwclock_cmos])
-UL_REQUIRES_BUILD([hwclock_cmos], [hwclock])
+UL_REQUIRES_BUILD([hwclock_cmos])
 UL_REQUIRES_ARCH([hwclock_cmos], [i?86-*,x86_64*])
 AM_CONDITIONAL([USE_HWCLOCK_CMOS], [test "x$build_hwclock_cmos" = xyes])
 AS_IF([test "x$build_hwclock_cmos" = xyes ], [
@@ -1523,20 +1528,36 @@ AS_IF([test "x$enable_hwclock_gplv3" = xyes ], [
 ])
 
 
-UL_BUILD_INIT([mkfs], [yes])
+AC_ARG_ENABLE([mkfs],
+  AS_HELP_STRING([--disable-mkfs], [do not build mkfs]),
+  [], [UL_DEFAULT_ENABLE([mkfs], [yes])]
+)
+UL_BUILD_INIT([mkfs])
 AM_CONDITIONAL([BUILD_MKFS], [test "x$build_mkfs" = xyes])
 
-UL_BUILD_INIT([isosize], [yes])
+AC_ARG_ENABLE([isosize],
+  AS_HELP_STRING([--disable-isosize], [do not build isosize]),
+  [], [UL_DEFAULT_ENABLE([isosize], [yes])]
+)
+UL_BUILD_INIT([isosize])
 AM_CONDITIONAL([BUILD_ISOSIZE], [test "x$build_isosize" = xyes])
 
 
-UL_BUILD_INIT([fstrim], [check])
+AC_ARG_ENABLE([fstrim],
+  AS_HELP_STRING([--disable-fstrim], [do not build fstrim]),
+  [], [UL_DEFAULT_ENABLE([fstrim], [check])]
+)
+UL_BUILD_INIT([fstrim])
 UL_REQUIRES_LINUX([fstrim])
 UL_REQUIRES_BUILD([fstrim], [libmount])
 AM_CONDITIONAL([BUILD_FSTRIM], [test "x$build_fstrim" = xyes])
 
 
-UL_BUILD_INIT([swapon], [check])
+AC_ARG_ENABLE([swapon],
+  AS_HELP_STRING([--disable-swapon], [do not build swapon, swapoff]),
+  [], [UL_DEFAULT_ENABLE([swapon], [check])]
+)
+UL_BUILD_INIT([swapon])
 UL_REQUIRES_LINUX([swapon])
 UL_REQUIRES_SYSCALL_CHECK([swapon], [UL_CHECK_SYSCALL([swapon])], [swapon])
 UL_REQUIRES_SYSCALL_CHECK([swapon], [UL_CHECK_SYSCALL([swapoff])], [swapoff])
@@ -1547,16 +1568,22 @@ AM_CONDITIONAL([BUILD_SWAPON], [test "x$build_swapon" = xyes])
 AC_CHECK_FUNCS([swapon])
 AC_CHECK_FUNCS([swapoff])
 
-
-UL_BUILD_INIT([lsblk], [check])
+AC_ARG_ENABLE([lsblk],
+  AS_HELP_STRING([--disable-lsblk], [do not build lsblk]),
+  [], [UL_DEFAULT_ENABLE([lsblk], [check])]
+)
+UL_BUILD_INIT([lsblk])
 UL_REQUIRES_LINUX([lsblk])
 UL_REQUIRES_BUILD([lsblk], [libblkid])
 UL_REQUIRES_BUILD([lsblk], [libmount])
 UL_REQUIRES_BUILD([lsblk], [libsmartcols])
 AM_CONDITIONAL([BUILD_LSBLK], [test "x$build_lsblk" = xyes])
 
-
-UL_BUILD_INIT([lscpu], [check])
+AC_ARG_ENABLE([lscpu],
+  AS_HELP_STRING([--disable-lscpu], [do not build lscpu]),
+  [], [UL_DEFAULT_ENABLE([lscpu], [check])]
+)
+UL_BUILD_INIT([lscpu])
 UL_REQUIRES_LINUX([lscpu])
 UL_REQUIRES_BUILD([lscpu], [libsmartcols])
 UL_REQUIRES_HAVE([lscpu], [cpu_set_t], [cpu_set_t type])
@@ -1574,8 +1601,11 @@ UL_REQUIRES_HAVE([lslogins], [utmpx_h], [utmpx.h header])
 UL_REQUIRES_HAVE([lslogins], [gnu_utmpx], [GNU utmpx functions])
 AM_CONDITIONAL([BUILD_LSLOGINS], [test "x$build_lslogins" = xyes])
 
-
-UL_BUILD_INIT([chcpu], [check])
+AC_ARG_ENABLE([chcpu],
+  AS_HELP_STRING([--disable-chcpu], [do not build chcpu]),
+  [], [UL_DEFAULT_ENABLE([chcpu], [check])]
+)
+UL_BUILD_INIT([chcpu])
 UL_REQUIRES_LINUX([chcpu])
 UL_REQUIRES_HAVE([chcpu], [cpu_set_t], [cpu_set_t type])
 AM_CONDITIONAL([BUILD_CHCPU], [test "x$build_chcpu" = xyes])
@@ -1587,17 +1617,23 @@ AC_ARG_ENABLE([wdctl],
 )
 UL_BUILD_INIT([wdctl])
 UL_REQUIRES_LINUX([wdctl])
-UL_REQUIRES_BUILD([wdctl], [libsmartcols])
+UL_REQUIRES_BUILD([wdctl])
 UL_REQUIRES_HAVE([wdctl], [linux_watchdog_h], [linux/watchdog.h header file])
 AM_CONDITIONAL([BUILD_WDCTL], [test "x$build_wdctl" = xyes])
 
-
-UL_BUILD_INIT([swaplabel], [check])
+AC_ARG_ENABLE([swaplabel],
+  AS_HELP_STRING([--disable-swaplabel], [do not build swaplabel]),
+  [], [UL_DEFAULT_ENABLE([swaplabel], [check])]
+)
+UL_BUILD_INIT([swaplabel])
 UL_REQUIRES_BUILD([swaplabel], [libblkid])
 AM_CONDITIONAL([BUILD_SWAPLABEL], [test "x$build_swaplabel" = xyes])
 
-
-UL_BUILD_INIT([mkswap], [yes])
+AC_ARG_ENABLE([mkswap],
+  AS_HELP_STRING([--disable-mkswap], [do not build mkswap]),
+  [], [UL_DEFAULT_ENABLE([mkswap], [yes])]
+)
+UL_BUILD_INIT([mkswap])
 AM_CONDITIONAL([BUILD_MKSWAP], [test "x$build_mkswap" = xyes])
 AS_IF([test "x$build_mkswap" = xyes && test "x$build_libuuid" != xyes], [
   AC_MSG_WARN([uuid library is not found; mkswap(8) will not generate UUIDs])
@@ -1618,13 +1654,25 @@ AC_ARG_ENABLE([logger],
 UL_BUILD_INIT([logger])
 AM_CONDITIONAL([BUILD_LOGGER], [test "x$build_logger" = xyes])
 
-UL_BUILD_INIT([look], [yes])
+AC_ARG_ENABLE([look],
+  AS_HELP_STRING([--disable-look], [do not build look]),
+  [], [UL_DEFAULT_ENABLE([look], [yes])]
+)
+UL_BUILD_INIT([look])
 AM_CONDITIONAL([BUILD_LOOK], [test "x$build_look" = xyes])
 
-UL_BUILD_INIT([mcookie], [yes])
+AC_ARG_ENABLE([mcookie],
+  AS_HELP_STRING([--disable-mcookie], [do not build mcookie]),
+  [], [UL_DEFAULT_ENABLE([mcookie], [yes])]
+)
+UL_BUILD_INIT([mcookie])
 AM_CONDITIONAL([BUILD_MCOOKIE], [test "x$build_mcookie" = xyes])
 
-UL_BUILD_INIT([namei], [yes])
+AC_ARG_ENABLE([namei],
+  AS_HELP_STRING([--disable-namei], [do not build namei]),
+  [], [UL_DEFAULT_ENABLE([namei], [yes])]
+)
+UL_BUILD_INIT([namei])
 AM_CONDITIONAL([BUILD_NAMEI], [test "x$build_namei" = xyes])
 
 matriplet="$($CC -print-multiarch 2>/dev/null || true)"
@@ -1632,19 +1680,29 @@ if test "x$matriplet" != "x"; then
   AC_DEFINE_UNQUOTED([MULTIARCHTRIPLET], ["$matriplet"],
   ["Multi-arch triplet for whereis library search path"])
 fi
-UL_BUILD_INIT([whereis], [yes])
+UL_BUILD_INIT([whereis])
 AM_CONDITIONAL([BUILD_WHEREIS], [test "x$build_whereis" = xyes])
 
-UL_BUILD_INIT([getopt], [yes])
+AC_ARG_ENABLE([getopt],
+  AS_HELP_STRING([--disable-getopt], [do not build getopt]),
+  [], [UL_DEFAULT_ENABLE([getopt], [yes])]
+)
+UL_BUILD_INIT([getopt])
 AM_CONDITIONAL([BUILD_GETOPT], [test "x$build_getopt" = xyes])
 
-
-UL_BUILD_INIT([blockdev], [check])
+AC_ARG_ENABLE([blockdev],
+  AS_HELP_STRING([--disable-blockdev], [do not build blockdev]),
+  [], [UL_DEFAULT_ENABLE([blockdev], [check])]
+)
+UL_BUILD_INIT([blockdev])
 UL_REQUIRES_LINUX([blockdev])
 AM_CONDITIONAL([BUILD_BLOCKDEV], [test "x$build_blockdev" = xyes])
 
-
-UL_BUILD_INIT([prlimit], [check])
+AC_ARG_ENABLE([prlimit],
+  AS_HELP_STRING([--disable-prlimit], [do not build prlimit]),
+  [], [UL_DEFAULT_ENABLE([prlimit], [check])]
+)
+UL_BUILD_INIT([prlimit])
 UL_REQUIRES_LINUX([prlimit])
 UL_REQUIRES_BUILD([prlimit], [libsmartcols])
 UL_REQUIRES_SYSCALL_CHECK([prlimit], [UL_CHECK_SYSCALL([prlimit64])], [prlimit64])
@@ -1653,8 +1711,11 @@ AS_IF([test "x$build_prlimit" = xyes], [
   AC_CHECK_FUNCS([prlimit])
 ])
 
-
-UL_BUILD_INIT([lslocks], [check])
+AC_ARG_ENABLE([lslocks],
+  AS_HELP_STRING([--disable-lslocks], [do not build lslocks]),
+  [], [UL_DEFAULT_ENABLE([lslocks], [check])]
+)
+UL_BUILD_INIT([lslocks])
 UL_REQUIRES_LINUX([lslocks])
 UL_REQUIRES_BUILD([lslocks], [libmount])
 UL_REQUIRES_BUILD([lslocks], [libsmartcols])
@@ -1681,8 +1742,11 @@ UL_REQUIRES_LINUX([pivot_root])
 UL_REQUIRES_SYSCALL_CHECK([pivot_root], [UL_CHECK_SYSCALL([pivot_root])])
 AM_CONDITIONAL([BUILD_PIVOT_ROOT], [test "x$build_pivot_root" = xyes])
 
-
-UL_BUILD_INIT([flock], [check])
+AC_ARG_ENABLE([flock],
+  AS_HELP_STRING([--disable-flock], [do not build flock]),
+  [], [UL_DEFAULT_ENABLE([flock], [check])]
+)
+UL_BUILD_INIT([flock])
 UL_REQUIRES_HAVE([flock], [timer], [timer_create/setitimer function])
 AM_CONDITIONAL([BUILD_FLOCK], [test "x$build_flock" = xyes])
 
@@ -1705,7 +1769,11 @@ UL_BUILD_INIT([chmem])
 UL_REQUIRES_LINUX([chmem])
 AM_CONDITIONAL([BUILD_CHMEM], [test "x$build_chmem" = xyes])
 
-UL_BUILD_INIT([ipcmk], [yes])
+AC_ARG_ENABLE([ipcmk],
+  AS_HELP_STRING([--disable-ipcmk], [do not build ipcmk]),
+  [], [UL_DEFAULT_ENABLE([ipcmk], [yes])]
+)
+UL_BUILD_INIT([ipcmk])
 AM_CONDITIONAL([BUILD_IPCMK], [test "x$build_ipcmk" = xyes])
 
 
@@ -1744,23 +1812,38 @@ UL_REQUIRES_LINUX([lsirq])
 UL_REQUIRES_BUILD([lsirq], [libsmartcols])
 AM_CONDITIONAL([BUILD_LSIRQ], [test "x$build_lsirq" = xyes])
 
-
-UL_BUILD_INIT([choom], [check])
+AC_ARG_ENABLE([choom],
+  AS_HELP_STRING([--disable-choom], [do not build choom]),
+  [], [UL_DEFAULT_ENABLE([choom], [check])]
+)
+UL_BUILD_INIT([choom])
 UL_REQUIRES_LINUX([choom])
 AM_CONDITIONAL([BUILD_CHOOM], [test "x$build_choom" = xyes])
 
-UL_BUILD_INIT([lsipc], [check])
+AC_ARG_ENABLE([lsipc],
+  AS_HELP_STRING([--disable-lsipc], [do not build lsipc]),
+  [], [UL_DEFAULT_ENABLE([lsipc], [check])]
+)
+UL_BUILD_INIT([lsipc])
 UL_REQUIRES_LINUX([lsipc])
 UL_REQUIRES_BUILD([lsipc], [libsmartcols])
 AM_CONDITIONAL([BUILD_LSIPC], [test "x$build_lsipc" = xyes])
 
-UL_BUILD_INIT([lsns], [check])
+AC_ARG_ENABLE([lsns],
+  AS_HELP_STRING([--disable-lsns], [do not build lsns]),
+  [], [UL_DEFAULT_ENABLE([lsns], [check])]
+)
+UL_BUILD_INIT([lsns])
 UL_REQUIRES_LINUX([lsns])
 UL_REQUIRES_BUILD([lsns], [libsmartcols])
 UL_REQUIRES_BUILD([lsns], [libmount])
 AM_CONDITIONAL([BUILD_LSNS], [test "x$build_lsns" = xyes])
 
-UL_BUILD_INIT([renice], [yes])
+AC_ARG_ENABLE([renice],
+  AS_HELP_STRING([--disable-renice], [do not build renice]),
+  [], [UL_DEFAULT_ENABLE([renice], [yes])]
+)
+UL_BUILD_INIT([renice])
 AM_CONDITIONAL([BUILD_RENICE], [test "x$build_renice" = xyes])
 
 
@@ -1773,19 +1856,34 @@ UL_REQUIRES_LINUX([rfkill])
 UL_REQUIRES_BUILD([rfkill], [libsmartcols])
 AM_CONDITIONAL([BUILD_RFKILL], [test "x$build_rfkill" = xyes])
 
-
-UL_BUILD_INIT([setsid], [yes])
+AC_ARG_ENABLE([setsid],
+  AS_HELP_STRING([--disable-setsid], [do not build setsid]),
+  [], [UL_DEFAULT_ENABLE([setsid], [yes])]
+)
+UL_BUILD_INIT([setsid])
 AM_CONDITIONAL([BUILD_SETSID], [test "x$build_setsid" = xyes])
 
-UL_BUILD_INIT([readprofile], [check])
+AC_ARG_ENABLE([readprofile],
+  AS_HELP_STRING([--disable-readprofile], [do not build readprofile]),
+  [], [UL_DEFAULT_ENABLE([readprofile], [check])]
+)
+UL_BUILD_INIT([readprofile])
 UL_REQUIRES_LINUX([readprofile])
 AM_CONDITIONAL([BUILD_READPROFILE], [test "x$build_readprofile" = xyes])
 
-UL_BUILD_INIT([dmesg], [check])
+AC_ARG_ENABLE([dmesg],
+  AS_HELP_STRING([--disable-dmesg], [do not build dmesg]),
+  [], [UL_DEFAULT_ENABLE([dmesg], [check])]
+)
+UL_BUILD_INIT([dmesg])
 UL_REQUIRES_LINUX([dmesg])
 AM_CONDITIONAL([BUILD_DMESG], [test "x$build_dmesg" = xyes])
 
-UL_BUILD_INIT([ctrlaltdel], [check])
+AC_ARG_ENABLE([ctrlaltdel],
+  AS_HELP_STRING([--disable-ctrlaltdel], [do not build ctrlaltdel]),
+  [], [UL_DEFAULT_ENABLE([ctrlaltdel], [check])]
+)
+UL_BUILD_INIT([ctrlaltdel])
 UL_REQUIRES_LINUX([ctrlaltdel])
 dnl we assume reboot() to be the 1-argument variant, because even considering
 dnl widely used alternative C libraries like uclibc, dietlibc and musl,
@@ -1794,64 +1892,128 @@ dnl earlier than 2.x.
 UL_REQUIRES_HAVE([ctrlaltdel], [reboot], [reboot function])
 AM_CONDITIONAL([BUILD_CTRLALTDEL], [test "x$build_ctrlaltdel" = xyes])
 
-UL_BUILD_INIT([fincore], [check])
+AC_ARG_ENABLE([fincore],
+  AS_HELP_STRING([--disable-fincore], [do not build fincore]),
+  [], [UL_DEFAULT_ENABLE([fincore], [check])]
+)
+UL_BUILD_INIT([fincore])
 UL_REQUIRES_LINUX([fincore])
 UL_REQUIRES_BUILD([fincore], [libsmartcols])
 AM_CONDITIONAL([BUILD_FINCORE], [test "x$build_fincore" = xyes])
 
-UL_BUILD_INIT([fsfreeze], [check])
+AC_ARG_ENABLE([fsfreeze],
+  AS_HELP_STRING([--disable-fsfreeze], [do not build fsfreeze]),
+  [], [UL_DEFAULT_ENABLE([fsfreeze], [check])]
+)
+UL_BUILD_INIT([fsfreeze])
 UL_REQUIRES_LINUX([fsfreeze])
 AM_CONDITIONAL([BUILD_FSFREEZE], [test "x$build_fsfreeze" = xyes])
 
-UL_BUILD_INIT([blkdiscard], [check])
+AC_ARG_ENABLE([blkdiscard],
+  AS_HELP_STRING([--disable-blkdiscard], [do not build blkdiscard]),
+  [], [UL_DEFAULT_ENABLE([blkdiscard], [check])]
+)
+UL_BUILD_INIT([blkdiscard])
 UL_REQUIRES_LINUX([blkdiscard])
 AM_CONDITIONAL([BUILD_BLKDISCARD], [test "x$build_blkdiscard" = xyes])
 
-UL_BUILD_INIT([blkzone], [check])
+AC_ARG_ENABLE([blkzone],
+  AS_HELP_STRING([--disable-blkzone], [do not build blkzone]),
+  [], [UL_DEFAULT_ENABLE([blkzone], [check])]
+)
+UL_BUILD_INIT([blkzone])
 UL_REQUIRES_LINUX([blkzone])
 UL_REQUIRES_HAVE([blkzone], [linux_blkzoned_h], [linux/blkzoned.h header])
 AM_CONDITIONAL([BUILD_BLKZONE], [test "x$build_blkzone" = xyes])
 
-UL_BUILD_INIT([ldattach], [check])
+AC_ARG_ENABLE([ldattach],
+  AS_HELP_STRING([--disable-ldattach], [do not build ldattach]),
+  [], [UL_DEFAULT_ENABLE([ldattach], [check])]
+)
+UL_BUILD_INIT([ldattach])
 UL_REQUIRES_LINUX([ldattach])
 AM_CONDITIONAL([BUILD_LDATTACH], [test "x$build_ldattach" = xyes])
 
-UL_BUILD_INIT([rtcwake], [check])
+AC_ARG_ENABLE([rtcwake],
+  AS_HELP_STRING([--disable-rtcwake], [do not build rtcwake]),
+  [], [UL_DEFAULT_ENABLE([rtcwake], [check])]
+)
+UL_BUILD_INIT([rtcwake])
 UL_REQUIRES_LINUX([rtcwake])
 AM_CONDITIONAL([BUILD_RTCWAKE], [test "x$build_rtcwake" = xyes])
 
-UL_BUILD_INIT([setarch], [check])
+AC_ARG_ENABLE([setarch],
+  AS_HELP_STRING([--disable-setarch], [do not build setarch]),
+  [], [UL_DEFAULT_ENABLE([setarch], [check])]
+)
+UL_BUILD_INIT([setarch])
 UL_REQUIRES_LINUX([setarch])
 AM_CONDITIONAL([BUILD_SETARCH], [test "x$build_setarch" = xyes])
 
-UL_BUILD_INIT([script], [check])
+AC_ARG_ENABLE([script],
+  AS_HELP_STRING([--disable-script], [do not build script]),
+  [], [UL_DEFAULT_ENABLE([script], [check])]
+)
+UL_BUILD_INIT([script])
 UL_REQUIRES_HAVE([script], [pty])
 AM_CONDITIONAL([BUILD_SCRIPT], [test "x$build_script" = xyes])
 
-UL_BUILD_INIT([scriptreplay], [yes])
+AC_ARG_ENABLE([scriptreplay],
+  AS_HELP_STRING([--disable-scriptreplay], [do not build scriptreplay]),
+  [], [UL_DEFAULT_ENABLE([scriptreplay], [yes])]
+)
+UL_BUILD_INIT([scriptreplay])
 AM_CONDITIONAL([BUILD_SCRIPTREPLAY], [test "x$build_scriptreplay" = xyes])
 
-UL_BUILD_INIT([scriptlive], [check])
+AC_ARG_ENABLE([scriptlive],
+  AS_HELP_STRING([--disable-scriptlive], [do not build scriptlive]),
+  [], [UL_DEFAULT_ENABLE([scriptlive], [check])]
+)
+UL_BUILD_INIT([scriptlive])
 UL_REQUIRES_HAVE([scriptlive], [pty])
 AM_CONDITIONAL([BUILD_SCRIPTLIVE], [test "x$build_scriptlive" = xyes])
 
-UL_BUILD_INIT([col], [yes])
+AC_ARG_ENABLE([col],
+  AS_HELP_STRING([--disable-col], [do not build col]),
+  [], [UL_DEFAULT_ENABLE([col], [yes])]
+)
+UL_BUILD_INIT([col])
 AM_CONDITIONAL([BUILD_COL], [test "x$build_col" = xyes])
 
-UL_BUILD_INIT([colcrt], [yes])
+AC_ARG_ENABLE([colcrt],
+  AS_HELP_STRING([--disable-colcrt], [do not build colcrt]),
+  [], [UL_DEFAULT_ENABLE([colcrt], [yes])]
+)
+UL_BUILD_INIT([colcrt])
 AM_CONDITIONAL([BUILD_COLCRT], [test "x$build_colcrt" = xyes])
 
-UL_BUILD_INIT([colrm], [yes])
+AC_ARG_ENABLE([colrm],
+  AS_HELP_STRING([--disable-colrm], [do not build colrm]),
+  [], [UL_DEFAULT_ENABLE([colrm], [yes])]
+)
+UL_BUILD_INIT([colrm])
 AM_CONDITIONAL([BUILD_COLRM], [test "x$build_colrm" = xyes])
 
-UL_BUILD_INIT([column], [check])
+AC_ARG_ENABLE([column],
+  AS_HELP_STRING([--disable-column], [do not build column]),
+  [], [UL_DEFAULT_ENABLE([column], [check])]
+)
+UL_BUILD_INIT([column])
 UL_REQUIRES_BUILD([column], [libsmartcols])
 AM_CONDITIONAL([BUILD_COLUMN], [test "x$build_column" = xyes])
 
-UL_BUILD_INIT([hexdump], [yes])
+AC_ARG_ENABLE([hexdump],
+  AS_HELP_STRING([--disable-hexdump], [do not build hexdump]),
+  [], [UL_DEFAULT_ENABLE([hexdump], [yes])]
+)
+UL_BUILD_INIT([hexdump])
 AM_CONDITIONAL([BUILD_HEXDUMP], [test "x$build_hexdump" = xyes])
 
-UL_BUILD_INIT([rev], [yes])
+AC_ARG_ENABLE([rev],
+  AS_HELP_STRING([--disable-rev], [do not build rev]),
+  [], [UL_DEFAULT_ENABLE([rev], [yes])]
+)
+UL_BUILD_INIT([rev])
 AM_CONDITIONAL([BUILD_REV], [test "x$build_rev" = xyes])
 
 
diff --git a/disk-utils/cfdisk.c b/disk-utils/cfdisk.c
index 11f8b9a..af14233 100644
--- a/disk-utils/cfdisk.c
+++ b/disk-utils/cfdisk.c
@@ -12,144 +12,146 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  */
-#include <stdlib.h>
-#include <stdio.h>
-#include <errno.h>
-#include <signal.h>
+#include <assert.h>
 #include <ctype.h>
+#include <errno.h>
 #include <getopt.h>
-#include <assert.h>
+#include <libfdisk.h>
 #include <libsmartcols.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
 #include <sys/ioctl.h>
-#include <libfdisk.h>
+#include <termios.h>
 
 #ifdef HAVE_LIBMOUNT
-# include <libmount.h>	/* keep it optional for non-linux systems */
+    #include <libmount.h> /* keep it optional for non-linux systems */
 #endif
 
 #ifdef HAVE_SLANG_H
-# include <slang.h>
+    #include <slang.h>
 #elif defined(HAVE_SLANG_SLANG_H)
-# include <slang/slang.h>
+    #include <slang/slang.h>
 #endif
 
 #ifndef _XOPEN_SOURCE
-# define _XOPEN_SOURCE 500 /* for inclusion of get_wch */
+    #define _XOPEN_SOURCE 500 /* for inclusion of get_wch */
 #endif
 
 #ifdef HAVE_SLCURSES_H
-# include <slcurses.h>
+    #include <slcurses.h>
 #elif defined(HAVE_SLANG_SLCURSES_H)
-# include <slang/slcurses.h>
+    #include <slang/slcurses.h>
 #elif defined(HAVE_NCURSESW_NCURSES_H) && defined(HAVE_WIDECHAR)
-# include <ncursesw/ncurses.h>
+    #include <ncursesw/ncurses.h>
 #elif defined(HAVE_NCURSES_H)
-# include <ncurses.h>
+    #include <ncurses.h>
 #elif defined(HAVE_NCURSES_NCURSES_H)
-# include <ncurses/ncurses.h>
+    #include <ncurses/ncurses.h>
 #endif
 
 #ifdef HAVE_WIDECHAR
-# include <wctype.h>
-# include <wchar.h>
+    #include <wchar.h>
+    #include <wctype.h>
 #endif
 
+#include "blkdev.h"
 #include "c.h"
 #include "closestream.h"
-#include "nls.h"
-#include "strutils.h"
-#include "xalloc.h"
-#include "mbsalign.h"
-#include "mbsedit.h"
 #include "colors.h"
 #include "debug.h"
 #include "list.h"
-#include "blkdev.h"
+#include "mbsalign.h"
+#include "mbsedit.h"
+#include "nls.h"
+#include "strutils.h"
+#include "xalloc.h"
 
-static const char *default_disks[] = {
+static const char* default_disks[] = {
 #ifdef __GNU__
-		"/dev/hd0",
-		"/dev/sd0",
+    "/dev/hd0",
+    "/dev/sd0",
 #elif defined(__FreeBSD__)
-		"/dev/ad0",
-		"/dev/da0",
+    "/dev/ad0",
+    "/dev/da0",
 #else
-		"/dev/sda",
-		"/dev/vda",
-		"/dev/hda",
+    "/dev/sda",
+    "/dev/vda",
+    "/dev/hda",
 #endif
 };
 
-#define ARROW_CURSOR_STRING	">>  "
-#define ARROW_CURSOR_DUMMY	"    "
-#define ARROW_CURSOR_WIDTH	(sizeof(ARROW_CURSOR_STRING) - 1)
+#define ARROW_CURSOR_STRING ">>  "
+#define ARROW_CURSOR_DUMMY  "    "
+#define ARROW_CURSOR_WIDTH  (sizeof(ARROW_CURSOR_STRING) - 1)
 
 /* vertical menu */
-#define MENU_V_SPADDING		1	/* space around menu item string */
+#define MENU_V_SPADDING     1 /* space around menu item string */
 
 /* horizontal menu */
-#define MENU_H_SPADDING		0	/* space around menu item string */
-#define MENU_H_BETWEEN		2	/* space between menu items */
-#define MENU_H_PRESTR		"["
-#define MENU_H_POSTSTR		"]"
+#define MENU_H_SPADDING     0 /* space around menu item string */
+#define MENU_H_BETWEEN      2 /* space between menu items */
+#define MENU_H_PRESTR       "["
+#define MENU_H_POSTSTR      "]"
 
-#define MENU_TITLE_PADDING	3
+#define MENU_TITLE_PADDING  3
 
-#define MENU_H_PRESTR_SZ	(sizeof(MENU_H_PRESTR) - 1)
-#define MENU_H_POSTSTR_SZ	(sizeof(MENU_H_POSTSTR) - 1)
+#define MENU_H_PRESTR_SZ    (sizeof(MENU_H_PRESTR) - 1)
+#define MENU_H_POSTSTR_SZ   (sizeof(MENU_H_POSTSTR) - 1)
 
-#define TABLE_START_LINE	4
-#define MENU_START_LINE		(ui_lines - 4)		/* The menu maybe use two lines */
-#define INFO_LINE		(ui_lines - 2)
-#define WARN_LINE		INFO_LINE
-#define HINT_LINE		(ui_lines - 1)
+#define TABLE_START_LINE    4
+#define MENU_START_LINE     (ui_lines - 4) /* The menu maybe use two lines */
+#define INFO_LINE           (ui_lines - 2)
+#define WARN_LINE           INFO_LINE
+#define HINT_LINE           (ui_lines - 1)
 
-#define CFDISK_ERR_ESC		5000
+#define CFDISK_ERR_ESC      5000
 
 #ifndef KEY_ESC
-# define KEY_ESC	'\033'
+    #define KEY_ESC '\033'
 #endif
 #ifndef KEY_DELETE
-# define KEY_DELETE	'\177'
+    #define KEY_DELETE '\177'
 #endif
 #ifndef KEY_DC
-# define KEY_DC		0423
+    #define KEY_DC 0423
 #endif
 
-
 /* colors */
-enum {
-	CFDISK_CL_NONE = 0,
-	CFDISK_CL_WARNING,
-	CFDISK_CL_FREESPACE,
-	CFDISK_CL_INFO
+enum
+{
+    CFDISK_CL_NONE = 0,
+    CFDISK_CL_WARNING,
+    CFDISK_CL_FREESPACE,
+    CFDISK_CL_INFO
 };
 static const int color_pairs[][2] = {
-	/* color            foreground, background */
-	[CFDISK_CL_WARNING]   = { COLOR_RED, -1 },
-	[CFDISK_CL_FREESPACE] = { COLOR_GREEN, -1 },
-	[CFDISK_CL_INFO]      = { COLOR_BLUE, -1 }
-};
+    /* color            foreground, background */
+    [CFDISK_CL_WARNING]   = {COLOR_RED, -1},
+    [CFDISK_CL_FREESPACE] = {COLOR_GREEN, -1},
+    [CFDISK_CL_INFO]      = {COLOR_BLUE, -1}};
 
 struct cfdisk;
 
-static struct cfdisk_menuitem *menu_get_menuitem(struct cfdisk *cf, size_t idx);
-static struct cfdisk_menuitem *menu_get_menuitem_by_key(struct cfdisk *cf, int key, size_t *idx);
-static struct cfdisk_menu *menu_push(struct cfdisk *cf, struct cfdisk_menuitem *item);
-static struct cfdisk_menu *menu_pop(struct cfdisk *cf);
-static void menu_refresh_size(struct cfdisk *cf);
-
-static int ui_end(void);
-static int ui_refresh(struct cfdisk *cf);
-static void ui_warnx(const char *fmt, ...);
-static void ui_warn(const char *fmt, ...);
-static void ui_info(const char *fmt, ...);
-static void ui_draw_menu(struct cfdisk *cf);
-static int ui_menu_move(struct cfdisk *cf, int key);
-static void ui_menu_resize(struct cfdisk *cf);
-
-static int ui_get_size(struct cfdisk *cf, const char *prompt, uint64_t *res,
-		       uint64_t low, uint64_t up, int *expsize);
+static struct cfdisk_menuitem* menu_get_menuitem(struct cfdisk* cf, size_t idx);
+static struct cfdisk_menuitem* menu_get_menuitem_by_key(struct cfdisk* cf,
+                                                        int key, size_t* idx);
+static struct cfdisk_menu*     menu_push(struct cfdisk*          cf,
+                                         struct cfdisk_menuitem* item);
+static struct cfdisk_menu*     menu_pop(struct cfdisk* cf);
+static void                    menu_refresh_size(struct cfdisk* cf);
+
+static int                     ui_end(void);
+static int                     ui_refresh(struct cfdisk* cf);
+static void                    ui_warnx(const char* fmt, ...);
+static void                    ui_warn(const char* fmt, ...);
+static void                    ui_info(const char* fmt, ...);
+static void                    ui_draw_menu(struct cfdisk* cf);
+static int                     ui_menu_move(struct cfdisk* cf, int key);
+static void                    ui_menu_resize(struct cfdisk* cf);
+
+static int ui_get_size(struct cfdisk* cf, const char* prompt, uint64_t* res,
+                       uint64_t low, uint64_t up, int* expsize);
 
 static int ui_enabled;
 static volatile sig_atomic_t sig_resize;
@@ -157,2633 +159,2585 @@ static volatile sig_atomic_t sig_die;
 
 /* ncurses LINES and COLS may be actual variables or *macros*, but we need
  * something portable and writable */
-static size_t ui_lines;
-static size_t ui_cols;
+static size_t                ui_lines;
+static size_t                ui_cols;
 
 /* menu item */
-struct cfdisk_menuitem {
-	int		key;		/* keyboard shortcut */
-	const char	*name;		/* item name */
-	const char	*desc;		/* item description (hint) */
-	void		*userdata;
+struct cfdisk_menuitem
+{
+    int         key;  /* keyboard shortcut */
+    const char* name; /* item name */
+    const char* desc; /* item description (hint) */
+    void*       userdata;
 };
 
 /* menu */
-struct cfdisk_menu {
-	char			*title;	/* optional menu title */
-	struct cfdisk_menuitem	*items;	/* array with menu items */
-	char			*ignore;/* string with keys to ignore */
-	size_t			width;	/* maximal width of the menu item */
-	size_t			nitems;	/* number of the active menu items */
-	size_t			page_sz;/* when menu longer than screen */
-	size_t			idx;	/* the current menu item */
-	int			prefkey;/* preferred menu item  */
-	struct cfdisk_menu	*prev;
-
-	/* @ignore keys generator */
-	int (*ignore_cb)	(struct cfdisk *, char *, size_t);
-
-	unsigned int		vertical : 1;	/* enable vertical mode */
+struct cfdisk_menu
+{
+    char*                   title;   /* optional menu title */
+    struct cfdisk_menuitem* items;   /* array with menu items */
+    char*                   ignore;  /* string with keys to ignore */
+    size_t                  width;   /* maximal width of the menu item */
+    size_t                  nitems;  /* number of the active menu items */
+    size_t                  page_sz; /* when menu longer than screen */
+    size_t                  idx;     /* the current menu item */
+    int                     prefkey; /* preferred menu item  */
+    struct cfdisk_menu*     prev;
+
+    /* @ignore keys generator */
+    int (*ignore_cb)(struct cfdisk*, char*, size_t);
+
+    unsigned int vertical : 1; /* enable vertical mode */
 };
 
 /* main menu */
 static struct cfdisk_menuitem main_menuitems[] = {
-	{ 'b', N_("Bootable"), N_("Toggle bootable flag of the current partition") },
-	{ 'd', N_("Delete"), N_("Delete the current partition") },
-	{ 'r', N_("Resize"), N_("Reduce or enlarge the current partition") },
-	{ 'n', N_("New"), N_("Create new partition from free space") },
-	{ 'q', N_("Quit"), N_("Quit program without writing changes") },
-	{ 't', N_("Type"), N_("Change the partition type") },
-	{ 'h', N_("Help"), N_("Print help screen") },
-	{ 's', N_("Sort"), N_("Fix partitions order") },
-	{ 'W', N_("Write"), N_("Write partition table to disk (this might destroy data)") },
-	{ 'u', N_("Dump"), N_("Dump partition table to sfdisk compatible script file") },
-	{ 0, NULL, NULL }
-};
+    {'b', N_("Bootable"), N_("Toggle bootable flag of the current partition")},
+    {'d', N_("Delete"), N_("Delete the current partition")},
+    {'r', N_("Resize"), N_("Reduce or enlarge the current partition")},
+    {'n', N_("New"), N_("Create new partition from free space")},
+    {'q', N_("Quit"), N_("Quit program without writing changes")},
+    {'t', N_("Type"), N_("Change the partition type")},
+    {'h', N_("Help"), N_("Print help screen")},
+    {'s', N_("Sort"), N_("Fix partitions order")},
+    {'W', N_("Write"),
+     N_("Write partition table to disk (this might destroy data)")},
+    {'u', N_("Dump"),
+     N_("Dump partition table to sfdisk compatible script file")},
+    {0, NULL, NULL}};
 
 /* extra partinfo in name:value pairs */
-struct cfdisk_extra {
-	char *name;
-	char *data;
+struct cfdisk_extra
+{
+    char*            name;
+    char*            data;
 
-	struct list_head exs;
+    struct list_head exs;
 };
 
 /* line and extra partinfo list_head */
-struct cfdisk_line {
-	char			*data;		/* line data */
-	struct libscols_table	*extra;		/* extra info ('X') */
-	WINDOW			*w;		/* window with extra info */
+struct cfdisk_line
+{
+    char*                  data;  /* line data */
+    struct libscols_table* extra; /* extra info ('X') */
+    WINDOW*                w;     /* window with extra info */
 };
 
 /* top level control struct */
-struct cfdisk {
-	struct fdisk_context	*cxt;	/* libfdisk context */
-	struct fdisk_table	*table;	/* partition table */
-	struct fdisk_table	*original_layout; /* original on-disk PT */
+struct cfdisk
+{
+    struct fdisk_context* cxt;             /* libfdisk context */
+    struct fdisk_table*   table;           /* partition table */
+    struct fdisk_table*   original_layout; /* original on-disk PT */
 
-	struct cfdisk_menu	*menu;	/* the current menu */
+    struct cfdisk_menu*   menu; /* the current menu */
 
-	int	*fields;	/* output columns IDs */
-	size_t	nfields;	/* number of columns IDs */
+    int*                  fields;  /* output columns IDs */
+    size_t                nfields; /* number of columns IDs */
 
-	char	*linesbuf;	/* table as string */
-	size_t	linesbufsz;	/* size of the tb_buf */
+    char*                 linesbuf;   /* table as string */
+    size_t                linesbufsz; /* size of the tb_buf */
 
-	struct	cfdisk_line	*lines;	/* list of lines */
+    struct cfdisk_line*   lines; /* list of lines */
 
-	size_t	nlines;		/* number of lines */
-	size_t	lines_idx;	/* current line <0..N>, exclude header */
-	size_t  page_sz;
+    size_t                nlines;    /* number of lines */
+    size_t                lines_idx; /* current line <0..N>, exclude header */
+    size_t                page_sz;
 
-	unsigned int nwrites;	/* fdisk_write_disklabel() counter */
+    unsigned int          nwrites; /* fdisk_write_disklabel() counter */
 
-	WINDOW	*act_win;	/* the window currently on the screen */
+    WINDOW*               act_win; /* the window currently on the screen */
 
 #ifdef HAVE_LIBMOUNT
-	struct libmnt_table *mtab;
-	struct libmnt_table *fstab;
-	struct libmnt_cache *mntcache;
+    struct libmnt_table* mtab;
+    struct libmnt_table* fstab;
+    struct libmnt_cache* mntcache;
 #endif
-	unsigned int	wrong_order :1,		/* PT not in right order */
-			zero_start :1,		/* ignore existing partition table */
-			device_is_used : 1,	/* don't use re-read ioctl */
-			show_extra :1;		/* show extra partinfo */
+    unsigned int wrong_order : 1, /* PT not in right order */
+        zero_start           : 1, /* ignore existing partition table */
+        device_is_used       : 1, /* don't use re-read ioctl */
+        show_extra           : 1; /* show extra partinfo */
 };
 
-
 /*
  * let's use include/debug.h stuff for cfdisk too
  */
 static UL_DEBUG_DEFINE_MASK(cfdisk);
 UL_DEBUG_DEFINE_MASKNAMES(cfdisk) = UL_DEBUG_EMPTY_MASKNAMES;
 
-#define CFDISK_DEBUG_INIT	(1 << 1)
-#define CFDISK_DEBUG_UI		(1 << 2)
-#define CFDISK_DEBUG_MENU	(1 << 3)
-#define CFDISK_DEBUG_MISC	(1 << 4)
-#define CFDISK_DEBUG_TABLE	(1 << 5)
-#define CFDISK_DEBUG_ALL	0xFFFF
+#define CFDISK_DEBUG_INIT  (1 << 1)
+#define CFDISK_DEBUG_UI    (1 << 2)
+#define CFDISK_DEBUG_MENU  (1 << 3)
+#define CFDISK_DEBUG_MISC  (1 << 4)
+#define CFDISK_DEBUG_TABLE (1 << 5)
+#define CFDISK_DEBUG_ALL   0xFFFF
 
-#define DBG(m, x)       __UL_DBG(cfdisk, CFDISK_DEBUG_, m, x)
+#define DBG(m, x)          __UL_DBG(cfdisk, CFDISK_DEBUG_, m, x)
 
 static void cfdisk_init_debug(void)
 {
-	__UL_INIT_DEBUG_FROM_ENV(cfdisk, CFDISK_DEBUG_, 0, CFDISK_DEBUG);
+    __UL_INIT_DEBUG_FROM_ENV(cfdisk, CFDISK_DEBUG_, 0, CFDISK_DEBUG);
 }
 
 /* Initialize output columns -- we follow libfdisk fields (usually specific
  * to the label type.
  */
-static int cols_init(struct cfdisk *cf)
+static int cols_init(struct cfdisk* cf)
 {
-	assert(cf);
+    assert(cf);
 
-	free(cf->fields);
-	cf->fields = NULL;
-	cf->nfields = 0;
+    free(cf->fields);
+    cf->fields  = NULL;
+    cf->nfields = 0;
 
-	return fdisk_label_get_fields_ids(NULL, cf->cxt, &cf->fields, &cf->nfields);
+    return fdisk_label_get_fields_ids(NULL, cf->cxt, &cf->fields, &cf->nfields);
 }
 
 static void die_on_signal(void)
 {
-	DBG(MISC, ul_debug("die on signal."));
-	ui_end();
-	exit(EXIT_FAILURE);
+    DBG(MISC, ul_debug("die on signal."));
+    ui_end();
+    exit(EXIT_FAILURE);
 }
 
 static void resize(void)
 {
-	struct winsize ws;
+    struct winsize ws;
 
-	if (ioctl(fileno(stdout), TIOCGWINSZ, &ws) != -1
-	    && ws.ws_row && ws.ws_col) {
-		ui_lines = ws.ws_row;
-		ui_cols  = ws.ws_col;
+    if (ioctl(fileno(stdout), TIOCGWINSZ, &ws) != -1 && ws.ws_row && ws.ws_col)
+    {
+        ui_lines = ws.ws_row;
+        ui_cols  = ws.ws_col;
 #if HAVE_RESIZETERM
-		resizeterm(ws.ws_row, ws.ws_col);
+        resizeterm(ws.ws_row, ws.ws_col);
 #endif
-		clearok(stdscr, TRUE);
-	}
-	touchwin(stdscr);
+        clearok(stdscr, TRUE);
+    }
+    touchwin(stdscr);
 
-	DBG(UI, ul_debug("ui: resize refresh ui_cols=%zu, ui_lines=%zu",
-				ui_cols, ui_lines));
-	sig_resize = 0;
+    DBG(UI, ul_debug("ui: resize refresh ui_cols=%zu, ui_lines=%zu", ui_cols,
+                     ui_lines));
+    sig_resize = 0;
 }
 
 /* Reads partition in tree-like order from scols
  */
-static int partition_from_scols(struct fdisk_table *tb,
-				struct libscols_line *ln)
-{
-	struct fdisk_partition *pa = scols_line_get_userdata(ln);
-
-	fdisk_table_add_partition(tb, pa);
-	fdisk_unref_partition(pa);
-
-	if (scols_line_has_children(ln)) {
-		struct libscols_line *chln;
-		struct libscols_iter *itr = scols_new_iter(SCOLS_ITER_FORWARD);
-
-		if (!itr)
-			return -EINVAL;
-		while (scols_line_next_child(ln, itr, &chln) == 0)
-			partition_from_scols(tb, chln);
-		scols_free_iter(itr);
-	}
-	return 0;
-}
-
-static char *table_to_string(struct cfdisk *cf, struct fdisk_table *tb)
-{
-	struct fdisk_partition *pa;
-	struct fdisk_label *lb;
-	struct fdisk_iter *itr;
-	struct libscols_table *table = NULL;
-	struct libscols_iter *s_itr = NULL;
-	char *res = NULL;
-	size_t i;
-	int tree = 0;
-	struct libscols_line *ln, *ln_cont = NULL;
-
-	DBG(TABLE, ul_debug("convert to string"));
-
-	assert(cf);
-	assert(cf->cxt);
-	assert(cf->fields);
-	assert(tb);
-
-	lb = fdisk_get_label(cf->cxt, NULL);
-	assert(lb);
-
-	itr = fdisk_new_iter(FDISK_ITER_FORWARD);
-	if (!itr)
-		goto done;
-
-	/* get container (e.g. extended partition) */
-	while (fdisk_table_next_partition(tb, itr, &pa) == 0) {
-		if (fdisk_partition_is_nested(pa)) {
-			DBG(TABLE, ul_debug("nested detected, using tree"));
-			tree = SCOLS_FL_TREE;
-			break;
-		}
-	}
-
-	table = scols_new_table();
-	if (!table)
-		goto done;
-	scols_table_enable_maxout(table, 1);
-	scols_table_enable_nowrap(table, 1);
+static int partition_from_scols(struct fdisk_table*   tb,
+                                struct libscols_line* ln)
+{
+    struct fdisk_partition* pa = scols_line_get_userdata(ln);
+
+    fdisk_table_add_partition(tb, pa);
+    fdisk_unref_partition(pa);
+
+    if (scols_line_has_children(ln))
+    {
+        struct libscols_line* chln;
+        struct libscols_iter* itr = scols_new_iter(SCOLS_ITER_FORWARD);
+
+        if (!itr) return -EINVAL;
+        while (scols_line_next_child(ln, itr, &chln) == 0)
+            partition_from_scols(tb, chln);
+        scols_free_iter(itr);
+    }
+    return 0;
+}
+
+static char* table_to_string(struct cfdisk* cf, struct fdisk_table* tb)
+{
+    struct fdisk_partition* pa;
+    struct fdisk_label*     lb;
+    struct fdisk_iter*      itr;
+    struct libscols_table*  table = NULL;
+    struct libscols_iter*   s_itr = NULL;
+    char*                   res   = NULL;
+    size_t                  i;
+    int                     tree = 0;
+    struct libscols_line *  ln, *ln_cont = NULL;
+
+    DBG(TABLE, ul_debug("convert to string"));
+
+    assert(cf);
+    assert(cf->cxt);
+    assert(cf->fields);
+    assert(tb);
+
+    lb = fdisk_get_label(cf->cxt, NULL);
+    assert(lb);
+
+    itr = fdisk_new_iter(FDISK_ITER_FORWARD);
+    if (!itr) goto done;
+
+    /* get container (e.g. extended partition) */
+    while (fdisk_table_next_partition(tb, itr, &pa) == 0)
+    {
+        if (fdisk_partition_is_nested(pa))
+        {
+            DBG(TABLE, ul_debug("nested detected, using tree"));
+            tree = SCOLS_FL_TREE;
+            break;
+        }
+    }
+
+    table = scols_new_table();
+    if (!table) goto done;
+    scols_table_enable_maxout(table, 1);
+    scols_table_enable_nowrap(table, 1);
 
 #if !defined(HAVE_LIBNCURSESW) || !defined(HAVE_WIDECHAR)
-	scols_table_enable_ascii(table, 1);
+    scols_table_enable_ascii(table, 1);
 #endif
 
-	/* headers */
-	for (i = 0; i < cf->nfields; i++) {
-		int fl = 0;
-		const struct fdisk_field *field =
-				fdisk_label_get_field(lb, cf->fields[i]);
-		if (!field)
-			continue;
-
-		if (fdisk_field_is_number(field))
-			fl |= SCOLS_FL_RIGHT;
-		if (fdisk_field_get_id(field) == FDISK_FIELD_TYPE)
-			fl |= SCOLS_FL_TRUNC;
-		if (tree && fdisk_field_get_id(field) == FDISK_FIELD_DEVICE)
-			fl |= SCOLS_FL_TREE;
-
-		if (!scols_table_new_column(table,
-				_(fdisk_field_get_name(field)),
-				fdisk_field_get_width(field), fl))
-			goto done;
-	}
-
-	/* data */
-	fdisk_reset_iter(itr, FDISK_ITER_FORWARD);
-
-	while (fdisk_table_next_partition(tb, itr, &pa) == 0) {
-		struct libscols_line *parent = fdisk_partition_is_nested(pa) ? ln_cont : NULL;
-
-		ln = scols_table_new_line(table, parent);
-		if (!ln)
-			goto done;
-		for (i = 0; i < cf->nfields; i++) {
-			char *cdata = NULL;
-
-			if (fdisk_partition_to_string(pa, cf->cxt,
-					cf->fields[i], &cdata))
-				continue;
-			scols_line_refer_data(ln, i, cdata);
-		}
-		if (tree && fdisk_partition_is_container(pa))
-			ln_cont = ln;
-
-		scols_line_set_userdata(ln, (void *) pa);
-		fdisk_ref_partition(pa);
-	}
-
-	if (scols_table_is_empty(table))
-		goto done;
-
-	scols_table_reduce_termwidth(table, ARROW_CURSOR_WIDTH);
-	scols_print_table_to_string(table, &res);
-
-	/* scols_* code might reorder lines, let's reorder @tb according to the
-	 * final output (it's no problem because partitions are addressed by
-	 * parno stored within struct fdisk_partition)  */
-
-	/* remove all */
-	fdisk_reset_table(tb);
-
-	s_itr = scols_new_iter(SCOLS_ITER_FORWARD);
-	if (!s_itr)
-		goto done;
-
-	/* add all in the right order (don't forget the output is tree) */
-	while (scols_table_next_line(table, s_itr, &ln) == 0) {
-		if (scols_line_get_parent(ln))
-			continue;
-		if (partition_from_scols(tb, ln))
-			break;
-	}
+    /* headers */
+    for (i = 0; i < cf->nfields; i++)
+    {
+        int                       fl = 0;
+        const struct fdisk_field* field
+            = fdisk_label_get_field(lb, cf->fields[i]);
+        if (!field) continue;
+
+        if (fdisk_field_is_number(field)) fl |= SCOLS_FL_RIGHT;
+        if (fdisk_field_get_id(field) == FDISK_FIELD_TYPE) fl |= SCOLS_FL_TRUNC;
+        if (tree && fdisk_field_get_id(field) == FDISK_FIELD_DEVICE)
+            fl |= SCOLS_FL_TREE;
+
+        if (!scols_table_new_column(table, _(fdisk_field_get_name(field)),
+                                    fdisk_field_get_width(field), fl))
+            goto done;
+    }
+
+    /* data */
+    fdisk_reset_iter(itr, FDISK_ITER_FORWARD);
+
+    while (fdisk_table_next_partition(tb, itr, &pa) == 0)
+    {
+        struct libscols_line* parent
+            = fdisk_partition_is_nested(pa) ? ln_cont : NULL;
+
+        ln = scols_table_new_line(table, parent);
+        if (!ln) goto done;
+        for (i = 0; i < cf->nfields; i++)
+        {
+            char* cdata = NULL;
+
+            if (fdisk_partition_to_string(pa, cf->cxt, cf->fields[i], &cdata))
+                continue;
+            scols_line_refer_data(ln, i, cdata);
+        }
+        if (tree && fdisk_partition_is_container(pa)) ln_cont = ln;
+
+        scols_line_set_userdata(ln, (void*)pa);
+        fdisk_ref_partition(pa);
+    }
+
+    if (scols_table_is_empty(table)) goto done;
+
+    scols_table_reduce_termwidth(table, ARROW_CURSOR_WIDTH);
+    scols_print_table_to_string(table, &res);
+
+    /* scols_* code might reorder lines, let's reorder @tb according to the
+     * final output (it's no problem because partitions are addressed by
+     * parno stored within struct fdisk_partition)  */
+
+    /* remove all */
+    fdisk_reset_table(tb);
+
+    s_itr = scols_new_iter(SCOLS_ITER_FORWARD);
+    if (!s_itr) goto done;
+
+    /* add all in the right order (don't forget the output is tree) */
+    while (scols_table_next_line(table, s_itr, &ln) == 0)
+    {
+        if (scols_line_get_parent(ln)) continue;
+        if (partition_from_scols(tb, ln)) break;
+    }
 done:
-	scols_unref_table(table);
-	scols_free_iter(s_itr);
-	fdisk_free_iter(itr);
+    scols_unref_table(table);
+    scols_free_iter(s_itr);
+    fdisk_free_iter(itr);
 
-	return res;
+    return res;
 }
 
-static void cfdisk_free_lines(struct cfdisk *cf)
+static void cfdisk_free_lines(struct cfdisk* cf)
 {
-	size_t i = 0;
-	while(i < cf->nlines) {
-		scols_unref_table(cf->lines[i].extra);
+    size_t i = 0;
+    while (i < cf->nlines)
+    {
+        scols_unref_table(cf->lines[i].extra);
 
-		DBG(UI, ul_debug("delete window: %p",
-				cf->lines[i].w));
+        DBG(UI, ul_debug("delete window: %p", cf->lines[i].w));
 
-		if (cf->lines[i].w)
-			delwin(cf->lines[i].w);
-		cf->lines[i].w = NULL;
-		++i;
-	}
-	cf->act_win = NULL;
-	free(cf->lines);
-	cf->lines = NULL;
+        if (cf->lines[i].w) delwin(cf->lines[i].w);
+        cf->lines[i].w = NULL;
+        ++i;
+    }
+    cf->act_win = NULL;
+    free(cf->lines);
+    cf->lines = NULL;
 }
 /*
  * Read data about partitions from libfdisk and prepare output lines.
  */
-static int lines_refresh(struct cfdisk *cf)
+static int lines_refresh(struct cfdisk* cf)
 {
-	int rc;
-	char *p;
-	size_t i;
+    int    rc;
+    char*  p;
+    size_t i;
 
-	assert(cf);
+    assert(cf);
 
-	DBG(TABLE, ul_debug("refreshing buffer"));
+    DBG(TABLE, ul_debug("refreshing buffer"));
 
-	free(cf->linesbuf);
-	cfdisk_free_lines(cf);
-	cf->linesbuf = NULL;
-	cf->linesbufsz = 0;
-	cf->lines = NULL;
-	cf->nlines = 0;
+    free(cf->linesbuf);
+    cfdisk_free_lines(cf);
+    cf->linesbuf   = NULL;
+    cf->linesbufsz = 0;
+    cf->lines      = NULL;
+    cf->nlines     = 0;
 
-	fdisk_unref_table(cf->table);
-	cf->table = NULL;
+    fdisk_unref_table(cf->table);
+    cf->table = NULL;
 
-	/* read partitions and free spaces into cf->table */
-	rc = fdisk_get_partitions(cf->cxt, &cf->table);
-	if (!rc)
-		rc = fdisk_get_freespaces(cf->cxt, &cf->table);
-	if (rc)
-		return rc;
+    /* read partitions and free spaces into cf->table */
+    rc        = fdisk_get_partitions(cf->cxt, &cf->table);
+    if (!rc) rc = fdisk_get_freespaces(cf->cxt, &cf->table);
+    if (rc) return rc;
 
-	cf->linesbuf = table_to_string(cf, cf->table);
-	if (!cf->linesbuf)
-		return -ENOMEM;
+    cf->linesbuf = table_to_string(cf, cf->table);
+    if (!cf->linesbuf) return -ENOMEM;
 
-	cf->linesbufsz = strlen(cf->linesbuf);
-	cf->nlines = fdisk_table_get_nents(cf->table) + 1;	/* 1 for header line */
-	cf->page_sz = 0;
-	cf->wrong_order = fdisk_table_wrong_order(cf->table) ? 1 : 0;
+    cf->linesbufsz = strlen(cf->linesbuf);
+    cf->nlines  = fdisk_table_get_nents(cf->table) + 1; /* 1 for header line */
+    cf->page_sz = 0;
+    cf->wrong_order = fdisk_table_wrong_order(cf->table) ? 1 : 0;
 
-	if (MENU_START_LINE - TABLE_START_LINE < cf->nlines)
-		cf->page_sz = MENU_START_LINE - TABLE_START_LINE - 1;
+    if (MENU_START_LINE - TABLE_START_LINE < cf->nlines)
+        cf->page_sz = MENU_START_LINE - TABLE_START_LINE - 1;
 
-	cf->lines = xcalloc(cf->nlines, sizeof(struct cfdisk_line));
+    cf->lines = xcalloc(cf->nlines, sizeof(struct cfdisk_line));
 
-	for (p = cf->linesbuf, i = 0; p && i < cf->nlines; i++) {
-		cf->lines[i].data = p;
-		p = strchr(p, '\n');
-		if (p) {
-			*p = '\0';
-			p++;
-		}
-		cf->lines[i].extra = scols_new_table();
-		scols_table_enable_noheadings(cf->lines[i].extra, 1);
-		scols_table_new_column(cf->lines[i].extra, NULL, 0, SCOLS_FL_RIGHT);
-		scols_table_new_column(cf->lines[i].extra, NULL, 0, SCOLS_FL_TRUNC);
-	}
+    for (p = cf->linesbuf, i = 0; p && i < cf->nlines; i++)
+    {
+        cf->lines[i].data = p;
+        p                 = strchr(p, '\n');
+        if (p)
+        {
+            *p = '\0';
+            p++;
+        }
+        cf->lines[i].extra = scols_new_table();
+        scols_table_enable_noheadings(cf->lines[i].extra, 1);
+        scols_table_new_column(cf->lines[i].extra, NULL, 0, SCOLS_FL_RIGHT);
+        scols_table_new_column(cf->lines[i].extra, NULL, 0, SCOLS_FL_TRUNC);
+    }
 
-	return 0;
+    return 0;
 }
 
-static struct fdisk_partition *get_current_partition(struct cfdisk *cf)
+static struct fdisk_partition* get_current_partition(struct cfdisk* cf)
 {
-	assert(cf);
-	assert(cf->table);
+    assert(cf);
+    assert(cf->table);
 
-	return fdisk_table_get_partition(cf->table, cf->lines_idx);
+    return fdisk_table_get_partition(cf->table, cf->lines_idx);
 }
 
-static int is_freespace(struct cfdisk *cf, size_t i)
+static int is_freespace(struct cfdisk* cf, size_t i)
 {
-	struct fdisk_partition *pa;
+    struct fdisk_partition* pa;
 
-	assert(cf);
-	assert(cf->table);
+    assert(cf);
+    assert(cf->table);
 
-	pa = fdisk_table_get_partition(cf->table, i);
-	return fdisk_partition_is_freespace(pa);
+    pa = fdisk_table_get_partition(cf->table, i);
+    return fdisk_partition_is_freespace(pa);
 }
 
 /* converts libfdisk FDISK_ASKTYPE_MENU to cfdisk menu and returns user's
  * response back to libfdisk
  */
-static int ask_menu(struct fdisk_ask *ask, struct cfdisk *cf)
-{
-	struct cfdisk_menuitem *d, *cm;
-	int key;
-	size_t i = 0, nitems;
-	const char *name, *desc;
-
-	assert(ask);
-	assert(cf);
-
-	/* create cfdisk menu according to libfdisk ask-menu, note that the
-	 * last cm[] item has to be empty -- so nitems + 1 */
-	nitems = fdisk_ask_menu_get_nitems(ask);
-	cm = xcalloc(nitems + 1, sizeof(struct cfdisk_menuitem));
-
-	for (i = 0; i < nitems; i++) {
-		if (fdisk_ask_menu_get_item(ask, i, &key, &name, &desc))
-			break;
-		cm[i].key = key;
-		cm[i].desc = desc;
-		cm[i].name = name;
-	}
-
-	/* make the new menu active */
-	menu_push(cf, cm);
-	ui_draw_menu(cf);
-	refresh();
-
-	/* wait for keys */
-	while (!sig_die) {
-		key = getch();
-
-		if (sig_die)
-			break;
-		if (sig_resize)
-			ui_menu_resize(cf);
-		if (ui_menu_move(cf, key) == 0)
-			continue;
-
-		switch (key) {
-		case KEY_ENTER:
-		case '\n':
-		case '\r':
-			d = menu_get_menuitem(cf, cf->menu->idx);
-			if (d)
-				fdisk_ask_menu_set_result(ask, d->key);
-			menu_pop(cf);
-			free(cm);
-			return 0;
-		}
-	}
-
-	if (sig_die)
-		die_on_signal();
-
-	menu_pop(cf);
-	free(cm);
-	return -1;
+static int ask_menu(struct fdisk_ask* ask, struct cfdisk* cf)
+{
+    struct cfdisk_menuitem *d, *cm;
+    int                     key;
+    size_t                  i = 0, nitems;
+    const char *            name, *desc;
+
+    assert(ask);
+    assert(cf);
+
+    /* create cfdisk menu according to libfdisk ask-menu, note that the
+     * last cm[] item has to be empty -- so nitems + 1 */
+    nitems = fdisk_ask_menu_get_nitems(ask);
+    cm     = xcalloc(nitems + 1, sizeof(struct cfdisk_menuitem));
+
+    for (i = 0; i < nitems; i++)
+    {
+        if (fdisk_ask_menu_get_item(ask, i, &key, &name, &desc)) break;
+        cm[i].key  = key;
+        cm[i].desc = desc;
+        cm[i].name = name;
+    }
+
+    /* make the new menu active */
+    menu_push(cf, cm);
+    ui_draw_menu(cf);
+    refresh();
+
+    /* wait for keys */
+    while (!sig_die)
+    {
+        key = getch();
+
+        if (sig_die) break;
+        if (sig_resize) ui_menu_resize(cf);
+        if (ui_menu_move(cf, key) == 0) continue;
+
+        switch (key)
+        {
+            case KEY_ENTER:
+            case '\n':
+            case '\r':
+                d = menu_get_menuitem(cf, cf->menu->idx);
+                if (d) fdisk_ask_menu_set_result(ask, d->key);
+                menu_pop(cf);
+                free(cm);
+                return 0;
+        }
+    }
+
+    if (sig_die) die_on_signal();
+
+    menu_pop(cf);
+    free(cm);
+    return -1;
 }
 
 /* libfdisk callback
  */
-static int ask_callback(struct fdisk_context *cxt __attribute__((__unused__)),
-			struct fdisk_ask *ask,
-			void *data __attribute__((__unused__)))
-{
-	int rc = 0;
-
-	assert(ask);
-
-	switch(fdisk_ask_get_type(ask)) {
-	case FDISK_ASKTYPE_INFO:
-		ui_info(fdisk_ask_print_get_mesg(ask));
-		break;
-	case FDISK_ASKTYPE_WARNX:
-		ui_warnx(fdisk_ask_print_get_mesg(ask));
-		break;
-	case FDISK_ASKTYPE_WARN:
-		ui_warn(fdisk_ask_print_get_mesg(ask));
-		break;
-	case FDISK_ASKTYPE_MENU:
-		ask_menu(ask, (struct cfdisk *) data);
-		break;
-	default:
-		ui_warnx(_("internal error: unsupported dialog type %d"),
-			fdisk_ask_get_type(ask));
-		return -EINVAL;
-	}
-	return rc;
+static int ask_callback(struct fdisk_context* cxt __attribute__((__unused__)),
+                        struct fdisk_ask*     ask,
+                        void*                 data __attribute__((__unused__)))
+{
+    int rc = 0;
+
+    assert(ask);
+
+    switch (fdisk_ask_get_type(ask))
+    {
+        case FDISK_ASKTYPE_INFO: ui_info(fdisk_ask_print_get_mesg(ask)); break;
+        case FDISK_ASKTYPE_WARNX:
+            ui_warnx(fdisk_ask_print_get_mesg(ask));
+            break;
+        case FDISK_ASKTYPE_WARN: ui_warn(fdisk_ask_print_get_mesg(ask)); break;
+        case FDISK_ASKTYPE_MENU: ask_menu(ask, (struct cfdisk*)data); break;
+        default:
+            ui_warnx(_("internal error: unsupported dialog type %d"),
+                     fdisk_ask_get_type(ask));
+            return -EINVAL;
+    }
+    return rc;
 }
 
 static int ui_end(void)
 {
-	if (!ui_enabled)
-		return -EINVAL;
+    if (!ui_enabled) return -EINVAL;
 
 #if defined(HAVE_SLCURSES_H) || defined(HAVE_SLANG_SLCURSES_H)
-	SLsmg_gotorc(ui_lines - 1, 0);
-	SLsmg_refresh();
+    SLsmg_gotorc(ui_lines - 1, 0);
+    SLsmg_refresh();
 #else
-	mvcur(0, ui_cols - 1, ui_lines-1, 0);
+    mvcur(0, ui_cols - 1, ui_lines - 1, 0);
 #endif
-	curs_set(1);
-	nl();
-	endwin();
-	printf("\n");
-	ui_enabled = 0;
-	return 0;
-}
-
-static void ui_vprint_center(size_t line, int attrs, const char *fmt, va_list ap)
-{
-	size_t width;
-	char *buf = NULL;
-
-	move(line, 0);
-	clrtoeol();
-
-	xvasprintf(&buf, fmt, ap);
-
-	width = mbs_safe_width(buf);
-	if (width > (size_t) ui_cols) {
-		char *p = strrchr(buf + ui_cols, ' ');
-		if (!p)
-			p = buf + ui_cols;
-		*p = '\0';
-		if (line + 1 >= ui_lines)
-			line--;
-		attron(attrs);
-		mvaddstr(line, 0, buf);
-		mvaddstr(line + 1, 0, p+1);
-		attroff(attrs);
-	} else {
-		attron(attrs);
-		mvaddstr(line, (ui_cols - width) / 2, buf);
-		attroff(attrs);
-	}
-	free(buf);
-}
-
-static void ui_center(size_t line, const char *fmt, ...)
-{
-	va_list ap;
-	va_start(ap, fmt);
-	ui_vprint_center(line, 0, fmt, ap);
-	va_end(ap);
-}
-
-static void ui_warnx(const char *fmt, ...)
-{
-	va_list ap;
-	va_start(ap, fmt);
-	if (ui_enabled)
-		ui_vprint_center(WARN_LINE,
-			colors_wanted() ? COLOR_PAIR(CFDISK_CL_WARNING) : 0,
-			fmt, ap);
-	else {
-		vfprintf(stderr, fmt, ap);
-		fputc('\n', stderr);
-	}
-	va_end(ap);
-}
-
-static void ui_warn(const char *fmt, ...)
-{
-	char *fmt_m;
-	va_list ap;
-
-	xasprintf(&fmt_m, "%s: %m", fmt);
-
-	va_start(ap, fmt);
-	if (ui_enabled)
-		ui_vprint_center(WARN_LINE,
-			colors_wanted() ? COLOR_PAIR(CFDISK_CL_WARNING) : 0,
-			fmt_m, ap);
-	else {
-		vfprintf(stderr, fmt_m, ap);
-		fputc('\n', stderr);
-	}
-	va_end(ap);
-	free(fmt_m);
+    curs_set(1);
+    nl();
+    endwin();
+    printf("\n");
+    ui_enabled = 0;
+    return 0;
+}
+
+static void ui_vprint_center(size_t line, int attrs, const char* fmt,
+                             va_list ap)
+{
+    size_t width;
+    char*  buf = NULL;
+
+    move(line, 0);
+    clrtoeol();
+
+    xvasprintf(&buf, fmt, ap);
+
+    width = mbs_safe_width(buf);
+    if (width > (size_t)ui_cols)
+    {
+        char* p = strrchr(buf + ui_cols, ' ');
+        if (!p) p = buf + ui_cols;
+        *p = '\0';
+        if (line + 1 >= ui_lines) line--;
+        attron(attrs);
+        mvaddstr(line, 0, buf);
+        mvaddstr(line + 1, 0, p + 1);
+        attroff(attrs);
+    }
+    else
+    {
+        attron(attrs);
+        mvaddstr(line, (ui_cols - width) / 2, buf);
+        attroff(attrs);
+    }
+    free(buf);
+}
+
+static void ui_center(size_t line, const char* fmt, ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+    ui_vprint_center(line, 0, fmt, ap);
+    va_end(ap);
+}
+
+static void ui_warnx(const char* fmt, ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+    if (ui_enabled)
+        ui_vprint_center(WARN_LINE,
+                         colors_wanted() ? COLOR_PAIR(CFDISK_CL_WARNING) : 0,
+                         fmt, ap);
+    else
+    {
+        vfprintf(stderr, fmt, ap);
+        fputc('\n', stderr);
+    }
+    va_end(ap);
+}
+
+static void ui_warn(const char* fmt, ...)
+{
+    char*   fmt_m;
+    va_list ap;
+
+    xasprintf(&fmt_m, "%s: %m", fmt);
+
+    va_start(ap, fmt);
+    if (ui_enabled)
+        ui_vprint_center(WARN_LINE,
+                         colors_wanted() ? COLOR_PAIR(CFDISK_CL_WARNING) : 0,
+                         fmt_m, ap);
+    else
+    {
+        vfprintf(stderr, fmt_m, ap);
+        fputc('\n', stderr);
+    }
+    va_end(ap);
+    free(fmt_m);
 }
 
 static void ui_clean_warn(void)
 {
-	move(WARN_LINE, 0);
-	clrtoeol();
+    move(WARN_LINE, 0);
+    clrtoeol();
 }
 
-static int __attribute__((__noreturn__)) ui_err(int rc, const char *fmt, ...)
-		{
-	va_list ap;
-	ui_end();
+static int __attribute__((__noreturn__)) ui_err(int rc, const char* fmt, ...)
+{
+    va_list ap;
+    ui_end();
 
-	va_start(ap, fmt);
-	fprintf(stderr, "%s: ", program_invocation_short_name);
-	vfprintf(stderr, fmt, ap);
-	fprintf(stderr, ": %s\n", strerror(errno));
-	va_end(ap);
+    va_start(ap, fmt);
+    fprintf(stderr, "%s: ", program_invocation_short_name);
+    vfprintf(stderr, fmt, ap);
+    fprintf(stderr, ": %s\n", strerror(errno));
+    va_end(ap);
 
-	exit(rc);
+    exit(rc);
 }
 
-static int __attribute__((__noreturn__)) ui_errx(int rc, const char *fmt, ...)
-		{
-	va_list ap;
-	ui_end();
+static int __attribute__((__noreturn__)) ui_errx(int rc, const char* fmt, ...)
+{
+    va_list ap;
+    ui_end();
 
-	va_start(ap, fmt);
-	fprintf(stderr, "%s: ", program_invocation_short_name);
-	vfprintf(stderr, fmt, ap);
-	fputc('\n', stderr);
-	va_end(ap);
+    va_start(ap, fmt);
+    fprintf(stderr, "%s: ", program_invocation_short_name);
+    vfprintf(stderr, fmt, ap);
+    fputc('\n', stderr);
+    va_end(ap);
 
-	exit(rc);
+    exit(rc);
 }
 
-static void ui_info(const char *fmt, ...)
+static void ui_info(const char* fmt, ...)
 {
-	va_list ap;
-	va_start(ap, fmt);
-	if (ui_enabled)
-		ui_vprint_center(INFO_LINE,
-				colors_wanted() ? COLOR_PAIR(CFDISK_CL_INFO) : 0,
-				fmt, ap);
-	else {
-		vfprintf(stdout, fmt, ap);
-		fputc('\n', stdout);
-	}
-	va_end(ap);
+    va_list ap;
+    va_start(ap, fmt);
+    if (ui_enabled)
+        ui_vprint_center(INFO_LINE,
+                         colors_wanted() ? COLOR_PAIR(CFDISK_CL_INFO) : 0, fmt,
+                         ap);
+    else
+    {
+        vfprintf(stdout, fmt, ap);
+        fputc('\n', stdout);
+    }
+    va_end(ap);
 }
 
 static void ui_clean_info(void)
 {
-	move(INFO_LINE, 0);
-	clrtoeol();
+    move(INFO_LINE, 0);
+    clrtoeol();
 }
 
-static void ui_hint(const char *fmt, ...)
+static void ui_hint(const char* fmt, ...)
 {
-	va_list ap;
-	va_start(ap, fmt);
-	if (ui_enabled)
-		ui_vprint_center(HINT_LINE, A_BOLD, fmt, ap);
-	else {
-		vfprintf(stdout, fmt, ap);
-		fputc('\n', stdout);
-	}
-	va_end(ap);
+    va_list ap;
+    va_start(ap, fmt);
+    if (ui_enabled) ui_vprint_center(HINT_LINE, A_BOLD, fmt, ap);
+    else
+    {
+        vfprintf(stdout, fmt, ap);
+        fputc('\n', stdout);
+    }
+    va_end(ap);
 }
 
 static void ui_clean_hint(void)
 {
-	move(HINT_LINE, 0);
-	clrtoeol();
+    move(HINT_LINE, 0);
+    clrtoeol();
 }
 
-
 static void sig_handler_die(int dummy __attribute__((__unused__)))
 {
-	sig_die = 1;
+    sig_die = 1;
 }
 
 static void sig_handler_resize(int dummy __attribute__((__unused__)))
 {
-	sig_resize = 1;
+    sig_resize = 1;
 }
 
-static void menu_refresh_size(struct cfdisk *cf)
+static void menu_refresh_size(struct cfdisk* cf)
 {
-	if (cf->menu && cf->menu->nitems)
-		cf->menu->page_sz = (cf->menu->nitems / (ui_lines - 4)) ? ui_lines - 4 : 0;
+    if (cf->menu && cf->menu->nitems)
+        cf->menu->page_sz
+            = (cf->menu->nitems / (ui_lines - 4)) ? ui_lines - 4 : 0;
 }
 
-static void menu_update_ignore(struct cfdisk *cf)
+static void menu_update_ignore(struct cfdisk* cf)
 {
-	char ignore[128] = { 0 };
-	int i = 0;
-	struct cfdisk_menu *m;
-	struct cfdisk_menuitem *d, *org = NULL;
-	size_t idx;
+    char                    ignore[128] = {0};
+    int                     i           = 0;
+    struct cfdisk_menu*     m;
+    struct cfdisk_menuitem *d, *org = NULL;
+    size_t                  idx;
 
-	assert(cf);
-	assert(cf->menu);
-	assert(cf->menu->ignore_cb);
+    assert(cf);
+    assert(cf->menu);
+    assert(cf->menu->ignore_cb);
 
-	m = cf->menu;
-	DBG(MENU, ul_debug("update menu ignored keys"));
+    m = cf->menu;
+    DBG(MENU, ul_debug("update menu ignored keys"));
 
-	i = m->ignore_cb(cf, ignore, sizeof(ignore));
-	ignore[i] = '\0';
+    i         = m->ignore_cb(cf, ignore, sizeof(ignore));
+    ignore[i] = '\0';
 
-	/* return if no change */
-	if ((!m->ignore && !*ignore)
-	    || (m->ignore && *ignore && strcmp(m->ignore, ignore) == 0)) {
-		    return;
-	}
+    /* return if no change */
+    if ((!m->ignore && !*ignore)
+        || (m->ignore && *ignore && strcmp(m->ignore, ignore) == 0))
+    {
+        return;
+    }
 
-	if (!m->prefkey)
-		org = menu_get_menuitem(cf, m->idx);
+    if (!m->prefkey) org = menu_get_menuitem(cf, m->idx);
 
-	free(m->ignore);
-	m->ignore = xstrdup(ignore);
-	m->nitems = 0;
+    free(m->ignore);
+    m->ignore = xstrdup(ignore);
+    m->nitems = 0;
 
-	for (d = m->items; d->name; d++) {
-		if (m->ignore && strchr(m->ignore, d->key))
-			continue;
-		m->nitems++;
-	}
+    for (d = m->items; d->name; d++)
+    {
+        if (m->ignore && strchr(m->ignore, d->key)) continue;
+        m->nitems++;
+    }
 
-	DBG(MENU, ul_debug("update menu preferred keys"));
+    DBG(MENU, ul_debug("update menu preferred keys"));
 
-	/* refresh menu index to be at the same menuitem or go to the first */
-	if (org && menu_get_menuitem_by_key(cf, org->key, &idx))
-		m->idx = idx;
-	else if (m->prefkey && menu_get_menuitem_by_key(cf, m->prefkey, &idx))
-		m->idx = idx;
-	else
-		m->idx = 0;
+    /* refresh menu index to be at the same menuitem or go to the first */
+    if (org && menu_get_menuitem_by_key(cf, org->key, &idx)) m->idx = idx;
+    else if (m->prefkey && menu_get_menuitem_by_key(cf, m->prefkey, &idx))
+        m->idx = idx;
+    else m->idx = 0;
 
-	menu_refresh_size(cf);
+    menu_refresh_size(cf);
 }
 
-static struct cfdisk_menu *menu_push(
-			struct cfdisk *cf,
-			struct cfdisk_menuitem *items)
+static struct cfdisk_menu* menu_push(struct cfdisk*          cf,
+                                     struct cfdisk_menuitem* items)
 {
-	struct cfdisk_menu *m = xcalloc(1, sizeof(*m));
-	struct cfdisk_menuitem *d;
+    struct cfdisk_menu*     m = xcalloc(1, sizeof(*m));
+    struct cfdisk_menuitem* d;
 
-	assert(cf);
+    assert(cf);
 
-	DBG(MENU, ul_debug("new menu"));
+    DBG(MENU, ul_debug("new menu"));
 
-	m->prev = cf->menu;
-	m->items = items;
+    m->prev  = cf->menu;
+    m->items = items;
 
-	for (d = m->items; d->name; d++) {
-		const char *name = _(d->name);
-		size_t len = mbs_safe_width(name);
-		if (len > m->width)
-			m->width = len;
-		m->nitems++;
-	}
+    for (d = m->items; d->name; d++)
+    {
+        const char* name = _(d->name);
+        size_t      len  = mbs_safe_width(name);
+        if (len > m->width) m->width = len;
+        m->nitems++;
+    }
 
-	cf->menu = m;
+    cf->menu = m;
 
-	menu_refresh_size(cf);
-	return m;
+    menu_refresh_size(cf);
+    return m;
 }
 
-static struct cfdisk_menu *menu_pop(struct cfdisk *cf)
+static struct cfdisk_menu* menu_pop(struct cfdisk* cf)
 {
-	struct cfdisk_menu *m = NULL;
+    struct cfdisk_menu* m = NULL;
 
-	assert(cf);
+    assert(cf);
 
-	DBG(MENU, ul_debug("pop menu"));
+    DBG(MENU, ul_debug("pop menu"));
 
-	if (cf->menu) {
-		m = cf->menu->prev;
-		free(cf->menu->ignore);
-		free(cf->menu->title);
-		free(cf->menu);
-	}
-	cf->menu = m;
-	return cf->menu;
+    if (cf->menu)
+    {
+        m = cf->menu->prev;
+        free(cf->menu->ignore);
+        free(cf->menu->title);
+        free(cf->menu);
+    }
+    cf->menu = m;
+    return cf->menu;
 }
 
-static void menu_set_title(struct cfdisk_menu *m, const char *title)
+static void menu_set_title(struct cfdisk_menu* m, const char* title)
 {
-	char *str = NULL;
+    char* str = NULL;
 
-	if (title) {
-		size_t len =  mbs_safe_width(title);
-		if (len + MENU_TITLE_PADDING > m->width)
-			m->width = len + MENU_TITLE_PADDING;
-		str = xstrdup(title);
-	}
-	m->title = str;
+    if (title)
+    {
+        size_t len = mbs_safe_width(title);
+        if (len + MENU_TITLE_PADDING > m->width)
+            m->width = len + MENU_TITLE_PADDING;
+        str = xstrdup(title);
+    }
+    m->title = str;
 }
 
-
-static int ui_init(struct cfdisk *cf __attribute__((__unused__)))
+static int ui_init(struct cfdisk* cf __attribute__((__unused__)))
 {
-	struct sigaction sa;
+    struct sigaction sa;
 
-	DBG(UI, ul_debug("init"));
+    DBG(UI, ul_debug("init"));
 
-	/* setup SIGCHLD handler */
-	sigemptyset(&sa.sa_mask);
-	sa.sa_flags = 0;
-	sa.sa_handler = sig_handler_die;
-	sigaction(SIGINT, &sa, NULL);
-	sigaction(SIGTERM, &sa, NULL);
+    /* setup SIGCHLD handler */
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags   = 0;
+    sa.sa_handler = sig_handler_die;
+    sigaction(SIGINT, &sa, NULL);
+    sigaction(SIGTERM, &sa, NULL);
 
-	sa.sa_handler = sig_handler_resize;
-	sigaction(SIGWINCH, &sa, NULL);
+    sa.sa_handler = sig_handler_resize;
+    sigaction(SIGWINCH, &sa, NULL);
 
-	ui_enabled = 1;
-	initscr();
+    ui_enabled = 1;
+    initscr();
 
 #ifdef HAVE_USE_DEFAULT_COLORS
-	if (colors_wanted() && has_colors()) {
-		size_t i;
-
-		start_color();
-		use_default_colors();
-		for (i = 1; i < ARRAY_SIZE(color_pairs); i++)		/* yeah, start from 1! */
-			init_pair(i, color_pairs[i][0], color_pairs[i][1]);
-	}
+    if (colors_wanted() && has_colors())
+    {
+        size_t i;
+
+        start_color();
+        use_default_colors();
+        for (i = 1; i < ARRAY_SIZE(color_pairs); i++) /* yeah, start from 1! */
+            init_pair(i, color_pairs[i][0], color_pairs[i][1]);
+    }
 #else
-	colors_off();
+    colors_off();
 #endif
 
-	cbreak();
-	noecho();
-	nonl();
-	curs_set(0);
-	keypad(stdscr, TRUE);
+    cbreak();
+    noecho();
+    nonl();
+    curs_set(0);
+    keypad(stdscr, TRUE);
 
-	return 0;
+    return 0;
 }
 
 /* "[ string ]" */
-#define MENU_H_ITEMWIDTH(m)	(  MENU_H_PRESTR_SZ \
-				 + MENU_H_SPADDING \
-				 + (m)->width \
-				 + MENU_H_SPADDING \
-				 + MENU_H_POSTSTR_SZ)
+#define MENU_H_ITEMWIDTH(m)                                                    \
+    (MENU_H_PRESTR_SZ + MENU_H_SPADDING + (m)->width + MENU_H_SPADDING         \
+     + MENU_H_POSTSTR_SZ)
 
-#define MENU_V_ITEMWIDTH(m)	(MENU_V_SPADDING + (m)->width + MENU_V_SPADDING)
+#define MENU_V_ITEMWIDTH(m) (MENU_V_SPADDING + (m)->width + MENU_V_SPADDING)
 
-
-static size_t menuitem_get_line(struct cfdisk *cf, size_t idx)
+static size_t menuitem_get_line(struct cfdisk* cf, size_t idx)
 {
-	struct cfdisk_menu *m = cf->menu;
+    struct cfdisk_menu* m = cf->menu;
 
-	if (m->vertical) {
-		if (!m->page_sz)				/* small menu */
-			return (ui_lines - (cf->menu->nitems + 1)) / 2 + idx;
-		return (idx % m->page_sz) + 1;
-	}
+    if (m->vertical)
+    {
+        if (!m->page_sz) /* small menu */
+            return (ui_lines - (cf->menu->nitems + 1)) / 2 + idx;
+        return (idx % m->page_sz) + 1;
+    }
 
-	{
-		size_t len = MENU_H_ITEMWIDTH(m) + MENU_H_BETWEEN; /** item width */
-		size_t items = ui_cols / len;			/* items per line */
+    {
+        size_t len   = MENU_H_ITEMWIDTH(m) + MENU_H_BETWEEN; /** item width */
+        size_t items = ui_cols / len; /* items per line */
 
-		if (items == 0)
-			return 0;
-		return MENU_START_LINE + ((idx / items));
-	}
+        if (items == 0) return 0;
+        return MENU_START_LINE + ((idx / items));
+    }
 }
 
-static int menuitem_get_column(struct cfdisk *cf, size_t idx)
+static int menuitem_get_column(struct cfdisk* cf, size_t idx)
 {
-	if (cf->menu->vertical) {
-		size_t nc = MENU_V_ITEMWIDTH(cf->menu);
-		if ((size_t) ui_cols <= nc)
-			return 0;
-		return (ui_cols - nc) / 2;
-	}
+    if (cf->menu->vertical)
+    {
+        size_t nc = MENU_V_ITEMWIDTH(cf->menu);
+        if ((size_t)ui_cols <= nc) return 0;
+        return (ui_cols - nc) / 2;
+    }
 
-	{
-		size_t len = MENU_H_ITEMWIDTH(cf->menu) + MENU_H_BETWEEN; /* item width */
-		size_t items = ui_cols / len;				/* items per line */
-		size_t extra = items < cf->menu->nitems ?		/* extra space on line */
-				ui_cols % len :				/* - multi-line menu */
-				ui_cols - (cf->menu->nitems * len);	/* - one line menu */
+    {
+        size_t len
+            = MENU_H_ITEMWIDTH(cf->menu) + MENU_H_BETWEEN; /* item width */
+        size_t items = ui_cols / len;                      /* items per line */
+        size_t extra
+            = items < cf->menu->nitems ? /* extra space on line */
+                  ui_cols % len
+                                       :              /* - multi-line menu */
+                  ui_cols - (cf->menu->nitems * len); /* - one line menu */
 
-		if (items == 0)
-			return 0;					/* hmm... no space */
+        if (items == 0) return 0; /* hmm... no space */
 
-		extra += MENU_H_BETWEEN;	/* add padding after last item to extra */
+        extra += MENU_H_BETWEEN; /* add padding after last item to extra */
 
-		if (idx < items)
-			return (idx * len) + (extra / 2);
-		return ((idx % items) * len) + (extra / 2);
-	}
+        if (idx < items) return (idx * len) + (extra / 2);
+        return ((idx % items) * len) + (extra / 2);
+    }
 }
 
-static int menuitem_on_page(struct cfdisk *cf, size_t idx)
+static int menuitem_on_page(struct cfdisk* cf, size_t idx)
 {
-	struct cfdisk_menu *m = cf->menu;
+    struct cfdisk_menu* m = cf->menu;
 
-	if (m->page_sz == 0 ||
-	    m->idx / m->page_sz == idx / m->page_sz)
-		return 1;
-	return 0;
+    if (m->page_sz == 0 || m->idx / m->page_sz == idx / m->page_sz) return 1;
+    return 0;
 }
 
-static struct cfdisk_menuitem *menu_get_menuitem(struct cfdisk *cf, size_t idx)
+static struct cfdisk_menuitem* menu_get_menuitem(struct cfdisk* cf, size_t idx)
 {
-	struct cfdisk_menuitem *d;
-	size_t i;
+    struct cfdisk_menuitem* d;
+    size_t                  i;
 
-	for (i = 0, d = cf->menu->items; d->name; d++) {
-		if (cf->menu->ignore && strchr(cf->menu->ignore, d->key))
-			continue;
-		if (i++ == idx)
-			return d;
-	}
+    for (i = 0, d = cf->menu->items; d->name; d++)
+    {
+        if (cf->menu->ignore && strchr(cf->menu->ignore, d->key)) continue;
+        if (i++ == idx) return d;
+    }
 
-	return NULL;
+    return NULL;
 }
 
-static struct cfdisk_menuitem *menu_get_menuitem_by_key(struct cfdisk *cf,
-							int key, size_t *idx)
+static struct cfdisk_menuitem* menu_get_menuitem_by_key(struct cfdisk* cf,
+                                                        int key, size_t* idx)
 {
-	struct cfdisk_menuitem *d;
+    struct cfdisk_menuitem* d;
 
-	for (*idx = 0, d = cf->menu->items; d->name; d++) {
-		if (cf->menu->ignore && strchr(cf->menu->ignore, d->key))
-			continue;
-		if (key == d->key)
-			return d;
-		(*idx)++;
-	}
+    for (*idx = 0, d = cf->menu->items; d->name; d++)
+    {
+        if (cf->menu->ignore && strchr(cf->menu->ignore, d->key)) continue;
+        if (key == d->key) return d;
+        (*idx)++;
+    }
 
-	return NULL;
+    return NULL;
 }
 
-static void ui_draw_menuitem(struct cfdisk *cf,
-			     struct cfdisk_menuitem *d,
-			     size_t idx)
+static void ui_draw_menuitem(struct cfdisk* cf, struct cfdisk_menuitem* d,
+                             size_t idx)
 {
-	char *buf, *ptr;
-	const char *name;
-	size_t width;
-	const size_t buf_sz = 80 * MB_CUR_MAX;
-	int ln, cl, vert = cf->menu->vertical;
+    char *       buf, *ptr;
+    const char*  name;
+    size_t       width;
+    const size_t buf_sz = 80 * MB_CUR_MAX;
+    int          ln, cl, vert = cf->menu->vertical;
+
+    if (!menuitem_on_page(cf, idx)) return; /* no visible item */
+    ln  = menuitem_get_line(cf, idx);
+    cl  = menuitem_get_column(cf, idx);
 
-	if (!menuitem_on_page(cf, idx))
-		return;		/* no visible item */
-	ln = menuitem_get_line(cf, idx);
-	cl = menuitem_get_column(cf, idx);
+    ptr = buf = xmalloc(buf_sz);
+    /* string width */
+    if (vert)
+    {
+        width = cf->menu->width + MENU_V_SPADDING;
+        memset(ptr, ' ', MENU_V_SPADDING);
+        ptr += MENU_V_SPADDING;
+    }
+    else width = MENU_H_SPADDING + cf->menu->width + MENU_H_SPADDING;
 
-	ptr = buf = xmalloc(buf_sz);
-	/* string width */
-	if (vert) {
-		width = cf->menu->width + MENU_V_SPADDING;
-		memset(ptr, ' ', MENU_V_SPADDING);
-		ptr += MENU_V_SPADDING;
-	} else
-		width = MENU_H_SPADDING + cf->menu->width + MENU_H_SPADDING;
+    name = _(d->name);
+    mbsalign(name, ptr, buf_sz, &width,
+             vert ? MBS_ALIGN_LEFT : MBS_ALIGN_CENTER, 0);
 
-	name = _(d->name);
-	mbsalign(name, ptr, buf_sz, &width,
-			vert ? MBS_ALIGN_LEFT : MBS_ALIGN_CENTER,
-			0);
+    DBG(MENU, ul_debug("menuitem: cl=%d, ln=%d, item='%s'", cl, ln, buf));
 
-	DBG(MENU, ul_debug("menuitem: cl=%d, ln=%d, item='%s'",
-			cl, ln, buf));
-
-	if (vert) {
-		mvaddch(ln, cl - 1, ACS_VLINE);
-		mvaddch(ln, cl + MENU_V_ITEMWIDTH(cf->menu), ACS_VLINE);
-	}
-
-	if (cf->menu->idx == idx)
-		standout();
-
-	if (vert)
-		mvprintw(ln, cl, "%s", buf);
-	else
-		mvprintw(ln, cl, "%s%s%s", MENU_H_PRESTR, buf, MENU_H_POSTSTR);
-	free(buf);
+    if (vert)
+    {
+        mvaddch(ln, cl - 1, ACS_VLINE);
+        mvaddch(ln, cl + MENU_V_ITEMWIDTH(cf->menu), ACS_VLINE);
+    }
 
-	if (cf->menu->idx == idx) {
-		standend();
-		if (d->desc)
-			ui_hint(_(d->desc));
-	}
+    if (cf->menu->idx == idx) standout();
+
+    if (vert) mvprintw(ln, cl, "%s", buf);
+    else mvprintw(ln, cl, "%s%s%s", MENU_H_PRESTR, buf, MENU_H_POSTSTR);
+    free(buf);
+
+    if (cf->menu->idx == idx)
+    {
+        standend();
+        if (d->desc) ui_hint(_(d->desc));
+    }
 }
 
-static void ui_clean_menu(struct cfdisk *cf)
+static void ui_clean_menu(struct cfdisk* cf)
 {
-	size_t i;
-	size_t lastline;
-	struct cfdisk_menu *m = cf->menu;
-	size_t ln = menuitem_get_line(cf, 0);
-
-	if (m->vertical)
-		lastline = ln + (m->page_sz ? m->page_sz : m->nitems);
-	else
-		lastline = menuitem_get_line(cf, m->nitems);
+    size_t              i;
+    size_t              lastline;
+    struct cfdisk_menu* m  = cf->menu;
+    size_t              ln = menuitem_get_line(cf, 0);
+
+    if (m->vertical) lastline = ln + (m->page_sz ? m->page_sz : m->nitems);
+    else lastline = menuitem_get_line(cf, m->nitems);
+
+    for (i = ln; i <= lastline; i++)
+    {
+        move(i, 0);
+        clrtoeol();
+        DBG(MENU, ul_debug("clean_menu: line %zu", i));
+    }
+    if (m->vertical)
+    {
+        move(ln - 1, 0);
+        clrtoeol();
+    }
+    ui_clean_hint();
+}
 
-	for (i = ln; i <= lastline; i++) {
-		move(i, 0);
-		clrtoeol();
-		DBG(MENU, ul_debug("clean_menu: line %zu", i));
-	}
-	if (m->vertical) {
-		move(ln - 1, 0);
-		clrtoeol();
-	}
-	ui_clean_hint();
-}
-
-static void ui_draw_menu(struct cfdisk *cf)
+static void ui_draw_menu(struct cfdisk* cf)
 {
-	struct cfdisk_menuitem *d;
-	struct cfdisk_menu *m;
-	size_t i = 0;
-	size_t ln = menuitem_get_line(cf, 0);
-	size_t nlines;
-
-	assert(cf);
-	assert(cf->menu);
-
-	DBG(MENU, ul_debug("draw start"));
-
-	ui_clean_menu(cf);
-	m = cf->menu;
-
-	if (m->vertical)
-		nlines = m->page_sz ? m->page_sz : m->nitems;
-	else
-		nlines = menuitem_get_line(cf, m->nitems);
-
-	if (m->ignore_cb)
-		menu_update_ignore(cf);
-	i = 0;
-	while ((d = menu_get_menuitem(cf, i)))
-		ui_draw_menuitem(cf, d, i++);
-
-	if (m->vertical) {
-		size_t cl = menuitem_get_column(cf, 0);
-		size_t curpg = m->page_sz ? m->idx / m->page_sz : 0;
-
-		/* corners and horizontal lines */
-		mvaddch(ln - 1, cl - 1, ACS_ULCORNER);
-		mvaddch(ln + nlines, cl - 1, ACS_LLCORNER);
-
-		for (i = 0; i < MENU_V_ITEMWIDTH(m); i++) {
-			mvaddch(ln - 1, cl + i, ACS_HLINE);
-			mvaddch(ln + nlines, cl + i, ACS_HLINE);
-		}
-
-		mvaddch(ln - 1, cl + i, ACS_URCORNER);
-		mvaddch(ln + nlines, cl + i, ACS_LRCORNER);
-
-		/* draw also lines around empty lines on last page */
-		if (m->page_sz &&
-		    m->nitems / m->page_sz == m->idx / m->page_sz) {
-			for (i = m->nitems % m->page_sz + 1; i <= m->page_sz; i++) {
-				mvaddch(i, cl - 1, ACS_VLINE);
-				mvaddch(i, cl + MENU_V_ITEMWIDTH(m), ACS_VLINE);
-			}
-		}
-		if (m->title) {
-			attron(A_BOLD);
-			mvprintw(ln - 1, cl, " %s ", m->title);
-			attroff(A_BOLD);
-		}
-		if (curpg != 0)
-			mvaddch(ln - 1, cl + MENU_V_ITEMWIDTH(m) - 2, ACS_UARROW);
-		if (m->page_sz && curpg < m->nitems / m->page_sz)
-			mvaddch(ln + nlines, cl + MENU_V_ITEMWIDTH(m) - 2, ACS_DARROW);
-	}
+    struct cfdisk_menuitem* d;
+    struct cfdisk_menu*     m;
+    size_t                  i  = 0;
+    size_t                  ln = menuitem_get_line(cf, 0);
+    size_t                  nlines;
+
+    assert(cf);
+    assert(cf->menu);
+
+    DBG(MENU, ul_debug("draw start"));
+
+    ui_clean_menu(cf);
+    m = cf->menu;
+
+    if (m->vertical) nlines = m->page_sz ? m->page_sz : m->nitems;
+    else nlines = menuitem_get_line(cf, m->nitems);
 
-	DBG(MENU, ul_debug("draw end."));
-}
+    if (m->ignore_cb) menu_update_ignore(cf);
+    i = 0;
+    while ((d = menu_get_menuitem(cf, i))) ui_draw_menuitem(cf, d, i++);
 
-inline static int extra_insert_pair(struct cfdisk_line *l, const char *name, const char *data)
+    if (m->vertical)
+    {
+        size_t cl    = menuitem_get_column(cf, 0);
+        size_t curpg = m->page_sz ? m->idx / m->page_sz : 0;
+
+        /* corners and horizontal lines */
+        mvaddch(ln - 1, cl - 1, ACS_ULCORNER);
+        mvaddch(ln + nlines, cl - 1, ACS_LLCORNER);
+
+        for (i = 0; i < MENU_V_ITEMWIDTH(m); i++)
+        {
+            mvaddch(ln - 1, cl + i, ACS_HLINE);
+            mvaddch(ln + nlines, cl + i, ACS_HLINE);
+        }
+
+        mvaddch(ln - 1, cl + i, ACS_URCORNER);
+        mvaddch(ln + nlines, cl + i, ACS_LRCORNER);
+
+        /* draw also lines around empty lines on last page */
+        if (m->page_sz && m->nitems / m->page_sz == m->idx / m->page_sz)
+        {
+            for (i = m->nitems % m->page_sz + 1; i <= m->page_sz; i++)
+            {
+                mvaddch(i, cl - 1, ACS_VLINE);
+                mvaddch(i, cl + MENU_V_ITEMWIDTH(m), ACS_VLINE);
+            }
+        }
+        if (m->title)
+        {
+            attron(A_BOLD);
+            mvprintw(ln - 1, cl, " %s ", m->title);
+            attroff(A_BOLD);
+        }
+        if (curpg != 0)
+            mvaddch(ln - 1, cl + MENU_V_ITEMWIDTH(m) - 2, ACS_UARROW);
+        if (m->page_sz && curpg < m->nitems / m->page_sz)
+            mvaddch(ln + nlines, cl + MENU_V_ITEMWIDTH(m) - 2, ACS_DARROW);
+    }
+
+    DBG(MENU, ul_debug("draw end."));
+}
+
+inline static int extra_insert_pair(struct cfdisk_line* l, const char* name,
+                                    const char* data)
 {
-	struct libscols_line *lsl;
-	int rc;
+    struct libscols_line* lsl;
+    int                   rc;
+
+    assert(l);
+    assert(l->extra);
+
+    if (!data || !*data) return 0;
 
-	assert(l);
-	assert(l->extra);
+    lsl = scols_table_new_line(l->extra, NULL);
+    if (!lsl) return -ENOMEM;
 
-	if (!data || !*data)
-		return 0;
+    rc = scols_line_set_data(lsl, 0, name);
+    if (!rc) rc = scols_line_set_data(lsl, 1, data);
 
-	lsl = scols_table_new_line(l->extra, NULL);
-	if (!lsl)
-		return -ENOMEM;
-
-	rc = scols_line_set_data(lsl, 0, name);
-	if (!rc)
-		rc = scols_line_set_data(lsl, 1, data);
-
-	return rc;
+    return rc;
 }
 
 #ifndef HAVE_LIBMOUNT
-static char *get_mountpoint(	struct cfdisk *cf __attribute__((unused)),
-				const char *tagname __attribute__((unused)),
-				const char *tagdata __attribute__((unused)))
+static char* get_mountpoint(struct cfdisk* cf __attribute__((unused)),
+                            const char*    tagname __attribute__((unused)),
+                            const char*    tagdata __attribute__((unused)))
 {
-	return NULL;
+    return NULL;
 }
 #else
-static char *get_mountpoint(struct cfdisk *cf, const char *tagname, const char *tagdata)
-{
-	struct libmnt_fs *fs = NULL;
-	char *target = NULL;
-	int mounted = 0;
-
-	assert(tagname);
-	assert(tagdata);
-
-	DBG(UI, ul_debug("asking for mountpoint [%s=%s]", tagname, tagdata));
-
-	if (!cf->mntcache)
-		cf->mntcache = mnt_new_cache();
-
-	/* 1st try between mounted filesystems */
-	if (!cf->mtab) {
-		cf->mtab = mnt_new_table();
-		if (cf->mtab) {
-			mnt_table_set_cache(cf->mtab, cf->mntcache);
-			mnt_table_parse_mtab(cf->mtab, NULL);
-		}
-	}
-
-	if (cf->mtab)
-		fs = mnt_table_find_tag(cf->mtab, tagname, tagdata, MNT_ITER_FORWARD);
-
-	/* 2nd try fstab */
-	if (!fs) {
-		if (!cf->fstab) {
-			cf->fstab = mnt_new_table();
-			if (cf->fstab) {
-				mnt_table_set_cache(cf->fstab, cf->mntcache);
-				if (mnt_table_parse_fstab(cf->fstab, NULL) != 0) {
-					mnt_unref_table(cf->fstab);
-					cf->fstab = NULL;
-				}
-			}
-		}
-		if (cf->fstab)
-			fs = mnt_table_find_tag(cf->fstab, tagname, tagdata, MNT_ITER_FORWARD);
-	} else
-		mounted = 1;
-
-	if (fs) {
-		if (mounted)
-			xasprintf(&target, _("%s (mounted)"), mnt_fs_get_target(fs));
-		else
-			target = xstrdup(mnt_fs_get_target(fs));
-	}
-
-	return target;
+static char* get_mountpoint(struct cfdisk* cf, const char* tagname,
+                            const char* tagdata)
+{
+    struct libmnt_fs* fs      = NULL;
+    char*             target  = NULL;
+    int               mounted = 0;
+
+    assert(tagname);
+    assert(tagdata);
+
+    DBG(UI, ul_debug("asking for mountpoint [%s=%s]", tagname, tagdata));
+
+    if (!cf->mntcache) cf->mntcache = mnt_new_cache();
+
+    /* 1st try between mounted filesystems */
+    if (!cf->mtab)
+    {
+        cf->mtab = mnt_new_table();
+        if (cf->mtab)
+        {
+            mnt_table_set_cache(cf->mtab, cf->mntcache);
+            mnt_table_parse_mtab(cf->mtab, NULL);
+        }
+    }
+
+    if (cf->mtab)
+        fs = mnt_table_find_tag(cf->mtab, tagname, tagdata, MNT_ITER_FORWARD);
+
+    /* 2nd try fstab */
+    if (!fs)
+    {
+        if (!cf->fstab)
+        {
+            cf->fstab = mnt_new_table();
+            if (cf->fstab)
+            {
+                mnt_table_set_cache(cf->fstab, cf->mntcache);
+                if (mnt_table_parse_fstab(cf->fstab, NULL) != 0)
+                {
+                    mnt_unref_table(cf->fstab);
+                    cf->fstab = NULL;
+                }
+            }
+        }
+        if (cf->fstab)
+            fs = mnt_table_find_tag(cf->fstab, tagname, tagdata,
+                                    MNT_ITER_FORWARD);
+    }
+    else mounted = 1;
+
+    if (fs)
+    {
+        if (mounted)
+            xasprintf(&target, _("%s (mounted)"), mnt_fs_get_target(fs));
+        else target = xstrdup(mnt_fs_get_target(fs));
+    }
+
+    return target;
 }
 #endif /* HAVE_LIBMOUNT */
 
-static void extra_prepare_data(struct cfdisk *cf)
-{
-	struct fdisk_partition *pa = get_current_partition(cf);
-	struct cfdisk_line *l = &cf->lines[cf->lines_idx];
-	char *data = NULL;
-	char *mountpoint = NULL;
-
-	DBG(UI, ul_debug("preparing extra data"));
-
-	/* string data should not equal an empty string */
-	if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_NAME, &data) && data) {
-		extra_insert_pair(l, _("Partition name:"), data);
-		if (!mountpoint)
-			mountpoint = get_mountpoint(cf, "PARTLABEL", data);
-		free(data);
-	}
-
-	if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_UUID, &data) && data) {
-		extra_insert_pair(l, _("Partition UUID:"), data);
-		if (!mountpoint)
-			mountpoint = get_mountpoint(cf, "PARTUUID", data);
-		free(data);
-	}
-
-	if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_TYPE, &data) && data) {
-		char *code = NULL, *type = NULL;
-
-		fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_TYPEID, &code);
-		xasprintf(&type, "%s (%s)", data, code);
-
-		extra_insert_pair(l, _("Partition type:"), type);
-		free(data);
-		free(code);
-		free(type);
-	}
-
-	if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_ATTR, &data) && data) {
-		extra_insert_pair(l, _("Attributes:"), data);
-		free(data);
-	}
-
-	/* for numeric data, only show non-zero rows */
-	if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_BSIZE, &data) && data) {
-		if (atoi(data))
-			extra_insert_pair(l, "BSIZE:", data);
-		free(data);
-	}
-
-	if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_CPG, &data) && data) {
-		if (atoi(data))
-			extra_insert_pair(l, "CPG:", data);
-		free(data);
-	}
-
-	if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_FSIZE, &data) && data) {
-		if (atoi(data))
-			extra_insert_pair(l, "FSIZE:", data);
-		free(data);
-	}
-
-	if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_FSUUID, &data) && data) {
-		extra_insert_pair(l, _("Filesystem UUID:"), data);
-		if (!mountpoint)
-			mountpoint = get_mountpoint(cf, "UUID", data);
-		free(data);
-	}
-
-	if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_FSLABEL, &data) && data) {
-		extra_insert_pair(l, _("Filesystem LABEL:"), data);
-		if (!mountpoint)
-			mountpoint = get_mountpoint(cf, "LABEL", data);
-		free(data);
-	}
-	if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_FSTYPE, &data) && data) {
-		extra_insert_pair(l, _("Filesystem:"), data);
-		free(data);
-	}
-
-	if (mountpoint) {
-		extra_insert_pair(l, _("Mountpoint:"), mountpoint);
-		free(mountpoint);
-	}
-}
-
-static int ui_draw_extra(struct cfdisk *cf)
-{
-	WINDOW *win_ex;
-	int wline = 1;
-	struct cfdisk_line *ln = &cf->lines[cf->lines_idx];
-	char *tbstr = NULL, *end;
-	int win_ex_start_line, win_height, tblen;
-	int ndatalines;
-
-	if (!cf->show_extra)
-		return 0;
-
-	DBG(UI, ul_debug("draw extra"));
-
-	assert(ln->extra);
-
-	if (cf->act_win) {
-		wclear(cf->act_win);
-		touchwin(stdscr);
-	}
-
-	if (scols_table_is_empty(ln->extra)) {
-		extra_prepare_data(cf);
-		if (scols_table_is_empty(ln->extra))
-			return 0;
-	}
-
-	ndatalines = fdisk_table_get_nents(cf->table) + 1;
-
-	/* nents + header + one free line */
-	win_ex_start_line = TABLE_START_LINE + ndatalines;
-	win_height = MENU_START_LINE - win_ex_start_line;
-	tblen = scols_table_get_nlines(ln->extra);
-
-	/* we can't get a single line of data under the partlist*/
-	if (win_height < 3)
-		return 1;
-
-	/* number of data lines + 2 for top/bottom lines */
-	win_height = win_height < tblen + 2 ? win_height : tblen + 2;
-
-	if ((size_t) win_ex_start_line + win_height + 1 < MENU_START_LINE)
-		win_ex_start_line = MENU_START_LINE - win_height;
-
-	win_ex = subwin(stdscr, win_height, ui_cols - 2, win_ex_start_line, 1);
-
-	scols_table_reduce_termwidth(ln->extra, 4);
-	scols_print_table_to_string(ln->extra, &tbstr);
-
-	end = tbstr;
-	while ((end = strchr(end, '\n')))
-		*end++ = '\0';
-
-	box(win_ex, 0, 0);
-
-	end = tbstr;
-	while (--win_height > 1) {
-		mvwaddstr(win_ex, wline++, 1 /* window column*/, tbstr);
-		tbstr += strlen(tbstr) + 1;
-	}
-	free(end);
-
-	if (ln->w)
-		delwin(ln->w);
-
-	DBG(UI, ul_debug("draw window: %p", win_ex));
-	touchwin(stdscr);
-	wrefresh(win_ex);
-
-	cf->act_win = ln->w = win_ex;
-	return 0;
-}
-
-static void ui_menu_goto(struct cfdisk *cf, int where)
-{
-	struct cfdisk_menuitem *d;
-	size_t old;
-
-	/* stop and begin/end for vertical menus */
-	if (cf->menu->vertical) {
-		if (where < 0)
-			where = 0;
-		else if (where > (int) cf->menu->nitems - 1)
-			where = cf->menu->nitems - 1;
-	} else {
-		/* continue from begin/end */
-		if (where < 0)
-			where = cf->menu->nitems - 1;
-		else if ((size_t) where > cf->menu->nitems - 1)
-			where = 0;
-	}
-	if ((size_t) where == cf->menu->idx)
-		return;
-
-	ui_clean_info();
-
-	old = cf->menu->idx;
-	cf->menu->idx = where;
-
-	if (!menuitem_on_page(cf, old)) {
-		ui_draw_menu(cf);
-		return;
-	}
-
-	d = menu_get_menuitem(cf, old);
-	ui_draw_menuitem(cf, d, old);
-
-	d = menu_get_menuitem(cf, where);
-	ui_draw_menuitem(cf, d, where);
-
-}
-
-static int ui_menu_move(struct cfdisk *cf, int key)
-{
-	struct cfdisk_menu *m;
-
-	assert(cf);
-	assert(cf->menu);
-
-	if (key == (int) ERR)
-		return 0;	/* ignore errors */
-
-	m = cf->menu;
-
-	DBG(MENU, ul_debug("menu move key >%c<.", key));
-
-	if (m->vertical)
-	{
-		switch (key) {
-		case KEY_DOWN:
-		case '\016':	/* ^N */
-		case 'j':	/* Vi-like alternative */
-			ui_menu_goto(cf, m->idx + 1);
-			return 0;
-		case KEY_UP:
-		case '\020':	/* ^P */
-		case 'k':	/* Vi-like alternative */
-			ui_menu_goto(cf, (int) m->idx - 1);
-			return 0;
-		case KEY_PPAGE:
-			if (m->page_sz) {
-				ui_menu_goto(cf, (int) m->idx - m->page_sz);
-				return 0;
-			}
-			/* fallthrough */
-		case KEY_HOME:
-			ui_menu_goto(cf, 0);
-			return 0;
-		case KEY_NPAGE:
-			if (m->page_sz) {
-				ui_menu_goto(cf, m->idx + m->page_sz);
-				return 0;
-			}
-			/* fallthrough */
-		case KEY_END:
-			ui_menu_goto(cf, m->nitems);
-			return 0;
-		}
-	} else {
-		switch (key) {
-		case KEY_RIGHT:
-		case '\t':
-			ui_menu_goto(cf, m->idx + 1);
-			return 0;
-		case KEY_LEFT:
+static void extra_prepare_data(struct cfdisk* cf)
+{
+    struct fdisk_partition* pa         = get_current_partition(cf);
+    struct cfdisk_line*     l          = &cf->lines[cf->lines_idx];
+    char*                   data       = NULL;
+    char*                   mountpoint = NULL;
+
+    DBG(UI, ul_debug("preparing extra data"));
+
+    /* string data should not equal an empty string */
+    if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_NAME, &data)
+        && data)
+    {
+        extra_insert_pair(l, _("Partition name:"), data);
+        if (!mountpoint) mountpoint = get_mountpoint(cf, "PARTLABEL", data);
+        free(data);
+    }
+
+    if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_UUID, &data)
+        && data)
+    {
+        extra_insert_pair(l, _("Partition UUID:"), data);
+        if (!mountpoint) mountpoint = get_mountpoint(cf, "PARTUUID", data);
+        free(data);
+    }
+
+    if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_TYPE, &data)
+        && data)
+    {
+        char *code = NULL, *type = NULL;
+
+        fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_TYPEID, &code);
+        xasprintf(&type, "%s (%s)", data, code);
+
+        extra_insert_pair(l, _("Partition type:"), type);
+        free(data);
+        free(code);
+        free(type);
+    }
+
+    if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_ATTR, &data)
+        && data)
+    {
+        extra_insert_pair(l, _("Attributes:"), data);
+        free(data);
+    }
+
+    /* for numeric data, only show non-zero rows */
+    if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_BSIZE, &data)
+        && data)
+    {
+        if (atoi(data)) extra_insert_pair(l, "BSIZE:", data);
+        free(data);
+    }
+
+    if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_CPG, &data) && data)
+    {
+        if (atoi(data)) extra_insert_pair(l, "CPG:", data);
+        free(data);
+    }
+
+    if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_FSIZE, &data)
+        && data)
+    {
+        if (atoi(data)) extra_insert_pair(l, "FSIZE:", data);
+        free(data);
+    }
+
+    if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_FSUUID, &data)
+        && data)
+    {
+        extra_insert_pair(l, _("Filesystem UUID:"), data);
+        if (!mountpoint) mountpoint = get_mountpoint(cf, "UUID", data);
+        free(data);
+    }
+
+    if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_FSLABEL, &data)
+        && data)
+    {
+        extra_insert_pair(l, _("Filesystem LABEL:"), data);
+        if (!mountpoint) mountpoint = get_mountpoint(cf, "LABEL", data);
+        free(data);
+    }
+    if (!fdisk_partition_to_string(pa, cf->cxt, FDISK_FIELD_FSTYPE, &data)
+        && data)
+    {
+        extra_insert_pair(l, _("Filesystem:"), data);
+        free(data);
+    }
+
+    if (mountpoint)
+    {
+        extra_insert_pair(l, _("Mountpoint:"), mountpoint);
+        free(mountpoint);
+    }
+}
+
+static int ui_draw_extra(struct cfdisk* cf)
+{
+    WINDOW*             win_ex;
+    int                 wline = 1;
+    struct cfdisk_line* ln    = &cf->lines[cf->lines_idx];
+    char *              tbstr = NULL, *end;
+    int                 win_ex_start_line, win_height, tblen;
+    int                 ndatalines;
+
+    if (!cf->show_extra) return 0;
+
+    DBG(UI, ul_debug("draw extra"));
+
+    assert(ln->extra);
+
+    if (cf->act_win)
+    {
+        wclear(cf->act_win);
+        touchwin(stdscr);
+    }
+
+    if (scols_table_is_empty(ln->extra))
+    {
+        extra_prepare_data(cf);
+        if (scols_table_is_empty(ln->extra)) return 0;
+    }
+
+    ndatalines        = fdisk_table_get_nents(cf->table) + 1;
+
+    /* nents + header + one free line */
+    win_ex_start_line = TABLE_START_LINE + ndatalines;
+    win_height        = MENU_START_LINE - win_ex_start_line;
+    tblen             = scols_table_get_nlines(ln->extra);
+
+    /* we can't get a single line of data under the partlist*/
+    if (win_height < 3) return 1;
+
+    /* number of data lines + 2 for top/bottom lines */
+    win_height = win_height < tblen + 2 ? win_height : tblen + 2;
+
+    if ((size_t)win_ex_start_line + win_height + 1 < MENU_START_LINE)
+        win_ex_start_line = MENU_START_LINE - win_height;
+
+    win_ex = subwin(stdscr, win_height, ui_cols - 2, win_ex_start_line, 1);
+
+    scols_table_reduce_termwidth(ln->extra, 4);
+    scols_print_table_to_string(ln->extra, &tbstr);
+
+    end = tbstr;
+    while ((end = strchr(end, '\n'))) *end++ = '\0';
+
+    box(win_ex, 0, 0);
+
+    end = tbstr;
+    while (--win_height > 1)
+    {
+        mvwaddstr(win_ex, wline++, 1 /* window column*/, tbstr);
+        tbstr += strlen(tbstr) + 1;
+    }
+    free(end);
+
+    if (ln->w) delwin(ln->w);
+
+    DBG(UI, ul_debug("draw window: %p", win_ex));
+    touchwin(stdscr);
+    wrefresh(win_ex);
+
+    cf->act_win = ln->w = win_ex;
+    return 0;
+}
+
+static void ui_menu_goto(struct cfdisk* cf, int where)
+{
+    struct cfdisk_menuitem* d;
+    size_t                  old;
+
+    /* stop and begin/end for vertical menus */
+    if (cf->menu->vertical)
+    {
+        if (where < 0) where = 0;
+        else if (where > (int)cf->menu->nitems - 1)
+            where = cf->menu->nitems - 1;
+    }
+    else
+    {
+        /* continue from begin/end */
+        if (where < 0) where = cf->menu->nitems - 1;
+        else if ((size_t)where > cf->menu->nitems - 1) where = 0;
+    }
+    if ((size_t)where == cf->menu->idx) return;
+
+    ui_clean_info();
+
+    old           = cf->menu->idx;
+    cf->menu->idx = where;
+
+    if (!menuitem_on_page(cf, old))
+    {
+        ui_draw_menu(cf);
+        return;
+    }
+
+    d = menu_get_menuitem(cf, old);
+    ui_draw_menuitem(cf, d, old);
+
+    d = menu_get_menuitem(cf, where);
+    ui_draw_menuitem(cf, d, where);
+}
+
+static int ui_menu_move(struct cfdisk* cf, int key)
+{
+    struct cfdisk_menu* m;
+
+    assert(cf);
+    assert(cf->menu);
+
+    if (key == (int)ERR) return 0; /* ignore errors */
+
+    m = cf->menu;
+
+    DBG(MENU, ul_debug("menu move key >%c<.", key));
+
+    if (m->vertical)
+    {
+        switch (key)
+        {
+            case KEY_DOWN:
+            case '\016': /* ^N */
+            case 'j':    /* Vi-like alternative */
+                ui_menu_goto(cf, m->idx + 1);
+                return 0;
+            case KEY_UP:
+            case '\020': /* ^P */
+            case 'k':    /* Vi-like alternative */
+                ui_menu_goto(cf, (int)m->idx - 1);
+                return 0;
+            case KEY_PPAGE:
+                if (m->page_sz)
+                {
+                    ui_menu_goto(cf, (int)m->idx - m->page_sz);
+                    return 0;
+                }
+                /* fallthrough */
+            case KEY_HOME: ui_menu_goto(cf, 0); return 0;
+            case KEY_NPAGE:
+                if (m->page_sz)
+                {
+                    ui_menu_goto(cf, m->idx + m->page_sz);
+                    return 0;
+                }
+                /* fallthrough */
+            case KEY_END: ui_menu_goto(cf, m->nitems); return 0;
+        }
+    }
+    else
+    {
+        switch (key)
+        {
+            case KEY_RIGHT:
+            case '\t': ui_menu_goto(cf, m->idx + 1); return 0;
+            case KEY_LEFT:
 #ifdef KEY_BTAB
-		case KEY_BTAB:
+            case KEY_BTAB:
 #endif
-			ui_menu_goto(cf, (int) m->idx - 1);
-			return 0;
-		}
-	}
+                ui_menu_goto(cf, (int)m->idx - 1);
+                return 0;
+        }
+    }
 
-	if (key == '\014') {		/* ^L refresh */
-		ui_menu_resize(cf);
-		return 0;
-	}
+    if (key == '\014')
+    { /* ^L refresh */
+        ui_menu_resize(cf);
+        return 0;
+    }
 
-	DBG(MENU, ul_debug(" no menu move key"));
-	return 1;
+    DBG(MENU, ul_debug(" no menu move key"));
+    return 1;
 }
 
 /* but don't call me from ui_run(), this is for pop-up menus only */
-static void ui_menu_resize(struct cfdisk *cf)
-{
-	DBG(MENU, ul_debug("menu resize/refresh"));
-	resize();
-	ui_clean_menu(cf);
-	menu_refresh_size(cf);
-	ui_draw_menu(cf);
-	refresh();
-}
-
-static int partition_on_page(struct cfdisk *cf, size_t i)
-{
-	if (cf->page_sz == 0 ||
-	    cf->lines_idx / cf->page_sz == i / cf->page_sz)
-		return 1;
-	return 0;
-}
-
-static void ui_draw_partition(struct cfdisk *cf, size_t i)
-{
-	int ln = TABLE_START_LINE + 1 + i;	/* skip table header */
-	int cl = ARROW_CURSOR_WIDTH;		/* we need extra space for cursor */
-	int cur = cf->lines_idx == i;
-	size_t curpg = 0;
-
-	if (cf->page_sz) {
-		if (!partition_on_page(cf, i))
-			return;
-		ln = TABLE_START_LINE + (i % cf->page_sz) + 1;
-		curpg = cf->lines_idx / cf->page_sz;
-	}
-
-	DBG(UI, ul_debug(
-			"draw partition %zu [page_sz=%zu, "
-			"line=%d, idx=%zu]",
-			i, cf->page_sz, ln, cf->lines_idx));
-
-	if (cur) {
-		attron(A_REVERSE);
-		mvaddstr(ln, 0, ARROW_CURSOR_STRING);
-		mvaddstr(ln, cl, cf->lines[i + 1].data);
-		attroff(A_REVERSE);
-	} else {
-		int at = 0;
-
-		if (colors_wanted() && is_freespace(cf, i)) {
-			attron(COLOR_PAIR(CFDISK_CL_FREESPACE));
-			at = 1;
-		}
-		mvaddstr(ln, 0, ARROW_CURSOR_DUMMY);
-		mvaddstr(ln, cl, cf->lines[i + 1].data);
-		if (at)
-			attroff(COLOR_PAIR(CFDISK_CL_FREESPACE));
-	}
-
-	if ((size_t) ln == MENU_START_LINE - 1 &&
-	    cf->page_sz && curpg < cf->nlines / cf->page_sz) {
-		if (cur)
-			attron(A_REVERSE);
-		mvaddch(ln, ui_cols - 1, ACS_DARROW);
-		mvaddch(ln, 0, ACS_DARROW);
-		if (cur)
-			attroff(A_REVERSE);
-	}
-
-}
-
-static int ui_draw_table(struct cfdisk *cf)
-{
-	int cl = ARROW_CURSOR_WIDTH;
-	size_t i, nparts = fdisk_table_get_nents(cf->table);
-	size_t curpg = cf->page_sz ? cf->lines_idx / cf->page_sz : 0;
-
-	DBG(UI, ul_debug("draw table"));
-
-	for (i = TABLE_START_LINE; i <= TABLE_START_LINE + cf->page_sz; i++) {
-		move(i, 0);
-		clrtoeol();
-	}
-
-	if (nparts == 0 || (size_t) cf->lines_idx > nparts - 1)
-		cf->lines_idx = nparts ? nparts - 1 : 0;
+static void ui_menu_resize(struct cfdisk* cf)
+{
+    DBG(MENU, ul_debug("menu resize/refresh"));
+    resize();
+    ui_clean_menu(cf);
+    menu_refresh_size(cf);
+    ui_draw_menu(cf);
+    refresh();
+}
+
+static int partition_on_page(struct cfdisk* cf, size_t i)
+{
+    if (cf->page_sz == 0 || cf->lines_idx / cf->page_sz == i / cf->page_sz)
+        return 1;
+    return 0;
+}
+
+static void ui_draw_partition(struct cfdisk* cf, size_t i)
+{
+    int    ln    = TABLE_START_LINE + 1 + i; /* skip table header */
+    int    cl    = ARROW_CURSOR_WIDTH; /* we need extra space for cursor */
+    int    cur   = cf->lines_idx == i;
+    size_t curpg = 0;
+
+    if (cf->page_sz)
+    {
+        if (!partition_on_page(cf, i)) return;
+        ln    = TABLE_START_LINE + (i % cf->page_sz) + 1;
+        curpg = cf->lines_idx / cf->page_sz;
+    }
+
+    DBG(UI, ul_debug("draw partition %zu [page_sz=%zu, "
+                     "line=%d, idx=%zu]",
+                     i, cf->page_sz, ln, cf->lines_idx));
+
+    if (cur)
+    {
+        attron(A_REVERSE);
+        mvaddstr(ln, 0, ARROW_CURSOR_STRING);
+        mvaddstr(ln, cl, cf->lines[i + 1].data);
+        attroff(A_REVERSE);
+    }
+    else
+    {
+        int at = 0;
+
+        if (colors_wanted() && is_freespace(cf, i))
+        {
+            attron(COLOR_PAIR(CFDISK_CL_FREESPACE));
+            at = 1;
+        }
+        mvaddstr(ln, 0, ARROW_CURSOR_DUMMY);
+        mvaddstr(ln, cl, cf->lines[i + 1].data);
+        if (at) attroff(COLOR_PAIR(CFDISK_CL_FREESPACE));
+    }
+
+    if ((size_t)ln == MENU_START_LINE - 1 && cf->page_sz
+        && curpg < cf->nlines / cf->page_sz)
+    {
+        if (cur) attron(A_REVERSE);
+        mvaddch(ln, ui_cols - 1, ACS_DARROW);
+        mvaddch(ln, 0, ACS_DARROW);
+        if (cur) attroff(A_REVERSE);
+    }
+}
+
+static int ui_draw_table(struct cfdisk* cf)
+{
+    int    cl = ARROW_CURSOR_WIDTH;
+    size_t i, nparts = fdisk_table_get_nents(cf->table);
+    size_t curpg = cf->page_sz ? cf->lines_idx / cf->page_sz : 0;
+
+    DBG(UI, ul_debug("draw table"));
+
+    for (i = TABLE_START_LINE; i <= TABLE_START_LINE + cf->page_sz; i++)
+    {
+        move(i, 0);
+        clrtoeol();
+    }
+
+    if (nparts == 0 || (size_t)cf->lines_idx > nparts - 1)
+        cf->lines_idx = nparts ? nparts - 1 : 0;
 
-	/* print header */
-	attron(A_BOLD);
-	mvaddstr(TABLE_START_LINE, cl, cf->lines[0].data);
-	attroff(A_BOLD);
-
-	/* print partitions */
-	for (i = 0; i < nparts; i++)
-		ui_draw_partition(cf, i);
+    /* print header */
+    attron(A_BOLD);
+    mvaddstr(TABLE_START_LINE, cl, cf->lines[0].data);
+    attroff(A_BOLD);
+
+    /* print partitions */
+    for (i = 0; i < nparts; i++) ui_draw_partition(cf, i);
 
-	if (curpg != 0) {
-		mvaddch(TABLE_START_LINE, ui_cols - 1, ACS_UARROW);
-		mvaddch(TABLE_START_LINE, 0, ACS_UARROW);
-	}
-	if (cf->page_sz && curpg < cf->nlines / cf->page_sz) {
-		mvaddch(MENU_START_LINE - 1, ui_cols - 1, ACS_DARROW);
-		mvaddch(MENU_START_LINE - 1, 0, ACS_DARROW);
-	}
-	return 0;
+    if (curpg != 0)
+    {
+        mvaddch(TABLE_START_LINE, ui_cols - 1, ACS_UARROW);
+        mvaddch(TABLE_START_LINE, 0, ACS_UARROW);
+    }
+    if (cf->page_sz && curpg < cf->nlines / cf->page_sz)
+    {
+        mvaddch(MENU_START_LINE - 1, ui_cols - 1, ACS_DARROW);
+        mvaddch(MENU_START_LINE - 1, 0, ACS_DARROW);
+    }
+    return 0;
 }
 
-static int ui_table_goto(struct cfdisk *cf, int where)
+static int ui_table_goto(struct cfdisk* cf, int where)
 {
-	size_t old;
-	size_t nparts = fdisk_table_get_nents(cf->table);
+    size_t old;
+    size_t nparts = fdisk_table_get_nents(cf->table);
 
-	DBG(UI, ul_debug("goto table %d", where));
+    DBG(UI, ul_debug("goto table %d", where));
 
-	if (where < 0)
-		where = 0;
-	else if ((size_t) where > nparts - 1)
-		where = nparts - 1;
+    if (where < 0) where = 0;
+    else if ((size_t)where > nparts - 1) where = nparts - 1;
+
+    if ((size_t)where == cf->lines_idx) return 0;
 
-	if ((size_t) where == cf->lines_idx)
-		return 0;
-
-	old = cf->lines_idx;
-	cf->lines_idx = where;
-
-	if (!partition_on_page(cf, old) ||!partition_on_page(cf, where))
-		ui_draw_table(cf);
-	else {
-		ui_draw_partition(cf, old);	/* cleanup old */
-		ui_draw_partition(cf, where);	/* draw new */
-	}
-	ui_clean_info();
-	ui_draw_menu(cf);
-	ui_draw_extra(cf);
-	refresh();
+    old           = cf->lines_idx;
+    cf->lines_idx = where;
+
+    if (!partition_on_page(cf, old) || !partition_on_page(cf, where))
+        ui_draw_table(cf);
+    else
+    {
+        ui_draw_partition(cf, old);   /* cleanup old */
+        ui_draw_partition(cf, where); /* draw new */
+    }
+    ui_clean_info();
+    ui_draw_menu(cf);
+    ui_draw_extra(cf);
+    refresh();
+
+    return 0;
+}
+
+static int ui_refresh(struct cfdisk* cf)
+{
+    struct fdisk_label* lb;
+    char*               id = NULL;
+    uint64_t            bytes
+        = fdisk_get_nsectors(cf->cxt) * fdisk_get_sector_size(cf->cxt);
+    char* strsz;
 
-	return 0;
-}
-
-static int ui_refresh(struct cfdisk *cf)
-{
-	struct fdisk_label *lb;
-	char *id = NULL;
-        uint64_t bytes = fdisk_get_nsectors(cf->cxt) * fdisk_get_sector_size(cf->cxt);
-	char *strsz;
-
-	if (!ui_enabled)
-		return -EINVAL;
+    if (!ui_enabled) return -EINVAL;
 
-	strsz = size_to_human_string(SIZE_DECIMAL_2DIGITS
-				| SIZE_SUFFIX_SPACE
-				| SIZE_SUFFIX_3LETTER, bytes);
+    strsz = size_to_human_string(
+        SIZE_DECIMAL_2DIGITS | SIZE_SUFFIX_SPACE | SIZE_SUFFIX_3LETTER, bytes);
 
-	lb = fdisk_get_label(cf->cxt, NULL);
-	assert(lb);
+    lb = fdisk_get_label(cf->cxt, NULL);
+    assert(lb);
 
-	clear();
+    clear();
 
-	/* header */
-	attron(A_BOLD);
-	ui_center(0, _("Disk: %s"), fdisk_get_devname(cf->cxt));
-	attroff(A_BOLD);
-	ui_center(1, _("Size: %s, %"PRIu64" bytes, %ju sectors"),
-			strsz, bytes, (uintmax_t) fdisk_get_nsectors(cf->cxt));
-	if (fdisk_get_disklabel_id(cf->cxt, &id) == 0 && id)
-		ui_center(2, _("Label: %s, identifier: %s"),
-				fdisk_label_get_name(lb), id);
-	else
-		ui_center(2, _("Label: %s"), fdisk_label_get_name(lb));
-	free(strsz);
-	free(id);
+    /* header */
+    attron(A_BOLD);
+    ui_center(0, _("Disk: %s"), fdisk_get_devname(cf->cxt));
+    attroff(A_BOLD);
+    ui_center(1, _("Size: %s, %" PRIu64 " bytes, %ju sectors"), strsz, bytes,
+              (uintmax_t)fdisk_get_nsectors(cf->cxt));
+    if (fdisk_get_disklabel_id(cf->cxt, &id) == 0 && id)
+        ui_center(2, _("Label: %s, identifier: %s"), fdisk_label_get_name(lb),
+                  id);
+    else ui_center(2, _("Label: %s"), fdisk_label_get_name(lb));
+    free(strsz);
+    free(id);
 
-	ui_draw_table(cf);
-	ui_draw_menu(cf);
-	refresh();
-	return 0;
+    ui_draw_table(cf);
+    ui_draw_menu(cf);
+    refresh();
+    return 0;
 }
 
-static ssize_t ui_get_string(const char *prompt,
-			     const char *hint, char *buf, size_t len)
+static ssize_t ui_get_string(const char* prompt, const char* hint, char* buf,
+                             size_t len)
 {
-	int ln = MENU_START_LINE, cl = 1;
-	ssize_t rc = -1;
-	struct mbs_editor *edit;
+    int                ln = MENU_START_LINE, cl = 1;
+    ssize_t            rc = -1;
+    struct mbs_editor* edit;
 
-	DBG(UI, ul_debug("ui get string"));
+    DBG(UI, ul_debug("ui get string"));
 
-	assert(buf);
-	assert(len);
+    assert(buf);
+    assert(len);
 
-	move(ln, 0);
-	clrtoeol();
+    move(ln, 0);
+    clrtoeol();
 
-	move(ln + 1, 0);
-	clrtoeol();
+    move(ln + 1, 0);
+    clrtoeol();
 
-	if (prompt) {
-		mvaddstr(ln, cl, prompt);
-		cl += mbs_safe_width(prompt);
-	}
+    if (prompt)
+    {
+        mvaddstr(ln, cl, prompt);
+        cl += mbs_safe_width(prompt);
+    }
 
-	edit = mbs_new_edit(buf, len, ui_cols - cl);
-	if (!edit)
-		goto done;
+    edit = mbs_new_edit(buf, len, ui_cols - cl);
+    if (!edit) goto done;
 
-	mbs_edit_goto(edit, MBS_EDIT_END);
+    mbs_edit_goto(edit, MBS_EDIT_END);
 
-	if (hint)
-		ui_hint(hint);
-	else
-		ui_clean_hint();
+    if (hint) ui_hint(hint);
+    else ui_clean_hint();
 
-	curs_set(1);
+    curs_set(1);
 
-	while (!sig_die) {
-		wint_t c;	/* we have fallback in widechar.h */
+    while (!sig_die)
+    {
+        wint_t c; /* we have fallback in widechar.h */
 
-		move(ln, cl);
-		clrtoeol();
-		mvaddstr(ln, cl, edit->buf);
-		move(ln, cl + edit->cursor_cells);
-		refresh();
+        move(ln, cl);
+        clrtoeol();
+        mvaddstr(ln, cl, edit->buf);
+        move(ln, cl + edit->cursor_cells);
+        refresh();
 
-#if !defined(HAVE_SLCURSES_H) && !defined(HAVE_SLANG_SLCURSES_H) && \
-    defined(HAVE_LIBNCURSESW) && defined(HAVE_WIDECHAR)
-		if (get_wch(&c) == ERR) {
+#if !defined(HAVE_SLCURSES_H) && !defined(HAVE_SLANG_SLCURSES_H)               \
+    && defined(HAVE_LIBNCURSESW) && defined(HAVE_WIDECHAR)
+        if (get_wch(&c) == ERR)
+        {
 #else
-		if ((c = getch()) == (wint_t) ERR) {
+        if ((c = getch()) == (wint_t)ERR)
+        {
 #endif
-			if (sig_die)
-				break;
-			if (sig_resize) {
-				resize();
-				continue;
-			}
-			if (!isatty(STDIN_FILENO))
-				exit(2);
-			else
-				goto done;
-		}
-
-		DBG(UI, ul_debug("ui get string: key=%lc", c));
-
-		if (c == '\r' || c == '\n' || c == KEY_ENTER)
-			break;
-
-		rc = 1;
-
-		switch (c) {
-		case KEY_ESC:
-			rc = -CFDISK_ERR_ESC;
-			goto done;
-		case KEY_LEFT:
-			rc = mbs_edit_goto(edit, MBS_EDIT_LEFT);
-			break;
-		case KEY_RIGHT:
-			rc = mbs_edit_goto(edit, MBS_EDIT_RIGHT);
-			break;
-		case KEY_END:
-			rc = mbs_edit_goto(edit, MBS_EDIT_END);
-			break;
-		case KEY_HOME:
-			rc = mbs_edit_goto(edit, MBS_EDIT_HOME);
-			break;
-		case KEY_UP:
-		case KEY_DOWN:
-			break;
-		case KEY_DC:
-			rc = mbs_edit_delete(edit);
-			break;
-		case '\b':
-		case KEY_DELETE:
-		case KEY_BACKSPACE:
-			rc = mbs_edit_backspace(edit);
-			break;
-		default:
-			rc = mbs_edit_insert(edit, c);
-			break;
-		}
-		if (rc == 1)
-			beep();
-	}
-
-	if (sig_die)
-		die_on_signal();
-
-	rc = strlen(edit->buf);		/* success */
+            if (sig_die) break;
+            if (sig_resize)
+            {
+                resize();
+                continue;
+            }
+            if (!isatty(STDIN_FILENO)) exit(2);
+            else goto done;
+        }
+
+        DBG(UI, ul_debug("ui get string: key=%lc", c));
+
+        if (c == '\r' || c == '\n' || c == KEY_ENTER) break;
+
+        rc = 1;
+
+        switch (c)
+        {
+            case KEY_ESC: rc = -CFDISK_ERR_ESC; goto done;
+            case KEY_LEFT: rc = mbs_edit_goto(edit, MBS_EDIT_LEFT); break;
+            case KEY_RIGHT: rc = mbs_edit_goto(edit, MBS_EDIT_RIGHT); break;
+            case KEY_END: rc = mbs_edit_goto(edit, MBS_EDIT_END); break;
+            case KEY_HOME: rc = mbs_edit_goto(edit, MBS_EDIT_HOME); break;
+            case KEY_UP:
+            case KEY_DOWN: break;
+            case KEY_DC: rc = mbs_edit_delete(edit); break;
+            case '\b':
+            case KEY_DELETE:
+            case KEY_BACKSPACE: rc = mbs_edit_backspace(edit); break;
+            default: rc = mbs_edit_insert(edit, c); break;
+        }
+        if (rc == 1) beep();
+    }
+
+    if (sig_die) die_on_signal();
+
+    rc = strlen(edit->buf); /* success */
 done:
-	move(ln, 0);
-	clrtoeol();
-	curs_set(0);
-	refresh();
-	mbs_free_edit(edit);
-
-	return rc;
-}
-
-static int ui_get_size(struct cfdisk *cf,	/* context */
-		       const char *prompt,	/* UI dialog string */
-		       uint64_t *res,		/* result in bytes */
-		       uint64_t low,		/* minimal size */
-		       uint64_t up,		/* maximal size */
-		       int *expsize)		/* explicitly specified size */
-{
-	char buf[128];
-	uint64_t user = 0;
-	ssize_t rc;
-	char *dflt = size_to_human_string(0, *res);
-
-	DBG(UI, ul_debug("get_size (default=%"PRIu64")", *res));
-
-	ui_clean_info();
-
-	snprintf(buf, sizeof(buf), "%s", dflt);
-
-	do {
-		int pwr = 0, insec = 0;
-
-		rc = ui_get_string(prompt,
-				_("May be followed by M for MiB, G for GiB, "
-				  "T for TiB, or S for sectors."),
-				buf, sizeof(buf));
-		ui_clean_warn();
-
-		if (rc == 0) {
-			ui_warnx(_("Please, specify size."));
-			continue;			/* nothing specified */
-		} if (rc == -CFDISK_ERR_ESC)
-			break;				/* cancel dialog */
-
-		if (strcmp(buf, dflt) == 0)
-			user = *res, rc = 0;		/* no change, use default */
-		else {
-			size_t len = strlen(buf);
-			if (buf[len - 1] == 'S' || buf[len - 1] == 's') {
-				insec = 1;
-				buf[len - 1] = '\0';
-			}
-			rc = parse_size(buf, (uintmax_t *)&user, &pwr);	/* parse */
-		}
-
-		if (rc == 0) {
-			DBG(UI, ul_debug("get_size user=%"PRIu64", power=%d, in-sectors=%s",
-						user, pwr, insec ? "yes" : "no"));
-			if (insec)
-				user *= fdisk_get_sector_size(cf->cxt);
-			if (user < low) {
-				ui_warnx(_("Minimum size is %"PRIu64" bytes."), low);
-				rc = -ERANGE;
-			}
-			if (user > up && pwr && user < up + (1ULL << pwr * 10))
-				/* ignore when the user specified size overflow
-				 * with in range specified by suffix (e.g. MiB) */
-				user = up;
-
-			if (user > up) {
-				ui_warnx(_("Maximum size is %"PRIu64" bytes."), up);
-				rc = -ERANGE;
-			}
-			if (rc == 0 && insec && expsize)
-				*expsize = 1;
-
-		} else
-			ui_warnx(_("Failed to parse size."));
-	} while (rc != 0);
-
-	if (rc == 0)
-		*res = user;
-	free(dflt);
-
-	DBG(UI, ul_debug("get_size (result=%"PRIu64", rc=%zd)", *res, rc));
-	return rc;
-}
-
-static struct fdisk_parttype *ui_get_parttype(struct cfdisk *cf,
-					struct fdisk_parttype *cur)
-{
-	struct cfdisk_menuitem *d, *cm;
-	size_t i = 0, nitems, idx = 0;
-	struct fdisk_parttype *t = NULL;
-	struct fdisk_label *lb;
-	int codetypes = 0;
-
-	DBG(UI, ul_debug("asking for parttype."));
-
-	lb = fdisk_get_label(cf->cxt, NULL);
-
-	/* create cfdisk menu according to label types, note that the
-	 * last cm[] item has to be empty -- so nitems + 1 */
-	nitems = fdisk_label_get_nparttypes(lb);
-	if (!nitems)
-		return NULL;
-
-	cm = xcalloc(nitems + 1, sizeof(struct cfdisk_menuitem));
-	if (!cm)
-		return NULL;
-
-	codetypes = fdisk_label_has_code_parttypes(lb);
-
-	for (i = 0; i < nitems; i++) {
-		const struct fdisk_parttype *x = fdisk_label_get_parttype(lb, i);
-		char *name;
-
-		cm[i].userdata = (void *) x;
-		if (codetypes)
-			xasprintf(&name, "%2x %s",
-				fdisk_parttype_get_code(x),
-				_(fdisk_parttype_get_name(x)));
-		else {
-			name = (char *) _(fdisk_parttype_get_name(x));
-			cm[i].desc = fdisk_parttype_get_string(x);
-		}
-		cm[i].name = name;
-		if (x == cur)
-			idx = i;
-	}
-
-	/* make the new menu active */
-	menu_push(cf, cm);
-	cf->menu->vertical = 1;
-	cf->menu->idx = idx;
-	menu_set_title(cf->menu, _("Select partition type"));
-	ui_draw_menu(cf);
-	refresh();
-
-	while (!sig_die) {
-		int key = getch();
-
-		if (sig_die)
-			break;
-		if (sig_resize)
-			ui_menu_resize(cf);
-		if (ui_menu_move(cf, key) == 0)
-			continue;
-
-		switch (key) {
-		case KEY_ENTER:
-		case '\n':
-		case '\r':
-			d = menu_get_menuitem(cf, cf->menu->idx);
-			if (d)
-				t = (struct fdisk_parttype *) d->userdata;
-			goto done;
-		case KEY_ESC:
-		case 'q':
-		case 'Q':
-			goto done;
-		}
-	}
-
-	if (sig_die)
-		die_on_signal();
+    move(ln, 0);
+    clrtoeol();
+    curs_set(0);
+    refresh();
+    mbs_free_edit(edit);
+
+    return rc;
+}
+
+static int ui_get_size(struct cfdisk* cf,     /* context */
+                       const char*    prompt, /* UI dialog string */
+                       uint64_t*      res,    /* result in bytes */
+                       uint64_t       low,    /* minimal size */
+                       uint64_t       up,     /* maximal size */
+                       int*           expsize)          /* explicitly specified size */
+{
+    char     buf[128];
+    uint64_t user = 0;
+    ssize_t  rc;
+    char*    dflt = size_to_human_string(0, *res);
+
+    DBG(UI, ul_debug("get_size (default=%" PRIu64 ")", *res));
+
+    ui_clean_info();
+
+    snprintf(buf, sizeof(buf), "%s", dflt);
+
+    do {
+        int pwr = 0, insec = 0;
+
+        rc = ui_get_string(prompt,
+                           _("May be followed by M for MiB, G for GiB, "
+                             "T for TiB, or S for sectors."),
+                           buf, sizeof(buf));
+        ui_clean_warn();
+
+        if (rc == 0)
+        {
+            ui_warnx(_("Please, specify size."));
+            continue; /* nothing specified */
+        }
+        if (rc == -CFDISK_ERR_ESC) break; /* cancel dialog */
+
+        if (strcmp(buf, dflt) == 0)
+            user = *res, rc = 0; /* no change, use default */
+        else
+        {
+            size_t len = strlen(buf);
+            if (buf[len - 1] == 'S' || buf[len - 1] == 's')
+            {
+                insec        = 1;
+                buf[len - 1] = '\0';
+            }
+            rc = parse_size(buf, (uintmax_t*)&user, &pwr); /* parse */
+        }
+
+        if (rc == 0)
+        {
+            DBG(UI,
+                ul_debug("get_size user=%" PRIu64 ", power=%d, in-sectors=%s",
+                         user, pwr, insec ? "yes" : "no"));
+            if (insec) user *= fdisk_get_sector_size(cf->cxt);
+            if (user < low)
+            {
+                ui_warnx(_("Minimum size is %" PRIu64 " bytes."), low);
+                rc = -ERANGE;
+            }
+            if (user > up && pwr && user < up + (1ULL << pwr * 10))
+                /* ignore when the user specified size overflow
+                 * with in range specified by suffix (e.g. MiB) */
+                user = up;
+
+            if (user > up)
+            {
+                ui_warnx(_("Maximum size is %" PRIu64 " bytes."), up);
+                rc = -ERANGE;
+            }
+            if (rc == 0 && insec && expsize) *expsize = 1;
+        }
+        else ui_warnx(_("Failed to parse size."));
+    } while (rc != 0);
+
+    if (rc == 0) *res = user;
+    free(dflt);
+
+    DBG(UI, ul_debug("get_size (result=%" PRIu64 ", rc=%zd)", *res, rc));
+    return rc;
+}
+
+static struct fdisk_parttype* ui_get_parttype(struct cfdisk*         cf,
+                                              struct fdisk_parttype* cur)
+{
+    struct cfdisk_menuitem *d, *cm;
+    size_t                  i = 0, nitems, idx = 0;
+    struct fdisk_parttype*  t = NULL;
+    struct fdisk_label*     lb;
+    int                     codetypes = 0;
+
+    DBG(UI, ul_debug("asking for parttype."));
+
+    lb     = fdisk_get_label(cf->cxt, NULL);
+
+    /* create cfdisk menu according to label types, note that the
+     * last cm[] item has to be empty -- so nitems + 1 */
+    nitems = fdisk_label_get_nparttypes(lb);
+    if (!nitems) return NULL;
+
+    cm = xcalloc(nitems + 1, sizeof(struct cfdisk_menuitem));
+    if (!cm) return NULL;
+
+    codetypes = fdisk_label_has_code_parttypes(lb);
+
+    for (i = 0; i < nitems; i++)
+    {
+        const struct fdisk_parttype* x = fdisk_label_get_parttype(lb, i);
+        char*                        name;
+
+        cm[i].userdata = (void*)x;
+        if (codetypes)
+            xasprintf(&name, "%2x %s", fdisk_parttype_get_code(x),
+                      _(fdisk_parttype_get_name(x)));
+        else
+        {
+            name       = (char*)_(fdisk_parttype_get_name(x));
+            cm[i].desc = fdisk_parttype_get_string(x);
+        }
+        cm[i].name = name;
+        if (x == cur) idx = i;
+    }
+
+    /* make the new menu active */
+    menu_push(cf, cm);
+    cf->menu->vertical = 1;
+    cf->menu->idx      = idx;
+    menu_set_title(cf->menu, _("Select partition type"));
+    ui_draw_menu(cf);
+    refresh();
+
+    while (!sig_die)
+    {
+        int key = getch();
+
+        if (sig_die) break;
+        if (sig_resize) ui_menu_resize(cf);
+        if (ui_menu_move(cf, key) == 0) continue;
+
+        switch (key)
+        {
+            case KEY_ENTER:
+            case '\n':
+            case '\r':
+                d = menu_get_menuitem(cf, cf->menu->idx);
+                if (d) t = (struct fdisk_parttype*)d->userdata;
+                goto done;
+            case KEY_ESC:
+            case 'q':
+            case 'Q': goto done;
+        }
+    }
+
+    if (sig_die) die_on_signal();
 done:
-	menu_pop(cf);
-	if (codetypes) {
-		for (i = 0; i < nitems; i++)
-			free((char *) cm[i].name);
-	}
-	free(cm);
-	DBG(UI, ul_debug("get parrtype done [type=%s] ", t ?
-				fdisk_parttype_get_name(t) : NULL));
-	return t;
-}
-
-static int ui_script_read(struct cfdisk *cf)
-{
-	struct fdisk_script *sc = NULL;
-	char buf[PATH_MAX] = { 0 };
-	int rc;
-
-	erase();
-	rc = ui_get_string(	_("Enter script file name: "),
-				_("The script file will be applied to in-memory partition table."),
-				buf, sizeof(buf));
-	if (rc <= 0)
-		return rc;
-
-	rc = -1;
-	errno = 0;
-	sc = fdisk_new_script_from_file(cf->cxt, buf);
-	if (!sc && errno)
-		ui_warn(_("Cannot open %s"), buf);
-	else if (!sc)
-		ui_warnx(_("Failed to parse script file %s"), buf);
-	else if (fdisk_apply_script(cf->cxt, sc) != 0)
-		ui_warnx(_("Failed to apply script %s"), buf);
-	else
-		rc = 0;
-
-	ui_clean_hint();
-	fdisk_unref_script(sc);
-	return rc;
-}
-
-static int ui_script_write(struct cfdisk *cf)
-{
-	struct fdisk_script *sc = NULL;
-	char buf[PATH_MAX] = { 0 };
-	FILE *f = NULL;
-	int rc;
-
-	rc = ui_get_string(	_("Enter script file name: "),
-				_("The current in-memory partition table will be dumped to the file."),
-				buf, sizeof(buf));
-	if (rc <= 0)
-		return rc;
-
-	rc = 0;
-	sc = fdisk_new_script(cf->cxt);
-	if (!sc) {
-		ui_warn(_("Failed to allocate script handler"));
-		goto done;
-	}
-
-	rc = fdisk_script_read_context(sc, NULL);
-	if (rc) {
-		ui_warnx(_("Failed to read disk layout into script."));
-		goto done;
-	}
-
-	DBG(UI, ul_debug("writing dump into: '%s'", buf));
-	f = fopen(buf, "w");
-	if (!f) {
-		ui_warn(_("Cannot open %s"), buf);
-		rc = -errno;
-		goto done;
-	}
-
-	rc = fdisk_script_write_file(sc, f);
-	if (!rc)
-		ui_info(_("Disk layout successfully dumped."));
+    menu_pop(cf);
+    if (codetypes)
+    {
+        for (i = 0; i < nitems; i++) free((char*)cm[i].name);
+    }
+    free(cm);
+    DBG(UI, ul_debug("get parrtype done [type=%s] ",
+                     t ? fdisk_parttype_get_name(t) : NULL));
+    return t;
+}
+
+static int ui_script_read(struct cfdisk* cf)
+{
+    struct fdisk_script* sc            = NULL;
+    char                 buf[PATH_MAX] = {0};
+    int                  rc;
+
+    erase();
+    rc = ui_get_string(
+        _("Enter script file name: "),
+        _("The script file will be applied to in-memory partition table."), buf,
+        sizeof(buf));
+    if (rc <= 0) return rc;
+
+    rc    = -1;
+    errno = 0;
+    sc    = fdisk_new_script_from_file(cf->cxt, buf);
+    if (!sc && errno) ui_warn(_("Cannot open %s"), buf);
+    else if (!sc) ui_warnx(_("Failed to parse script file %s"), buf);
+    else if (fdisk_apply_script(cf->cxt, sc) != 0)
+        ui_warnx(_("Failed to apply script %s"), buf);
+    else rc = 0;
+
+    ui_clean_hint();
+    fdisk_unref_script(sc);
+    return rc;
+}
+
+static int ui_script_write(struct cfdisk* cf)
+{
+    struct fdisk_script* sc            = NULL;
+    char                 buf[PATH_MAX] = {0};
+    FILE*                f             = NULL;
+    int                  rc;
+
+    rc = ui_get_string(
+        _("Enter script file name: "),
+        _("The current in-memory partition table will be dumped to the file."),
+        buf, sizeof(buf));
+    if (rc <= 0) return rc;
+
+    rc = 0;
+    sc = fdisk_new_script(cf->cxt);
+    if (!sc)
+    {
+        ui_warn(_("Failed to allocate script handler"));
+        goto done;
+    }
+
+    rc = fdisk_script_read_context(sc, NULL);
+    if (rc)
+    {
+        ui_warnx(_("Failed to read disk layout into script."));
+        goto done;
+    }
+
+    DBG(UI, ul_debug("writing dump into: '%s'", buf));
+    f = fopen(buf, "w");
+    if (!f)
+    {
+        ui_warn(_("Cannot open %s"), buf);
+        rc = -errno;
+        goto done;
+    }
+
+    rc = fdisk_script_write_file(sc, f);
+    if (!rc) ui_info(_("Disk layout successfully dumped."));
 done:
-	if (rc)
-		ui_warn(_("Failed to write script %s"), buf);
-	if (f)
-		fclose(f);
-	fdisk_unref_script(sc);
-	return rc;
+    if (rc) ui_warn(_("Failed to write script %s"), buf);
+    if (f) fclose(f);
+    fdisk_unref_script(sc);
+    return rc;
 }
 
 /* prints menu with libfdisk labels and waits for users response */
-static int ui_create_label(struct cfdisk *cf)
-{
-	struct cfdisk_menuitem *d, *cm;
-	int rc = 1, refresh_menu = 1;
-	size_t i = 0, nitems;
-	struct fdisk_label *lb = NULL;
-
-	assert(cf);
-
-	DBG(UI, ul_debug("asking for new disklabe."));
-
-	/* create cfdisk menu according to libfdisk labels, note that the
-	 * last cm[] item has to be empty -- so nitems + 1 */
-	nitems = fdisk_get_nlabels(cf->cxt);
-	cm = xcalloc(nitems + 1, sizeof(struct cfdisk_menuitem));
-
-	while (fdisk_next_label(cf->cxt, &lb) == 0) {
-		if (fdisk_label_is_disabled(lb) ||
-		    fdisk_label_get_type(lb) == FDISK_DISKLABEL_BSD)
-			continue;
-		cm[i++].name = fdisk_label_get_name(lb);
-	}
-
-	erase();
-
-	/* make the new menu active */
-	menu_push(cf, cm);
-	cf->menu->vertical = 1;
-	menu_set_title(cf->menu, _("Select label type"));
-
-	if (!cf->zero_start)
-		ui_info(_("Device does not contain a recognized partition table."));
-
-
-	while (!sig_die) {
-		int key;
-
-		if (refresh_menu) {
-			ui_draw_menu(cf);
-			ui_hint(_("Select a type to create a new label or press 'L' to load script file."));
-			refresh();
-			refresh_menu = 0;
-		}
-
-		key = getch();
-
-		if (sig_die)
-			break;
-		if (sig_resize)
-			ui_menu_resize(cf);
-		if (ui_menu_move(cf, key) == 0)
-			continue;
-		switch (key) {
-		case KEY_ENTER:
-		case '\n':
-		case '\r':
-			d = menu_get_menuitem(cf, cf->menu->idx);
-			if (d)
-				rc = fdisk_create_disklabel(cf->cxt, d->name);
-			goto done;
-		case KEY_ESC:
-		case 'q':
-		case 'Q':
-			goto done;
-		case 'l':
-		case 'L':
-			rc = ui_script_read(cf);
-			if (rc == 0)
-				goto done;
-			refresh_menu = 1;
-			break;
-		}
-	}
-
-	if (sig_die)
-		die_on_signal();
+static int ui_create_label(struct cfdisk* cf)
+{
+    struct cfdisk_menuitem *d, *cm;
+    int                     rc = 1, refresh_menu = 1;
+    size_t                  i  = 0, nitems;
+    struct fdisk_label*     lb = NULL;
+
+    assert(cf);
+
+    DBG(UI, ul_debug("asking for new disklabe."));
+
+    /* create cfdisk menu according to libfdisk labels, note that the
+     * last cm[] item has to be empty -- so nitems + 1 */
+    nitems = fdisk_get_nlabels(cf->cxt);
+    cm     = xcalloc(nitems + 1, sizeof(struct cfdisk_menuitem));
+
+    while (fdisk_next_label(cf->cxt, &lb) == 0)
+    {
+        if (fdisk_label_is_disabled(lb)
+            || fdisk_label_get_type(lb) == FDISK_DISKLABEL_BSD)
+            continue;
+        cm[i++].name = fdisk_label_get_name(lb);
+    }
+
+    erase();
+
+    /* make the new menu active */
+    menu_push(cf, cm);
+    cf->menu->vertical = 1;
+    menu_set_title(cf->menu, _("Select label type"));
+
+    if (!cf->zero_start)
+        ui_info(_("Device does not contain a recognized partition table."));
+
+    while (!sig_die)
+    {
+        int key;
+
+        if (refresh_menu)
+        {
+            ui_draw_menu(cf);
+            ui_hint(
+                _("Select a type to create a new label or press 'L' to load "
+                  "script file."));
+            refresh();
+            refresh_menu = 0;
+        }
+
+        key = getch();
+
+        if (sig_die) break;
+        if (sig_resize) ui_menu_resize(cf);
+        if (ui_menu_move(cf, key) == 0) continue;
+        switch (key)
+        {
+            case KEY_ENTER:
+            case '\n':
+            case '\r':
+                d = menu_get_menuitem(cf, cf->menu->idx);
+                if (d) rc = fdisk_create_disklabel(cf->cxt, d->name);
+                goto done;
+            case KEY_ESC:
+            case 'q':
+            case 'Q': goto done;
+            case 'l':
+            case 'L':
+                rc = ui_script_read(cf);
+                if (rc == 0) goto done;
+                refresh_menu = 1;
+                break;
+        }
+    }
+
+    if (sig_die) die_on_signal();
 done:
-	menu_pop(cf);
-	free(cm);
-	DBG(UI, ul_debug("create label done [rc=%d] ", rc));
-	return rc;
+    menu_pop(cf);
+    free(cm);
+    DBG(UI, ul_debug("create label done [rc=%d] ", rc));
+    return rc;
 }
 
-
 static int ui_help(void)
 {
-	size_t i;
-	static const char *help[] = {
-		N_("This is cfdisk, a curses-based disk partitioning program."),
-		N_("It lets you create, delete, and modify partitions on a block device."),
-		"  ",
-		N_("Command      Meaning"),
-		N_("-------      -------"),
-		N_("  b          Toggle bootable flag of the current partition"),
-		N_("  d          Delete the current partition"),
-		N_("  h          Print this screen"),
-		N_("  n          Create new partition from free space"),
-		N_("  q          Quit program without writing partition table"),
-		N_("  r          Reduce or enlarge the current partition"),
-		N_("  s          Fix partitions order (only when in disarray)"),
-		N_("  t          Change the partition type"),
-		N_("  u          Dump disk layout to sfdisk compatible script file"),
-		N_("  W          Write partition table to disk (you must enter uppercase W);"),
-		N_("               since this might destroy data on the disk, you must either"),
-		N_("               confirm or deny the write by entering 'yes' or 'no'"),
-		N_("  x          Display/hide extra information about a partition"),
-		N_("Up Arrow     Move cursor to the previous partition"),
-		N_("Down Arrow   Move cursor to the next partition"),
-		N_("Left Arrow   Move cursor to the previous menu item"),
-		N_("Right Arrow  Move cursor to the next menu item"),
-		"  ",
-		N_("Note: All of the commands can be entered with either upper or lower"),
-		N_("case letters (except for Write)."),
-		"  ",
-		N_("Use lsblk(8) or partx(8) to see more details about the device."),
-		"  ",
-		"  ",
-		"Copyright (C) 2014-2017 Karel Zak <kzak@redhat.com>"
-	};
-
-	erase();
-	for (i = 0; i < ARRAY_SIZE(help); i++)
-		mvaddstr(i, 1, _(help[i]));
-
-	ui_info(_("Press a key to continue."));
-
-	getch();
-
-	if (sig_die)
-		die_on_signal();
-	return 0;
+    size_t             i;
+    static const char* help[]
+        = {N_("This is cfdisk, a curses-based disk partitioning program."),
+           N_("It lets you create, delete, and modify partitions on a block "
+              "device."),
+           "  ",
+           N_("Command      Meaning"),
+           N_("-------      -------"),
+           N_("  b          Toggle bootable flag of the current partition"),
+           N_("  d          Delete the current partition"),
+           N_("  h          Print this screen"),
+           N_("  n          Create new partition from free space"),
+           N_("  q          Quit program without writing partition table"),
+           N_("  r          Reduce or enlarge the current partition"),
+           N_("  s          Fix partitions order (only when in disarray)"),
+           N_("  t          Change the partition type"),
+           N_("  u          Dump disk layout to sfdisk compatible script file"),
+           N_("  W          Write partition table to disk (you must enter "
+              "uppercase W);"),
+           N_("               since this might destroy data on the disk, you "
+              "must either"),
+           N_("               confirm or deny the write by entering 'yes' or "
+              "'no'"),
+           N_("  x          Display/hide extra information about a partition"),
+           N_("Up Arrow     Move cursor to the previous partition"),
+           N_("Down Arrow   Move cursor to the next partition"),
+           N_("Left Arrow   Move cursor to the previous menu item"),
+           N_("Right Arrow  Move cursor to the next menu item"),
+           "  ",
+           N_("Note: All of the commands can be entered with either upper or "
+              "lower"),
+           N_("case letters (except for Write)."),
+           "  ",
+           N_("Use lsblk(8) or partx(8) to see more details about the device."),
+           "  ",
+           "  ",
+           "Copyright (C) 2014-2017 Karel Zak <kzak@redhat.com>"};
+
+    erase();
+    for (i = 0; i < ARRAY_SIZE(help); i++) mvaddstr(i, 1, _(help[i]));
+
+    ui_info(_("Press a key to continue."));
+
+    getch();
+
+    if (sig_die) die_on_signal();
+    return 0;
 }
 
 /* TODO: use @sz, now 128bytes */
-static int main_menu_ignore_keys(struct cfdisk *cf, char *ignore,
-		size_t sz __attribute__((__unused__)))
+static int main_menu_ignore_keys(struct cfdisk* cf, char* ignore,
+                                 size_t sz __attribute__((__unused__)))
 {
-	struct fdisk_partition *pa = get_current_partition(cf);
-	size_t i = 0;
+    struct fdisk_partition* pa = get_current_partition(cf);
+    size_t                  i  = 0;
 
-	if (!pa)
-		return 0;
-	if (fdisk_partition_is_freespace(pa)) {
-		ignore[i++] = 'd';	/* delete */
-		ignore[i++] = 't';	/* set type */
-		ignore[i++] = 'b';      /* set bootable */
-		ignore[i++] = 'r';	/* resize */
-		cf->menu->prefkey = 'n';
-	} else {
-		cf->menu->prefkey = 'q';
-		ignore[i++] = 'n';
-		if (!fdisk_is_label(cf->cxt, DOS) &&
-		    !fdisk_is_label(cf->cxt, SGI))
-			ignore[i++] = 'b';
-	}
+    if (!pa) return 0;
+    if (fdisk_partition_is_freespace(pa))
+    {
+        ignore[i++]       = 'd'; /* delete */
+        ignore[i++]       = 't'; /* set type */
+        ignore[i++]       = 'b'; /* set bootable */
+        ignore[i++]       = 'r'; /* resize */
+        cf->menu->prefkey = 'n';
+    }
+    else
+    {
+        cf->menu->prefkey = 'q';
+        ignore[i++]       = 'n';
+        if (!fdisk_is_label(cf->cxt, DOS) && !fdisk_is_label(cf->cxt, SGI))
+            ignore[i++] = 'b';
+    }
 
-	if (!cf->wrong_order)
-		ignore[i++] = 's';
+    if (!cf->wrong_order) ignore[i++] = 's';
 
-	if (fdisk_is_readonly(cf->cxt))
-		ignore[i++] = 'W';
+    if (fdisk_is_readonly(cf->cxt)) ignore[i++] = 'W';
 
-	return i;
+    return i;
 }
 
-
 /* returns: error: < 0, success: 0, quit: 1 */
-static int main_menu_action(struct cfdisk *cf, int key)
-{
-	size_t n;
-	int ref = 0, rc, org_order = cf->wrong_order;
-	const char *info = NULL, *warn = NULL;
-	struct fdisk_partition *pa;
-
-	assert(cf);
-	assert(cf->cxt);
-	assert(cf->menu);
-
-	if (key == 0) {
-		struct cfdisk_menuitem *d = menu_get_menuitem(cf, cf->menu->idx);
-		if (!d)
-			return 0;
-		key = d->key;
-
-	} else if (key != 'w' && key != 'W')
-		key = tolower(key);	/* case insensitive except 'W'rite */
-
-	DBG(MENU, ul_debug("main menu action: key=%c", key));
-
-	if (cf->menu->ignore && strchr(cf->menu->ignore, key)) {
-		DBG(MENU, ul_debug("  ignore '%c'", key));
-		return 0;
-	}
-
-	pa = get_current_partition(cf);
-	if (!pa)
-		return -EINVAL;
-	n = fdisk_partition_get_partno(pa);
-
-	DBG(MENU, ul_debug("menu action on %p", pa));
-	ui_clean_hint();
-	ui_clean_info();
-
-	switch (key) {
-	case 'b': /* Bootable flag */
-	{
-		int fl = fdisk_is_label(cf->cxt, DOS) ? DOS_FLAG_ACTIVE :
-			 fdisk_is_label(cf->cxt, SGI) ? SGI_FLAG_BOOT : 0;
-
-		if (fl && fdisk_toggle_partition_flag(cf->cxt, n, fl))
-			warn = _("Could not toggle the flag.");
-		else if (fl)
-			ref = 1;
-		break;
-	}
+static int main_menu_action(struct cfdisk* cf, int key)
+{
+    size_t                  n;
+    int                     ref = 0, rc, org_order = cf->wrong_order;
+    const char *            info = NULL, *warn = NULL;
+    struct fdisk_partition* pa;
+
+    assert(cf);
+    assert(cf->cxt);
+    assert(cf->menu);
+
+    if (key == 0)
+    {
+        struct cfdisk_menuitem* d = menu_get_menuitem(cf, cf->menu->idx);
+        if (!d) return 0;
+        key = d->key;
+    }
+    else if (key != 'w' && key != 'W')
+        key = tolower(key); /* case insensitive except 'W'rite */
+
+    DBG(MENU, ul_debug("main menu action: key=%c", key));
+
+    if (cf->menu->ignore && strchr(cf->menu->ignore, key))
+    {
+        DBG(MENU, ul_debug("  ignore '%c'", key));
+        return 0;
+    }
+
+    pa = get_current_partition(cf);
+    if (!pa) return -EINVAL;
+    n = fdisk_partition_get_partno(pa);
+
+    DBG(MENU, ul_debug("menu action on %p", pa));
+    ui_clean_hint();
+    ui_clean_info();
+
+    switch (key)
+    {
+        case 'b': /* Bootable flag */
+        {
+            int fl = fdisk_is_label(cf->cxt, DOS) ? DOS_FLAG_ACTIVE
+                   : fdisk_is_label(cf->cxt, SGI) ? SGI_FLAG_BOOT
+                                                  : 0;
+
+            if (fl && fdisk_toggle_partition_flag(cf->cxt, n, fl))
+                warn = _("Could not toggle the flag.");
+            else if (fl) ref = 1;
+            break;
+        }
 #ifdef KEY_DC
-	case KEY_DC:
+        case KEY_DC:
 #endif
-	case 'd': /* Delete */
-		if (fdisk_delete_partition(cf->cxt, n) != 0)
-			warn = _("Could not delete partition %zu.");
-		else
-			info = _("Partition %zu has been deleted.");
-		ref = 1;
-		break;
-	case 'h': /* Help */
-	case '?':
-		ui_help();
-		ref = 1;
-		break;
-	case 'n': /* New */
-	{
-		uint64_t start, size, dflt_size, secs, max_size;
-		struct fdisk_partition *npa;	/* the new partition */
-		int expsize = 0;		/* size specified explicitly in sectors */
-
-		if (!fdisk_partition_is_freespace(pa) || !fdisk_partition_has_start(pa))
-			return -EINVAL;
-
-		/* free space range */
-		start = fdisk_partition_get_start(pa);
-		size = max_size = dflt_size = fdisk_partition_get_size(pa) * fdisk_get_sector_size(cf->cxt);
-
-		if (ui_get_size(cf, _("Partition size: "), &size,
-				fdisk_get_sector_size(cf->cxt),
-				max_size, &expsize) == -CFDISK_ERR_ESC)
-			break;
-
-		secs = size / fdisk_get_sector_size(cf->cxt);
-
-		npa = fdisk_new_partition();
-		if (!npa)
-			return -ENOMEM;
-
-		if (dflt_size == size)	/* default is to fillin all free space */
-			fdisk_partition_end_follow_default(npa, 1);
-		else
-			fdisk_partition_set_size(npa, secs);
-
-		if (expsize)
-			fdisk_partition_size_explicit(pa, 1);
-
-		fdisk_partition_set_start(npa, start);
-		fdisk_partition_partno_follow_default(npa, 1);
-		/* add to disk label -- libfdisk will ask for missing details */
-		rc = fdisk_add_partition(cf->cxt, npa, NULL);
-		fdisk_unref_partition(npa);
-		if (rc == 0)
-			ref = 1;
-		break;
-	}
-	case 'q': /* Quit */
-		return 1;
-	case 't': /* Type */
-	{
-		struct fdisk_parttype *t;
-
-		if (fdisk_partition_is_freespace(pa))
-			return -EINVAL;
-		t = (struct fdisk_parttype *) fdisk_partition_get_type(pa);
-		t = ui_get_parttype(cf, t);
-		ref = 1;
-
-		if (t && fdisk_set_partition_type(cf->cxt, n, t) == 0)
-			info = _("Changed type of partition %zu.");
-		else
-			info = _("The type of partition %zu is unchanged.");
-		break;
-	}
-	case 'r': /* resize */
-	{
-		struct fdisk_partition *npa, *next;
-		uint64_t size, max_size, secs;
-
-		if (fdisk_partition_is_freespace(pa) || !fdisk_partition_has_start(pa))
-			return -EINVAL;
-
-		size = fdisk_partition_get_size(pa);
-
-		/* is the next freespace? */
-		next = fdisk_table_get_partition(cf->table, cf->lines_idx + 1);
-		if (next && fdisk_partition_is_freespace(next))
-			size += fdisk_partition_get_size(next);
-
-		size *= fdisk_get_sector_size(cf->cxt);
-		max_size = size;
-
-		if (ui_get_size(cf, _("New size: "), &size,
-				fdisk_get_sector_size(cf->cxt),
-				max_size, NULL) == -CFDISK_ERR_ESC)
-			break;
-		secs = size / fdisk_get_sector_size(cf->cxt);
-		npa = fdisk_new_partition();
-		if (!npa)
-			return -ENOMEM;
-
-		fdisk_partition_set_size(npa, secs);
-
-		rc = fdisk_set_partition(cf->cxt, n, npa);
-		fdisk_unref_partition(npa);
-		if (rc == 0) {
-			ref = 1;
-			info = _("Partition %zu resized.");
-		}
-		break;
-	}
-	case 's': /* Sort */
-		if (cf->wrong_order) {
-			fdisk_reorder_partitions(cf->cxt);
-			ref = 1;
-		}
-		break;
-	case 'u': /* dUmp */
-		ui_script_write(cf);
-		break;
-	case 'W': /* Write */
-	{
-		char buf[64] = { 0 };
-
-		if (fdisk_is_readonly(cf->cxt)) {
-			warn = _("Device is open in read-only mode.");
-			break;
-		}
-
-		rc = ui_get_string(
-			  _("Are you sure you want to write the partition "
-			    "table to disk? "),
-			  _("Type \"yes\" or \"no\", or press ESC to leave this dialog."),
-			  buf, sizeof(buf));
-
-		ref = 1;
-		if (rc <= 0 || (strcasecmp(buf, "yes") != 0 &&
-				strcasecmp(buf, _("yes")) != 0)) {
-			info = _("Did not write partition table to disk.");
-			break;
-		}
-		rc = fdisk_write_disklabel(cf->cxt);
-		if (rc)
-			warn = _("Failed to write disklabel.");
-		else {
-			if (cf->device_is_used)
-				fdisk_reread_changes(cf->cxt, cf->original_layout);
-			else
-				fdisk_reread_partition_table(cf->cxt);
-			info = _("The partition table has been altered.");
-		}
-		cf->nwrites++;
-		break;
-	}
-	default:
-		break;
-	}
-
-	if (ref) {
-		lines_refresh(cf);
-		ui_refresh(cf);
-		ui_draw_extra(cf);
-	} else
-		ui_draw_menu(cf);
-
-	ui_clean_hint();
-
-	if (warn)
-		ui_warnx(warn, n + 1);
-	else if (info)
-		ui_info(info, n + 1);
-	else if (key == 'n' && cf->wrong_order && org_order == 0)
-		 ui_info(_("Note that partition table entries are not in disk order now."));
-
-	return 0;
-}
-
-static void ui_resize_refresh(struct cfdisk *cf)
-{
-	DBG(UI, ul_debug("ui resize/refresh"));
-	resize();
-	menu_refresh_size(cf);
-	lines_refresh(cf);
-	ui_refresh(cf);
-	ui_draw_extra(cf);
-}
-
-static void toggle_show_extra(struct cfdisk *cf)
-{
-	if (cf->show_extra && cf->act_win) {
-		wclear(cf->act_win);
-		touchwin(stdscr);
-	}
-	cf->show_extra = cf->show_extra ? 0 : 1;
-
-	if (cf->show_extra)
-		ui_draw_extra(cf);
-	DBG(MENU, ul_debug("extra: %s", cf->show_extra ? "ENABLED" : "DISABLED" ));
-}
-
-static int ui_run(struct cfdisk *cf)
-{
-	int rc = 0;
-
-	ui_lines = LINES;
-	ui_cols = COLS;
-	DBG(UI, ul_debug("start cols=%zu, lines=%zu", ui_cols, ui_lines));
-
-	if (fdisk_get_collision(cf->cxt)) {
-		ui_warnx(_("Device already contains a %s signature; it will be removed by a write command."),
-				fdisk_get_collision(cf->cxt));
-		fdisk_enable_wipe(cf->cxt, 1);
-		ui_hint(_("Press a key to continue."));
-		getch();
-	}
-
-	if (!fdisk_has_label(cf->cxt) || cf->zero_start) {
-		rc = ui_create_label(cf);
-		if (rc < 0) {
-			errno = -rc;
-			ui_err(EXIT_FAILURE,
-					_("failed to create a new disklabel"));
-		}
-		if (rc)
-			return rc;
-	}
-
-	cols_init(cf);
-	rc = lines_refresh(cf);
-	if (rc)
-		ui_errx(EXIT_FAILURE, _("failed to read partitions"));
-
-	menu_push(cf, main_menuitems);
-	cf->menu->ignore_cb = main_menu_ignore_keys;
-
-	rc = ui_refresh(cf);
-	if (rc)
-		return rc;
-
-	cf->show_extra = 1;
-	ui_draw_extra(cf);
-
-	if (fdisk_is_readonly(cf->cxt))
-		ui_warnx(_("Device is open in read-only mode."));
-	else if (cf->wrong_order)
-		ui_info(_("Note that partition table entries are not in disk order now."));
-
-	while (!sig_die) {
-		int key = getch();
-
-		rc = 0;
-
-		if (sig_die)
-			break;
-		if (sig_resize)
-			/* Note that ncurses getch() returns ERR when interrupted
-			 * by signal, but SLang does not interrupt at all. */
-			ui_resize_refresh(cf);
-		if (key == ERR)
-			continue;
-		if (key == '\014') {		/* ^L refresh */
-			ui_resize_refresh(cf);
-			continue;
-		}
-		if (ui_menu_move(cf, key) == 0)
-			continue;
-
-		DBG(UI, ul_debug("main action key >%1$c< [\\0%1$o].", key));
-
-		switch (key) {
-		case KEY_DOWN:
-		case '\016':	/* ^N */
-		case 'j':	/* Vi-like alternative */
-			ui_table_goto(cf, cf->lines_idx + 1);
-			break;
-		case KEY_UP:
-		case '\020':	/* ^P */
-		case 'k':	/* Vi-like alternative */
-			ui_table_goto(cf, (int) cf->lines_idx - 1);
-			break;
-		case KEY_PPAGE:
-			if (cf->page_sz) {
-				ui_table_goto(cf, (int) cf->lines_idx - cf->page_sz);
-				break;
-			}
-			/* fallthrough */
-		case KEY_HOME:
-			ui_table_goto(cf, 0);
-			break;
-		case KEY_NPAGE:
-			if (cf->page_sz) {
-				ui_table_goto(cf, cf->lines_idx + cf->page_sz);
-				break;
-			}
-			/* fallthrough */
-		case KEY_END:
-			ui_table_goto(cf, (int) cf->nlines - 1);
-			break;
-		case KEY_ENTER:
-		case '\n':
-		case '\r':
-			rc = main_menu_action(cf, 0);
-			break;
-		case 'X':
-		case 'x': /* Extra */
-			toggle_show_extra(cf);
-			break;
-		default:
-			rc = main_menu_action(cf, key);
-			if (rc < 0)
-				beep();
-			break;
-		}
-
-		if (rc == 1)
-			break; /* quit */
-	}
-
-	menu_pop(cf);
-
-	DBG(UI, ul_debug("end"));
-	return 0;
+        case 'd': /* Delete */
+            if (fdisk_delete_partition(cf->cxt, n) != 0)
+                warn = _("Could not delete partition %zu.");
+            else info = _("Partition %zu has been deleted.");
+            ref = 1;
+            break;
+        case 'h': /* Help */
+        case '?':
+            ui_help();
+            ref = 1;
+            break;
+        case 'n': /* New */
+        {
+            uint64_t                start, size, dflt_size, secs, max_size;
+            struct fdisk_partition* npa; /* the new partition */
+            int expsize = 0; /* size specified explicitly in sectors */
+
+            if (!fdisk_partition_is_freespace(pa)
+                || !fdisk_partition_has_start(pa))
+                return -EINVAL;
+
+            /* free space range */
+            start = fdisk_partition_get_start(pa);
+            size = max_size = dflt_size
+                = fdisk_partition_get_size(pa) * fdisk_get_sector_size(cf->cxt);
+
+            if (ui_get_size(cf, _("Partition size: "), &size,
+                            fdisk_get_sector_size(cf->cxt), max_size, &expsize)
+                == -CFDISK_ERR_ESC)
+                break;
+
+            secs = size / fdisk_get_sector_size(cf->cxt);
+
+            npa  = fdisk_new_partition();
+            if (!npa) return -ENOMEM;
+
+            if (dflt_size == size) /* default is to fillin all free space */
+                fdisk_partition_end_follow_default(npa, 1);
+            else fdisk_partition_set_size(npa, secs);
+
+            if (expsize) fdisk_partition_size_explicit(pa, 1);
+
+            fdisk_partition_set_start(npa, start);
+            fdisk_partition_partno_follow_default(npa, 1);
+            /* add to disk label -- libfdisk will ask for missing details */
+            rc = fdisk_add_partition(cf->cxt, npa, NULL);
+            fdisk_unref_partition(npa);
+            if (rc == 0) ref = 1;
+            break;
+        }
+        case 'q': /* Quit */ return 1;
+        case 't': /* Type */
+        {
+            struct fdisk_parttype* t;
+
+            if (fdisk_partition_is_freespace(pa)) return -EINVAL;
+            t   = (struct fdisk_parttype*)fdisk_partition_get_type(pa);
+            t   = ui_get_parttype(cf, t);
+            ref = 1;
+
+            if (t && fdisk_set_partition_type(cf->cxt, n, t) == 0)
+                info = _("Changed type of partition %zu.");
+            else info = _("The type of partition %zu is unchanged.");
+            break;
+        }
+        case 'r': /* resize */
+        {
+            struct fdisk_partition *npa, *next;
+            uint64_t                size, max_size, secs;
+
+            if (fdisk_partition_is_freespace(pa)
+                || !fdisk_partition_has_start(pa))
+                return -EINVAL;
+
+            size = fdisk_partition_get_size(pa);
+
+            /* is the next freespace? */
+            next = fdisk_table_get_partition(cf->table, cf->lines_idx + 1);
+            if (next && fdisk_partition_is_freespace(next))
+                size += fdisk_partition_get_size(next);
+
+            size *= fdisk_get_sector_size(cf->cxt);
+            max_size = size;
+
+            if (ui_get_size(cf, _("New size: "), &size,
+                            fdisk_get_sector_size(cf->cxt), max_size, NULL)
+                == -CFDISK_ERR_ESC)
+                break;
+            secs = size / fdisk_get_sector_size(cf->cxt);
+            npa  = fdisk_new_partition();
+            if (!npa) return -ENOMEM;
+
+            fdisk_partition_set_size(npa, secs);
+
+            rc = fdisk_set_partition(cf->cxt, n, npa);
+            fdisk_unref_partition(npa);
+            if (rc == 0)
+            {
+                ref  = 1;
+                info = _("Partition %zu resized.");
+            }
+            break;
+        }
+        case 's': /* Sort */
+            if (cf->wrong_order)
+            {
+                fdisk_reorder_partitions(cf->cxt);
+                ref = 1;
+            }
+            break;
+        case 'u': /* dUmp */ ui_script_write(cf); break;
+        case 'W': /* Write */
+        {
+            char buf[64] = {0};
+
+            if (fdisk_is_readonly(cf->cxt))
+            {
+                warn = _("Device is open in read-only mode.");
+                break;
+            }
+
+            rc = ui_get_string(
+                _("Are you sure you want to write the partition "
+                  "table to disk? "),
+                _("Type \"yes\" or \"no\", or press ESC to leave this dialog."),
+                buf, sizeof(buf));
+
+            ref = 1;
+            if (rc <= 0
+                || (strcasecmp(buf, "yes") != 0
+                    && strcasecmp(buf, _("yes")) != 0))
+            {
+                info = _("Did not write partition table to disk.");
+                break;
+            }
+            rc = fdisk_write_disklabel(cf->cxt);
+            if (rc) warn = _("Failed to write disklabel.");
+            else
+            {
+                if (cf->device_is_used)
+                    fdisk_reread_changes(cf->cxt, cf->original_layout);
+                else fdisk_reread_partition_table(cf->cxt);
+                info = _("The partition table has been altered.");
+            }
+            cf->nwrites++;
+            break;
+        }
+        default: break;
+    }
+
+    if (ref)
+    {
+        lines_refresh(cf);
+        ui_refresh(cf);
+        ui_draw_extra(cf);
+    }
+    else ui_draw_menu(cf);
+
+    ui_clean_hint();
+
+    if (warn) ui_warnx(warn, n + 1);
+    else if (info) ui_info(info, n + 1);
+    else if (key == 'n' && cf->wrong_order && org_order == 0)
+        ui_info(
+            _("Note that partition table entries are not in disk order now."));
+
+    return 0;
+}
+
+static void ui_resize_refresh(struct cfdisk* cf)
+{
+    DBG(UI, ul_debug("ui resize/refresh"));
+    resize();
+    menu_refresh_size(cf);
+    lines_refresh(cf);
+    ui_refresh(cf);
+    ui_draw_extra(cf);
+}
+
+static void toggle_show_extra(struct cfdisk* cf)
+{
+    if (cf->show_extra && cf->act_win)
+    {
+        wclear(cf->act_win);
+        touchwin(stdscr);
+    }
+    cf->show_extra = cf->show_extra ? 0 : 1;
+
+    if (cf->show_extra) ui_draw_extra(cf);
+    DBG(MENU, ul_debug("extra: %s", cf->show_extra ? "ENABLED" : "DISABLED"));
+}
+
+static int ui_run(struct cfdisk* cf)
+{
+    int rc   = 0;
+
+    ui_lines = LINES;
+    ui_cols  = COLS;
+    DBG(UI, ul_debug("start cols=%zu, lines=%zu", ui_cols, ui_lines));
+
+    if (fdisk_get_collision(cf->cxt))
+    {
+        ui_warnx(_("Device already contains a %s signature; it will be removed "
+                   "by a write command."),
+                 fdisk_get_collision(cf->cxt));
+        fdisk_enable_wipe(cf->cxt, 1);
+        ui_hint(_("Press a key to continue."));
+        getch();
+    }
+
+    if (!fdisk_has_label(cf->cxt) || cf->zero_start)
+    {
+        rc = ui_create_label(cf);
+        if (rc < 0)
+        {
+            errno = -rc;
+            ui_err(EXIT_FAILURE, _("failed to create a new disklabel"));
+        }
+        if (rc) return rc;
+    }
+
+    cols_init(cf);
+    rc = lines_refresh(cf);
+    if (rc) ui_errx(EXIT_FAILURE, _("failed to read partitions"));
+
+    menu_push(cf, main_menuitems);
+    cf->menu->ignore_cb = main_menu_ignore_keys;
+
+    rc                  = ui_refresh(cf);
+    if (rc) return rc;
+
+    cf->show_extra = 1;
+    ui_draw_extra(cf);
+
+    if (fdisk_is_readonly(cf->cxt))
+        ui_warnx(_("Device is open in read-only mode."));
+    else if (cf->wrong_order)
+        ui_info(
+            _("Note that partition table entries are not in disk order now."));
+
+    while (!sig_die)
+    {
+        int key = getch();
+
+        rc      = 0;
+
+        if (sig_die) break;
+        if (sig_resize)
+            /* Note that ncurses getch() returns ERR when interrupted
+             * by signal, but SLang does not interrupt at all. */
+            ui_resize_refresh(cf);
+        if (key == ERR) continue;
+        if (key == '\014')
+        { /* ^L refresh */
+            ui_resize_refresh(cf);
+            continue;
+        }
+        if (ui_menu_move(cf, key) == 0) continue;
+
+        DBG(UI, ul_debug("main action key >%1$c< [\\0%1$o].", key));
+
+        switch (key)
+        {
+            case KEY_DOWN:
+            case '\016': /* ^N */
+            case 'j':    /* Vi-like alternative */
+                ui_table_goto(cf, cf->lines_idx + 1);
+                break;
+            case KEY_UP:
+            case '\020': /* ^P */
+            case 'k':    /* Vi-like alternative */
+                ui_table_goto(cf, (int)cf->lines_idx - 1);
+                break;
+            case KEY_PPAGE:
+                if (cf->page_sz)
+                {
+                    ui_table_goto(cf, (int)cf->lines_idx - cf->page_sz);
+                    break;
+                }
+                /* fallthrough */
+            case KEY_HOME: ui_table_goto(cf, 0); break;
+            case KEY_NPAGE:
+                if (cf->page_sz)
+                {
+                    ui_table_goto(cf, cf->lines_idx + cf->page_sz);
+                    break;
+                }
+                /* fallthrough */
+            case KEY_END: ui_table_goto(cf, (int)cf->nlines - 1); break;
+            case KEY_ENTER:
+            case '\n':
+            case '\r': rc = main_menu_action(cf, 0); break;
+            case 'X':
+            case 'x': /* Extra */ toggle_show_extra(cf); break;
+            default:
+                rc = main_menu_action(cf, key);
+                if (rc < 0) beep();
+                break;
+        }
+
+        if (rc == 1) break; /* quit */
+    }
+
+    menu_pop(cf);
+
+    DBG(UI, ul_debug("end"));
+    return 0;
 }
 
 static void __attribute__((__noreturn__)) usage(void)
 {
-	FILE *out = stdout;
-	fputs(USAGE_HEADER, out);
-	fprintf(out,
-	      _(" %1$s [options] <disk>\n"), program_invocation_short_name);
-
-	fputs(USAGE_SEPARATOR, out);
-	fputs(_("Display or manipulate a disk partition table.\n"), out);
-
-	fputs(USAGE_OPTIONS, out);
-	fprintf(out,
-	      _(" -L, --color[=<when>]     colorize output (%s, %s or %s)\n"), "auto", "always", "never");
-	fprintf(out,
-	        "                            %s\n", USAGE_COLORS_DEFAULT);
-	fputs(_(" -z, --zero               start with zeroed partition table\n"), out);
-	fprintf(out,
-	      _("     --lock[=<mode>]      use exclusive device lock (%s, %s or %s)\n"), "yes", "no", "nonblock");
-
-	fputs(USAGE_SEPARATOR, out);
-	printf(USAGE_HELP_OPTIONS(26));
-
-	printf(USAGE_MAN_TAIL("cfdisk(8)"));
-	exit(EXIT_SUCCESS);
-}
-
-int main(int argc, char *argv[])
-{
-	const char *diskpath = NULL, *lockmode = NULL;
-	int rc, c, colormode = UL_COLORMODE_UNDEF;
-	struct cfdisk _cf = { .lines_idx = 0 },
-		      *cf = &_cf;
-	enum {
-		OPT_LOCK	= CHAR_MAX + 1
-	};
-	static const struct option longopts[] = {
-		{ "color",   optional_argument, NULL, 'L' },
-		{ "lock",    optional_argument, NULL, OPT_LOCK },
-		{ "help",    no_argument,       NULL, 'h' },
-		{ "version", no_argument,       NULL, 'V' },
-		{ "zero",    no_argument,	NULL, 'z' },
-		{ NULL, 0, NULL, 0 },
-	};
-
-	setlocale(LC_ALL, "");
-	bindtextdomain(PACKAGE, LOCALEDIR);
-	textdomain(PACKAGE);
-	close_stdout_atexit();
-
-	while((c = getopt_long(argc, argv, "L::hVz", longopts, NULL)) != -1) {
-		switch(c) {
-		case 'h':
-			usage();
-			break;
-		case 'L':
-			colormode = UL_COLORMODE_AUTO;
-			if (optarg)
-				colormode = colormode_or_err(optarg,
-						_("unsupported color mode"));
-			break;
-		case 'V':
-			print_version(EXIT_SUCCESS);
-		case 'z':
-			cf->zero_start = 1;
-			break;
-		case OPT_LOCK:
-			lockmode = "1";
-			if (optarg) {
-				if (*optarg == '=')
-					optarg++;
-				lockmode = optarg;
-			}
-			break;
-		default:
-			errtryhelp(EXIT_FAILURE);
-		}
-	}
-
-	colors_init(colormode, "cfdisk");
-
-	fdisk_init_debug(0);
-	scols_init_debug(0);
-	cfdisk_init_debug();
-	cf->cxt = fdisk_new_context();
-	if (!cf->cxt)
-		err(EXIT_FAILURE, _("failed to allocate libfdisk context"));
-
-	fdisk_set_ask(cf->cxt, ask_callback, (void *) cf);
-
-	if (optind == argc) {
-		size_t i;
-
-		for (i = 0; i < ARRAY_SIZE(default_disks); i++) {
-			if (access(default_disks[i], F_OK) == 0) {
-				diskpath = default_disks[i];
-				break;
-			}
-		}
-		if (!diskpath)
-			diskpath = default_disks[0];	/* default, used for "cannot open" */
-	} else
-		diskpath = argv[optind];
-
-	rc = fdisk_assign_device(cf->cxt, diskpath, 0);
-	if (rc == -EACCES)
-		rc = fdisk_assign_device(cf->cxt, diskpath, 1);
-	if (rc != 0)
-		err(EXIT_FAILURE, _("cannot open %s"), diskpath);
-
-	if (!fdisk_is_readonly(cf->cxt)) {
-		if (blkdev_lock(fdisk_get_devfd(cf->cxt), diskpath, lockmode) != 0)
-			return EXIT_FAILURE;
-
-		cf->device_is_used = fdisk_device_is_used(cf->cxt);
-		fdisk_get_partitions(cf->cxt, &cf->original_layout);
-	}
-
-	/* Don't use err(), warn() from this point */
-	ui_init(cf);
-	ui_run(cf);
-	ui_end();
-
-	cfdisk_free_lines(cf);
-	free(cf->linesbuf);
-	free(cf->fields);
-
-	fdisk_unref_table(cf->table);
+    FILE* out = stdout;
+    fputs(USAGE_HEADER, out);
+    fprintf(out, _(" %1$s [options] <disk>\n"), program_invocation_short_name);
+
+    fputs(USAGE_SEPARATOR, out);
+    fputs(_("Display or manipulate a disk partition table.\n"), out);
+
+    fputs(USAGE_OPTIONS, out);
+    fprintf(out,
+            _(" -L, --color[=<when>]     colorize output (%s, %s or %s)\n"),
+            "auto", "always", "never");
+    fprintf(out, "                            %s\n", USAGE_COLORS_DEFAULT);
+    fputs(_(" -z, --zero               start with zeroed partition table\n"),
+          out);
+    fprintf(out,
+            _("     --lock[=<mode>]      use exclusive device lock (%s, %s or "
+              "%s)\n"),
+            "yes", "no", "nonblock");
+
+    fputs(USAGE_SEPARATOR, out);
+    printf(USAGE_HELP_OPTIONS(26));
+
+    printf(USAGE_MAN_TAIL("cfdisk(8)"));
+    exit(EXIT_SUCCESS);
+}
+
+int main(int argc, char* argv[])
+{
+    const char *  diskpath = NULL, *lockmode = NULL;
+    int           rc, c, colormode = UL_COLORMODE_UNDEF;
+    struct cfdisk _cf = {.lines_idx = 0}, *cf = &_cf;
+    enum
+    {
+        OPT_LOCK = CHAR_MAX + 1
+    };
+    static const struct option longopts[] = {
+        {"color", optional_argument, NULL, 'L'},
+        {"lock", optional_argument, NULL, OPT_LOCK},
+        {"help", no_argument, NULL, 'h'},
+        {"version", no_argument, NULL, 'V'},
+        {"zero", no_argument, NULL, 'z'},
+        {NULL, 0, NULL, 0},
+    };
+
+    setlocale(LC_ALL, "");
+    bindtextdomain(PACKAGE, LOCALEDIR);
+    textdomain(PACKAGE);
+    close_stdout_atexit();
+
+    while ((c = getopt_long(argc, argv, "L::hVz", longopts, NULL)) != -1)
+    {
+        switch (c)
+        {
+            case 'h': usage(); break;
+            case 'L':
+                colormode = UL_COLORMODE_AUTO;
+                if (optarg)
+                    colormode
+                        = colormode_or_err(optarg, _("unsupported color mode"));
+                break;
+            case 'V': print_version(EXIT_SUCCESS);
+            case 'z': cf->zero_start = 1; break;
+            case OPT_LOCK:
+                lockmode = "1";
+                if (optarg)
+                {
+                    if (*optarg == '=') optarg++;
+                    lockmode = optarg;
+                }
+                break;
+            default: errtryhelp(EXIT_FAILURE);
+        }
+    }
+
+    colors_init(colormode, "cfdisk");
+
+    fdisk_init_debug(0);
+    scols_init_debug(0);
+    cfdisk_init_debug();
+    cf->cxt = fdisk_new_context();
+    if (!cf->cxt) err(EXIT_FAILURE, _("failed to allocate libfdisk context"));
+
+    fdisk_set_ask(cf->cxt, ask_callback, (void*)cf);
+
+    if (optind == argc)
+    {
+        size_t i;
+
+        for (i = 0; i < ARRAY_SIZE(default_disks); i++)
+        {
+            if (access(default_disks[i], F_OK) == 0)
+            {
+                diskpath = default_disks[i];
+                break;
+            }
+        }
+        if (!diskpath)
+            diskpath = default_disks[0]; /* default, used for "cannot open" */
+    }
+    else diskpath = argv[optind];
+
+    rc = fdisk_assign_device(cf->cxt, diskpath, 0);
+    if (rc == -EACCES) rc = fdisk_assign_device(cf->cxt, diskpath, 1);
+    if (rc != 0) err(EXIT_FAILURE, _("cannot open %s"), diskpath);
+
+    if (!fdisk_is_readonly(cf->cxt))
+    {
+        if (blkdev_lock(fdisk_get_devfd(cf->cxt), diskpath, lockmode) != 0)
+            return EXIT_FAILURE;
+
+        cf->device_is_used = fdisk_device_is_used(cf->cxt);
+        fdisk_get_partitions(cf->cxt, &cf->original_layout);
+    }
+
+    /* Don't use err(), warn() from this point */
+    ui_init(cf);
+    ui_run(cf);
+    ui_end();
+
+    cfdisk_free_lines(cf);
+    free(cf->linesbuf);
+    free(cf->fields);
+
+    fdisk_unref_table(cf->table);
 #ifdef HAVE_LIBMOUNT
-	mnt_unref_table(cf->fstab);
-	mnt_unref_table(cf->mtab);
-	mnt_unref_cache(cf->mntcache);
+    mnt_unref_table(cf->fstab);
+    mnt_unref_table(cf->mtab);
+    mnt_unref_cache(cf->mntcache);
 #endif
-	rc = fdisk_deassign_device(cf->cxt, cf->nwrites == 0);
-	fdisk_unref_context(cf->cxt);
-	DBG(MISC, ul_debug("bye! [rc=%d]", rc));
-	return rc == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+    rc = fdisk_deassign_device(cf->cxt, cf->nwrites == 0);
+    fdisk_unref_context(cf->cxt);
+    DBG(MISC, ul_debug("bye! [rc=%d]", rc));
+    return rc == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
 }
diff --git a/include/namespace.h b/include/namespace.h
index 2d0a56e..6c81bb7 100644
--- a/include/namespace.h
+++ b/include/namespace.h
@@ -6,51 +6,51 @@
  * Compat code so unshare and setns can be used with older libcs
  */
 #ifndef UTIL_LINUX_NAMESPACE_H
-# define UTIL_LINUX_NAMESPACE_H
-
-# include <sched.h>
-
-# ifndef CLONE_NEWNS
-#  define CLONE_NEWNS 0x00020000
-# endif
-# ifndef CLONE_NEWCGROUP
-#  define CLONE_NEWCGROUP 0x02000000
-# endif
-# ifndef CLONE_NEWUTS
-#  define CLONE_NEWUTS 0x04000000
-# endif
-# ifndef CLONE_NEWIPC
-#  define CLONE_NEWIPC 0x08000000
-# endif
-# ifndef CLONE_NEWNET
-#  define CLONE_NEWNET 0x40000000
-# endif
-# ifndef CLONE_NEWUSER
-#  define CLONE_NEWUSER 0x10000000
-# endif
-# ifndef CLONE_NEWPID
-#  define CLONE_NEWPID 0x20000000
-# endif
-# ifndef CLONE_NEWTIME
-#  define CLONE_NEWTIME 0x00000080
-# endif
-
-# if !defined(HAVE_UNSHARE) || !defined(HAVE_SETNS)
-#  include <sys/syscall.h>
-# endif
-
-# if !defined(HAVE_UNSHARE) && defined(SYS_unshare)
-static inline int unshare(int flags)
-{
-	return syscall(SYS_unshare, flags);
-}
-# endif
+#define UTIL_LINUX_NAMESPACE_H
+#ifndef __cryptix__
+
+    #include <sched.h>
+
+    #ifndef CLONE_NEWNS
+        #define CLONE_NEWNS 0x00020000
+    #endif
+    #ifndef CLONE_NEWCGROUP
+        #define CLONE_NEWCGROUP 0x02000000
+    #endif
+    #ifndef CLONE_NEWUTS
+        #define CLONE_NEWUTS 0x04000000
+    #endif
+    #ifndef CLONE_NEWIPC
+        #define CLONE_NEWIPC 0x08000000
+    #endif
+    #ifndef CLONE_NEWNET
+        #define CLONE_NEWNET 0x40000000
+    #endif
+    #ifndef CLONE_NEWUSER
+        #define CLONE_NEWUSER 0x10000000
+    #endif
+    #ifndef CLONE_NEWPID
+        #define CLONE_NEWPID 0x20000000
+    #endif
+    #ifndef CLONE_NEWTIME
+        #define CLONE_NEWTIME 0x00000080
+    #endif
 
-# if !defined(HAVE_SETNS) && defined(SYS_setns)
+    #if !defined(HAVE_UNSHARE) || !defined(HAVE_SETNS)
+        #include <sys/syscall.h>
+    #endif
+
+    #if !defined(HAVE_UNSHARE) && defined(SYS_unshare)
+static inline int unshare(int flags) { return syscall(SYS_unshare, flags); }
+    #endif
+
+    #if !defined(HAVE_SETNS) && defined(SYS_setns)
 static inline int setns(int fd, int nstype)
 {
-	return syscall(SYS_setns, fd, nstype);
+    return syscall(SYS_setns, fd, nstype);
 }
-# endif
+    #endif
+
+#endif
 
-#endif	/* UTIL_LINUX_NAMESPACE_H */
+#endif /* UTIL_LINUX_NAMESPACE_H */
diff --git a/include/path.h b/include/path.h
index 2a4f80e..f8676ec 100644
--- a/include/path.h
+++ b/include/path.h
@@ -1,135 +1,154 @@
 #ifndef UTIL_LINUX_PATH_H
 #define UTIL_LINUX_PATH_H
 
-#include <stdio.h>
+#include <dirent.h>
 #include <stdint.h>
+#include <stdio.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#include <dirent.h>
 
 #include "c.h"
 
-struct path_cxt {
-	int	dir_fd;
-	char	*dir_path;
+struct path_cxt
+{
+    int   dir_fd;
+    char* dir_path;
 
-	int	refcount;
+    int   refcount;
 
-	char *prefix;
-	char path_buffer[PATH_MAX];
+    char* prefix;
+    char  path_buffer[PATH_MAX];
 
-	void	*dialect;
-	void	(*free_dialect)(struct path_cxt *);
-	int	(*redirect_on_enoent)(struct path_cxt *, const char *, int *);
+    void* dialect;
+    void (*free_dialect)(struct path_cxt*);
+    int (*redirect_on_enoent)(struct path_cxt*, const char*, int*);
 };
 
-struct path_cxt *ul_new_path(const char *dir, ...);
-void ul_unref_path(struct path_cxt *pc);
-void ul_ref_path(struct path_cxt *pc);
-
-void ul_path_init_debug(void);
-
-int ul_path_set_prefix(struct path_cxt *pc, const char *prefix);
-const char *ul_path_get_prefix(struct path_cxt *pc);
-
-int ul_path_set_dir(struct path_cxt *pc, const char *dir);
-const char *ul_path_get_dir(struct path_cxt *pc);
-
-int ul_path_set_dialect(struct path_cxt *pc, void *data, void free_data(struct path_cxt *));
-void *ul_path_get_dialect(struct path_cxt *pc);
-
-int ul_path_set_enoent_redirect(struct path_cxt *pc, int (*func)(struct path_cxt *, const char *, int *));
-int ul_path_get_dirfd(struct path_cxt *pc);
-void ul_path_close_dirfd(struct path_cxt *pc);
-int ul_path_isopen_dirfd(struct path_cxt *pc);
-int ul_path_is_accessible(struct path_cxt *pc);
-
-char *ul_path_get_abspath(struct path_cxt *pc, char *buf, size_t bufsz, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 4, 5)));
-
-int ul_path_stat(struct path_cxt *pc, struct stat *sb, const char *path);
-int ul_path_access(struct path_cxt *pc, int mode, const char *path);
-int ul_path_accessf(struct path_cxt *pc, int mode, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 3, 4)));
-
-int ul_path_open(struct path_cxt *pc, int flags, const char *path);
-int ul_path_openf(struct path_cxt *pc, int flags, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 3, 4)));
-int ul_path_vopenf(struct path_cxt *pc, int flags, const char *path, va_list ap);
-
-FILE *ul_path_fopen(struct path_cxt *pc, const char *mode, const char *path);
-FILE *ul_path_fopenf(struct path_cxt *pc, const char *mode, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 3, 4)));
-FILE *ul_path_vfopenf(struct path_cxt *pc, const char *mode, const char *path, va_list ap);
-
-DIR *ul_path_opendir(struct path_cxt *pc, const char *path);
-DIR *ul_path_vopendirf(struct path_cxt *pc, const char *path, va_list ap);
-DIR *ul_path_opendirf(struct path_cxt *pc, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 2, 3)));
-
-ssize_t ul_path_readlink(struct path_cxt *pc, char *buf, size_t bufsiz, const char *path);
-ssize_t ul_path_readlinkf(struct path_cxt *pc, char *buf, size_t bufsiz, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 4, 5)));
-
-int ul_path_read(struct path_cxt *pc, char *buf, size_t len, const char *path);
-int ul_path_vreadf(struct path_cxt *pc, char *buf, size_t len, const char *path, va_list ap);
-int ul_path_readf(struct path_cxt *pc, char *buf, size_t len, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 4, 5)));
-
-int ul_path_read_string(struct path_cxt *pc, char **str, const char *path);
-int ul_path_readf_string(struct path_cxt *pc, char **str, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 3, 4)));
-
-int ul_path_read_buffer(struct path_cxt *pc, char *buf, size_t bufsz, const char *path);
-int ul_path_readf_buffer(struct path_cxt *pc, char *buf, size_t bufsz, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 4, 5)));
-
-int ul_path_scanf(struct path_cxt *pc, const char *path, const char *fmt, ...);
-int ul_path_scanff(struct path_cxt *pc, const char *path, va_list ap, const char *fmt, ...)
-				__attribute__ ((__format__ (__scanf__, 4, 5)));
-
-int ul_path_read_majmin(struct path_cxt *pc, dev_t *res, const char *path);
-int ul_path_readf_majmin(struct path_cxt *pc, dev_t *res, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 3, 4)));
-
-int ul_path_read_u32(struct path_cxt *pc, uint32_t *res, const char *path);
-int ul_path_readf_u32(struct path_cxt *pc, uint32_t *res, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 3, 4)));
-
-int ul_path_read_s32(struct path_cxt *pc, int32_t *res, const char *path);
-int ul_path_readf_s32(struct path_cxt *pc, int32_t *res, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 3, 4)));
-
-int ul_path_read_u64(struct path_cxt *pc, uint64_t *res, const char *path);
-int ul_path_readf_u64(struct path_cxt *pc, uint64_t *res, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 3, 4)));
-
-int ul_path_read_s64(struct path_cxt *pc, int64_t *res, const char *path);
-int ul_path_readf_s64(struct path_cxt *pc, int64_t *res, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 3, 4)));
-
-int ul_path_write_string(struct path_cxt *pc, const char *str, const char *path);
-int ul_path_writef_string(struct path_cxt *pc, const char *str, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 3, 4)));
-
-int ul_path_write_s64(struct path_cxt *pc, int64_t num, const char *path);
-int ul_path_write_u64(struct path_cxt *pc, uint64_t num, const char *path);
-int ul_path_writef_u64(struct path_cxt *pc, uint64_t num, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 3, 4)));
-
-int ul_path_count_dirents(struct path_cxt *pc, const char *path);
-int ul_path_countf_dirents(struct path_cxt *pc, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 2, 3)));
-
-FILE *ul_prefix_fopen(const char *prefix, const char *path, const char *mode);
-
-
-#ifdef HAVE_CPU_SET_T
-# include "cpuset.h"
-int ul_path_readf_cpuset(struct path_cxt *pc, cpu_set_t **set, int maxcpus, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 4, 5)));
-
-int ul_path_readf_cpulist(struct path_cxt *pc, cpu_set_t **set, int maxcpus, const char *path, ...)
-				__attribute__ ((__format__ (__printf__, 4, 5)));
-#endif /* HAVE_CPU_SET_T */
+struct path_cxt* ul_new_path(const char* dir, ...);
+void             ul_unref_path(struct path_cxt* pc);
+void             ul_ref_path(struct path_cxt* pc);
+
+void             ul_path_init_debug(void);
+
+int              ul_path_set_prefix(struct path_cxt* pc, const char* prefix);
+const char*      ul_path_get_prefix(struct path_cxt* pc);
+
+int              ul_path_set_dir(struct path_cxt* pc, const char* dir);
+const char*      ul_path_get_dir(struct path_cxt* pc);
+
+int              ul_path_set_dialect(struct path_cxt* pc, void* data,
+                                     void free_data(struct path_cxt*));
+void*            ul_path_get_dialect(struct path_cxt* pc);
+
+int              ul_path_set_enoent_redirect(struct path_cxt* pc,
+                                             int (*func)(struct path_cxt*, const char*,
+                                            int*));
+int              ul_path_get_dirfd(struct path_cxt* pc);
+void             ul_path_close_dirfd(struct path_cxt* pc);
+int              ul_path_isopen_dirfd(struct path_cxt* pc);
+int              ul_path_is_accessible(struct path_cxt* pc);
+
+char* ul_path_get_abspath(struct path_cxt* pc, char* buf, size_t bufsz,
+                          const char* path, ...)
+    __attribute__((__format__(__printf__, 4, 5)));
+
+int ul_path_stat(struct path_cxt* pc, struct stat* sb, const char* path);
+int ul_path_access(struct path_cxt* pc, int mode, const char* path);
+int ul_path_accessf(struct path_cxt* pc, int mode, const char* path, ...)
+    __attribute__((__format__(__printf__, 3, 4)));
+
+int ul_path_open(struct path_cxt* pc, int flags, const char* path);
+int ul_path_openf(struct path_cxt* pc, int flags, const char* path, ...)
+    __attribute__((__format__(__printf__, 3, 4)));
+int   ul_path_vopenf(struct path_cxt* pc, int flags, const char* path,
+                     va_list ap);
+
+FILE* ul_path_fopen(struct path_cxt* pc, const char* mode, const char* path);
+FILE* ul_path_fopenf(struct path_cxt* pc, const char* mode, const char* path,
+                     ...) __attribute__((__format__(__printf__, 3, 4)));
+FILE* ul_path_vfopenf(struct path_cxt* pc, const char* mode, const char* path,
+                      va_list ap);
+
+DIR*  ul_path_opendir(struct path_cxt* pc, const char* path);
+DIR*  ul_path_vopendirf(struct path_cxt* pc, const char* path, va_list ap);
+DIR*  ul_path_opendirf(struct path_cxt* pc, const char* path, ...)
+    __attribute__((__format__(__printf__, 2, 3)));
+
+ssize_t ul_path_readlink(struct path_cxt* pc, char* buf, size_t bufsiz,
+                         const char* path);
+ssize_t ul_path_readlinkf(struct path_cxt* pc, char* buf, size_t bufsiz,
+                          const char* path, ...)
+    __attribute__((__format__(__printf__, 4, 5)));
+
+int ul_path_read(struct path_cxt* pc, char* buf, size_t len, const char* path);
+int ul_path_vreadf(struct path_cxt* pc, char* buf, size_t len, const char* path,
+                   va_list ap);
+int ul_path_readf(struct path_cxt* pc, char* buf, size_t len, const char* path,
+                  ...) __attribute__((__format__(__printf__, 4, 5)));
+
+int ul_path_read_string(struct path_cxt* pc, char** str, const char* path);
+int ul_path_readf_string(struct path_cxt* pc, char** str, const char* path, ...)
+    __attribute__((__format__(__printf__, 3, 4)));
+
+int ul_path_read_buffer(struct path_cxt* pc, char* buf, size_t bufsz,
+                        const char* path);
+int ul_path_readf_buffer(struct path_cxt* pc, char* buf, size_t bufsz,
+                         const char* path, ...)
+    __attribute__((__format__(__printf__, 4, 5)));
+
+int ul_path_scanf(struct path_cxt* pc, const char* path, const char* fmt, ...);
+int ul_path_scanff(struct path_cxt* pc, const char* path, va_list ap,
+                   const char* fmt, ...)
+    __attribute__((__format__(__scanf__, 4, 5)));
+
+int ul_path_read_majmin(struct path_cxt* pc, dev_t* res, const char* path);
+int ul_path_readf_majmin(struct path_cxt* pc, dev_t* res, const char* path, ...)
+    __attribute__((__format__(__printf__, 3, 4)));
+
+int ul_path_read_u32(struct path_cxt* pc, uint32_t* res, const char* path);
+int ul_path_readf_u32(struct path_cxt* pc, uint32_t* res, const char* path, ...)
+    __attribute__((__format__(__printf__, 3, 4)));
+
+int ul_path_read_s32(struct path_cxt* pc, int32_t* res, const char* path);
+int ul_path_readf_s32(struct path_cxt* pc, int32_t* res, const char* path, ...)
+    __attribute__((__format__(__printf__, 3, 4)));
+
+int ul_path_read_u64(struct path_cxt* pc, uint64_t* res, const char* path);
+int ul_path_readf_u64(struct path_cxt* pc, uint64_t* res, const char* path, ...)
+    __attribute__((__format__(__printf__, 3, 4)));
+
+int ul_path_read_s64(struct path_cxt* pc, int64_t* res, const char* path);
+int ul_path_readf_s64(struct path_cxt* pc, int64_t* res, const char* path, ...)
+    __attribute__((__format__(__printf__, 3, 4)));
+
+int ul_path_write_string(struct path_cxt* pc, const char* str,
+                         const char* path);
+int ul_path_writef_string(struct path_cxt* pc, const char* str,
+                          const char* path, ...)
+    __attribute__((__format__(__printf__, 3, 4)));
+
+int ul_path_write_s64(struct path_cxt* pc, int64_t num, const char* path);
+int ul_path_write_u64(struct path_cxt* pc, uint64_t num, const char* path);
+int ul_path_writef_u64(struct path_cxt* pc, uint64_t num, const char* path, ...)
+    __attribute__((__format__(__printf__, 3, 4)));
+
+int ul_path_count_dirents(struct path_cxt* pc, const char* path);
+int ul_path_countf_dirents(struct path_cxt* pc, const char* path, ...)
+    __attribute__((__format__(__printf__, 2, 3)));
+
+FILE* ul_prefix_fopen(const char* prefix, const char* path, const char* mode);
+
+#ifndef __cryptix__
+
+    #ifdef HAVE_CPU_SET_T
+        #include "cpuset.h"
+int ul_path_readf_cpuset(struct path_cxt* pc, cpu_set_t** set, int maxcpus,
+                         const char* path, ...)
+    __attribute__((__format__(__printf__, 4, 5)));
+
+int ul_path_readf_cpulist(struct path_cxt* pc, cpu_set_t** set, int maxcpus,
+                          const char* path, ...)
+    __attribute__((__format__(__printf__, 4, 5)));
+    #endif /* HAVE_CPU_SET_T */
+#endif
 #endif /* UTIL_LINUX_PATH_H */
diff --git a/lib/cpuset.c b/lib/cpuset.c
index 2847db8..cc7421a 100644
--- a/lib/cpuset.c
+++ b/lib/cpuset.c
@@ -1,3 +1,4 @@
+#ifndef __cryptix__
 /*
  * Terminology:
  *
@@ -13,46 +14,40 @@
  * Copyright (C) 2010 Karel Zak <kzak@redhat.com>
  */
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sched.h>
-#include <errno.h>
-#include <string.h>
-#include <ctype.h>
-#include <sys/syscall.h>
+    #include <ctype.h>
+    #include <errno.h>
+    #include <sched.h>
+    #include <stdio.h>
+    #include <stdlib.h>
+    #include <string.h>
+    #include <sys/syscall.h>
+    #include <unistd.h>
 
-#include "cpuset.h"
-#include "c.h"
+    #include "c.h"
+    #include "cpuset.h"
 
 static inline int val_to_char(int v)
 {
-	if (v >= 0 && v < 10)
-		return '0' + v;
-	if (v >= 10 && v < 16)
-		return ('a' - 10) + v;
-	return -1;
+    if (v >= 0 && v < 10) return '0' + v;
+    if (v >= 10 && v < 16) return ('a' - 10) + v;
+    return -1;
 }
 
 static inline int char_to_val(int c)
 {
-	int cl;
-
-	if (c >= '0' && c <= '9')
-		return c - '0';
-	cl = tolower(c);
-	if (cl >= 'a' && cl <= 'f')
-		return cl + (10 - 'a');
-	return -1;
+    int cl;
+
+    if (c >= '0' && c <= '9') return c - '0';
+    cl = tolower(c);
+    if (cl >= 'a' && cl <= 'f') return cl + (10 - 'a');
+    return -1;
 }
 
-static const char *nexttoken(const char *q,  int sep)
+static const char* nexttoken(const char* q, int sep)
 {
-	if (q)
-		q = strchr(q, sep);
-	if (q)
-		q++;
-	return q;
+    if (q) q = strchr(q, sep);
+    if (q) q++;
+    return q;
 }
 
 /*
@@ -60,217 +55,197 @@ static const char *nexttoken(const char *q,  int sep)
  */
 int get_max_number_of_cpus(void)
 {
-#ifdef SYS_sched_getaffinity
-	int n, cpus = 2048;
-	size_t setsize;
-	cpu_set_t *set = cpuset_alloc(cpus, &setsize, NULL);
-
-	if (!set)
-		return -1;	/* error */
-
-	for (;;) {
-		CPU_ZERO_S(setsize, set);
-
-		/* the library version does not return size of cpumask_t */
-		n = syscall(SYS_sched_getaffinity, 0, setsize, set);
-
-		if (n < 0 && errno == EINVAL && cpus < 1024 * 1024) {
-			cpuset_free(set);
-			cpus *= 2;
-			set = cpuset_alloc(cpus, &setsize, NULL);
-			if (!set)
-				return -1;	/* error */
-			continue;
-		}
-		cpuset_free(set);
-		return n * 8;
-	}
-#endif
-	return -1;
+    #ifdef SYS_sched_getaffinity
+    int        n, cpus = 2048;
+    size_t     setsize;
+    cpu_set_t* set = cpuset_alloc(cpus, &setsize, NULL);
+
+    if (!set) return -1; /* error */
+
+    for (;;)
+    {
+        CPU_ZERO_S(setsize, set);
+
+        /* the library version does not return size of cpumask_t */
+        n = syscall(SYS_sched_getaffinity, 0, setsize, set);
+
+        if (n < 0 && errno == EINVAL && cpus < 1024 * 1024)
+        {
+            cpuset_free(set);
+            cpus *= 2;
+            set = cpuset_alloc(cpus, &setsize, NULL);
+            if (!set) return -1; /* error */
+            continue;
+        }
+        cpuset_free(set);
+        return n * 8;
+    }
+    #endif
+    return -1;
 }
 
 /*
  * Allocates a new set for ncpus and returns size in bytes and size in bits
  */
-cpu_set_t *cpuset_alloc(int ncpus, size_t *setsize, size_t *nbits)
+cpu_set_t* cpuset_alloc(int ncpus, size_t* setsize, size_t* nbits)
 {
-	cpu_set_t *set = CPU_ALLOC(ncpus);
-
-	if (!set)
-		return NULL;
-	if (setsize)
-		*setsize = CPU_ALLOC_SIZE(ncpus);
-	if (nbits)
-		*nbits = cpuset_nbits(CPU_ALLOC_SIZE(ncpus));
-	return set;
-}
+    cpu_set_t* set = CPU_ALLOC(ncpus);
 
-void cpuset_free(cpu_set_t *set)
-{
-	CPU_FREE(set);
+    if (!set) return NULL;
+    if (setsize) *setsize = CPU_ALLOC_SIZE(ncpus);
+    if (nbits) *nbits = cpuset_nbits(CPU_ALLOC_SIZE(ncpus));
+    return set;
 }
 
-#if !HAVE_DECL_CPU_ALLOC
+void cpuset_free(cpu_set_t* set) { CPU_FREE(set); }
+
+    #if !HAVE_DECL_CPU_ALLOC
 /* Please, use CPU_COUNT_S() macro. This is fallback */
-int __cpuset_count_s(size_t setsize, const cpu_set_t *set)
+int __cpuset_count_s(size_t setsize, const cpu_set_t* set)
 {
-	int s = 0;
-	const __cpu_mask *p = set->__bits;
-	const __cpu_mask *end = &set->__bits[setsize / sizeof (__cpu_mask)];
-
-	while (p < end) {
-		__cpu_mask l = *p++;
-
-		if (l == 0)
-			continue;
-# if LONG_BIT > 32
-		l = (l & 0x5555555555555555ul) + ((l >> 1) & 0x5555555555555555ul);
-		l = (l & 0x3333333333333333ul) + ((l >> 2) & 0x3333333333333333ul);
-		l = (l & 0x0f0f0f0f0f0f0f0ful) + ((l >> 4) & 0x0f0f0f0f0f0f0f0ful);
-		l = (l & 0x00ff00ff00ff00fful) + ((l >> 8) & 0x00ff00ff00ff00fful);
-		l = (l & 0x0000ffff0000fffful) + ((l >> 16) & 0x0000ffff0000fffful);
-		l = (l & 0x00000000fffffffful) + ((l >> 32) & 0x00000000fffffffful);
-# else
-		l = (l & 0x55555555ul) + ((l >> 1) & 0x55555555ul);
-		l = (l & 0x33333333ul) + ((l >> 2) & 0x33333333ul);
-		l = (l & 0x0f0f0f0ful) + ((l >> 4) & 0x0f0f0f0ful);
-		l = (l & 0x00ff00fful) + ((l >> 8) & 0x00ff00fful);
-		l = (l & 0x0000fffful) + ((l >> 16) & 0x0000fffful);
-# endif
-		s += l;
-	}
-	return s;
+    int               s   = 0;
+    const __cpu_mask* p   = set->__bits;
+    const __cpu_mask* end = &set->__bits[setsize / sizeof(__cpu_mask)];
+
+    while (p < end)
+    {
+        __cpu_mask l = *p++;
+
+        if (l == 0) continue;
+        #if LONG_BIT > 32
+        l = (l & 0x5555555555555555ul) + ((l >> 1) & 0x5555555555555555ul);
+        l = (l & 0x3333333333333333ul) + ((l >> 2) & 0x3333333333333333ul);
+        l = (l & 0x0f0f0f0f0f0f0f0ful) + ((l >> 4) & 0x0f0f0f0f0f0f0f0ful);
+        l = (l & 0x00ff00ff00ff00fful) + ((l >> 8) & 0x00ff00ff00ff00fful);
+        l = (l & 0x0000ffff0000fffful) + ((l >> 16) & 0x0000ffff0000fffful);
+        l = (l & 0x00000000fffffffful) + ((l >> 32) & 0x00000000fffffffful);
+        #else
+        l = (l & 0x55555555ul) + ((l >> 1) & 0x55555555ul);
+        l = (l & 0x33333333ul) + ((l >> 2) & 0x33333333ul);
+        l = (l & 0x0f0f0f0ful) + ((l >> 4) & 0x0f0f0f0ful);
+        l = (l & 0x00ff00fful) + ((l >> 8) & 0x00ff00fful);
+        l = (l & 0x0000fffful) + ((l >> 16) & 0x0000fffful);
+        #endif
+        s += l;
+    }
+    return s;
 }
-#endif
+    #endif
 
 /*
  * Returns human readable representation of the cpuset. The output format is
  * a list of CPUs with ranges (for example, "0,1,3-9").
  */
-char *cpulist_create(char *str, size_t len,
-			cpu_set_t *set, size_t setsize)
+char* cpulist_create(char* str, size_t len, cpu_set_t* set, size_t setsize)
 {
-	size_t i;
-	char *ptr = str;
-	int entry_made = 0;
-	size_t max = cpuset_nbits(setsize);
-
-	for (i = 0; i < max; i++) {
-		if (CPU_ISSET_S(i, setsize, set)) {
-			int rlen;
-			size_t j, run = 0;
-			entry_made = 1;
-			for (j = i + 1; j < max; j++) {
-				if (CPU_ISSET_S(j, setsize, set))
-					run++;
-				else
-					break;
-			}
-			if (!run)
-				rlen = snprintf(ptr, len, "%zu,", i);
-			else if (run == 1) {
-				rlen = snprintf(ptr, len, "%zu,%zu,", i, i + 1);
-				i++;
-			} else {
-				rlen = snprintf(ptr, len, "%zu-%zu,", i, i + run);
-				i += run;
-			}
-			if (rlen < 0 || (size_t) rlen >= len)
-				return NULL;
-			ptr += rlen;
-			len -= rlen;
-		}
-	}
-	ptr -= entry_made;
-	*ptr = '\0';
-
-	return str;
+    size_t i;
+    char*  ptr        = str;
+    int    entry_made = 0;
+    size_t max        = cpuset_nbits(setsize);
+
+    for (i = 0; i < max; i++)
+    {
+        if (CPU_ISSET_S(i, setsize, set))
+        {
+            int    rlen;
+            size_t j, run = 0;
+            entry_made = 1;
+            for (j = i + 1; j < max; j++)
+            {
+                if (CPU_ISSET_S(j, setsize, set)) run++;
+                else break;
+            }
+            if (!run) rlen = snprintf(ptr, len, "%zu,", i);
+            else if (run == 1)
+            {
+                rlen = snprintf(ptr, len, "%zu,%zu,", i, i + 1);
+                i++;
+            }
+            else
+            {
+                rlen = snprintf(ptr, len, "%zu-%zu,", i, i + run);
+                i += run;
+            }
+            if (rlen < 0 || (size_t)rlen >= len) return NULL;
+            ptr += rlen;
+            len -= rlen;
+        }
+    }
+    ptr -= entry_made;
+    *ptr = '\0';
+
+    return str;
 }
 
 /*
  * Returns string with CPU mask.
  */
-char *cpumask_create(char *str, size_t len,
-			cpu_set_t *set, size_t setsize)
+char* cpumask_create(char* str, size_t len, cpu_set_t* set, size_t setsize)
 {
-	char *ptr = str;
-	char *ret = NULL;
-	int cpu;
-
-	for (cpu = cpuset_nbits(setsize) - 4; cpu >= 0; cpu -= 4) {
-		char val = 0;
-
-		if (len == (size_t) (ptr - str))
-			break;
-
-		if (CPU_ISSET_S(cpu, setsize, set))
-			val |= 1;
-		if (CPU_ISSET_S(cpu + 1, setsize, set))
-			val |= 2;
-		if (CPU_ISSET_S(cpu + 2, setsize, set))
-			val |= 4;
-		if (CPU_ISSET_S(cpu + 3, setsize, set))
-			val |= 8;
-
-		if (!ret && val)
-			ret = ptr;
-		*ptr++ = val_to_char(val);
-	}
-	*ptr = '\0';
-	return ret ? ret : ptr - 1;
+    char* ptr = str;
+    char* ret = NULL;
+    int   cpu;
+
+    for (cpu = cpuset_nbits(setsize) - 4; cpu >= 0; cpu -= 4)
+    {
+        char val = 0;
+
+        if (len == (size_t)(ptr - str)) break;
+
+        if (CPU_ISSET_S(cpu, setsize, set)) val |= 1;
+        if (CPU_ISSET_S(cpu + 1, setsize, set)) val |= 2;
+        if (CPU_ISSET_S(cpu + 2, setsize, set)) val |= 4;
+        if (CPU_ISSET_S(cpu + 3, setsize, set)) val |= 8;
+
+        if (!ret && val) ret = ptr;
+        *ptr++ = val_to_char(val);
+    }
+    *ptr = '\0';
+    return ret ? ret : ptr - 1;
 }
 
 /*
  * Parses string with CPUs mask.
  */
-int cpumask_parse(const char *str, cpu_set_t *set, size_t setsize)
+int cpumask_parse(const char* str, cpu_set_t* set, size_t setsize)
 {
-	int len = strlen(str);
-	const char *ptr = str + len - 1;
-	int cpu = 0;
-
-	/* skip 0x, it's all hex anyway */
-	if (len > 1 && !memcmp(str, "0x", 2L))
-		str += 2;
-
-	CPU_ZERO_S(setsize, set);
-
-	while (ptr >= str) {
-		char val;
-
-		/* cpu masks in /sys uses comma as a separator */
-		if (*ptr == ',')
-			ptr--;
-
-		val = char_to_val(*ptr);
-		if (val == (char) -1)
-			return -1;
-		if (val & 1)
-			CPU_SET_S(cpu, setsize, set);
-		if (val & 2)
-			CPU_SET_S(cpu + 1, setsize, set);
-		if (val & 4)
-			CPU_SET_S(cpu + 2, setsize, set);
-		if (val & 8)
-			CPU_SET_S(cpu + 3, setsize, set);
-		ptr--;
-		cpu += 4;
-	}
-
-	return 0;
+    int         len = strlen(str);
+    const char* ptr = str + len - 1;
+    int         cpu = 0;
+
+    /* skip 0x, it's all hex anyway */
+    if (len > 1 && !memcmp(str, "0x", 2L)) str += 2;
+
+    CPU_ZERO_S(setsize, set);
+
+    while (ptr >= str)
+    {
+        char val;
+
+        /* cpu masks in /sys uses comma as a separator */
+        if (*ptr == ',') ptr--;
+
+        val = char_to_val(*ptr);
+        if (val == (char)-1) return -1;
+        if (val & 1) CPU_SET_S(cpu, setsize, set);
+        if (val & 2) CPU_SET_S(cpu + 1, setsize, set);
+        if (val & 4) CPU_SET_S(cpu + 2, setsize, set);
+        if (val & 8) CPU_SET_S(cpu + 3, setsize, set);
+        ptr--;
+        cpu += 4;
+    }
+
+    return 0;
 }
 
-static int nextnumber(const char *str, char **end, unsigned int *result)
+static int nextnumber(const char* str, char** end, unsigned int* result)
 {
-	errno = 0;
-	if (str == NULL || *str == '\0' || !isdigit(*str))
-		return -EINVAL;
-	*result = (unsigned int) strtoul(str, end, 10);
-	if (errno)
-		return -errno;
-	if (str == *end)
-		return -EINVAL;
-	return 0;
+    errno = 0;
+    if (str == NULL || *str == '\0' || !isdigit(*str)) return -EINVAL;
+    *result = (unsigned int)strtoul(str, end, 10);
+    if (errno) return -errno;
+    if (str == *end) return -EINVAL;
+    return 0;
 }
 
 /*
@@ -281,133 +256,118 @@ static int nextnumber(const char *str, char **end, unsigned int *result)
  * into the cpu_set. If fail is not set cpu numbers that do not fit are
  * ignored and 0 is returned instead.
  */
-int cpulist_parse(const char *str, cpu_set_t *set, size_t setsize, int fail)
+int cpulist_parse(const char* str, cpu_set_t* set, size_t setsize, int fail)
 {
-	size_t max = cpuset_nbits(setsize);
-	const char *p, *q;
-	char *end = NULL;
-
-	q = str;
-	CPU_ZERO_S(setsize, set);
-
-	while (p = q, q = nexttoken(q, ','), p) {
-		unsigned int a;	/* beginning of range */
-		unsigned int b;	/* end of range */
-		unsigned int s;	/* stride */
-		const char *c1, *c2;
-
-		if (nextnumber(p, &end, &a) != 0)
-			return 1;
-		b = a;
-		s = 1;
-		p = end;
-
-		c1 = nexttoken(p, '-');
-		c2 = nexttoken(p, ',');
-
-		if (c1 != NULL && (c2 == NULL || c1 < c2)) {
-			if (nextnumber(c1, &end, &b) != 0)
-				return 1;
-
-			c1 = end && *end ? nexttoken(end, ':') : NULL;
-
-			if (c1 != NULL && (c2 == NULL || c1 < c2)) {
-				if (nextnumber(c1, &end, &s) != 0)
-					return 1;
-				if (s == 0)
-					return 1;
-			}
-		}
-
-		if (!(a <= b))
-			return 1;
-		while (a <= b) {
-			if (fail && (a >= max))
-				return 2;
-			CPU_SET_S(a, setsize, set);
-			a += s;
-		}
-	}
-
-	if (end && *end)
-		return 1;
-	return 0;
+    size_t      max = cpuset_nbits(setsize);
+    const char *p, *q;
+    char*       end = NULL;
+
+    q               = str;
+    CPU_ZERO_S(setsize, set);
+
+    while (p = q, q = nexttoken(q, ','), p)
+    {
+        unsigned int a; /* beginning of range */
+        unsigned int b; /* end of range */
+        unsigned int s; /* stride */
+        const char * c1, *c2;
+
+        if (nextnumber(p, &end, &a) != 0) return 1;
+        b  = a;
+        s  = 1;
+        p  = end;
+
+        c1 = nexttoken(p, '-');
+        c2 = nexttoken(p, ',');
+
+        if (c1 != NULL && (c2 == NULL || c1 < c2))
+        {
+            if (nextnumber(c1, &end, &b) != 0) return 1;
+
+            c1 = end && *end ? nexttoken(end, ':') : NULL;
+
+            if (c1 != NULL && (c2 == NULL || c1 < c2))
+            {
+                if (nextnumber(c1, &end, &s) != 0) return 1;
+                if (s == 0) return 1;
+            }
+        }
+
+        if (!(a <= b)) return 1;
+        while (a <= b)
+        {
+            if (fail && (a >= max)) return 2;
+            CPU_SET_S(a, setsize, set);
+            a += s;
+        }
+    }
+
+    if (end && *end) return 1;
+    return 0;
 }
 
-#ifdef TEST_PROGRAM_CPUSET
+    #ifdef TEST_PROGRAM_CPUSET
 
-#include <getopt.h>
+        #include <getopt.h>
 
-int main(int argc, char *argv[])
+int main(int argc, char* argv[])
 {
-	cpu_set_t *set;
-	size_t setsize, buflen, nbits;
-	char *buf, *mask = NULL, *range = NULL;
-	int ncpus = 2048, rc, c;
-
-	static const struct option longopts[] = {
-	    { "ncpus", 1, NULL, 'n' },
-	    { "mask",  1, NULL, 'm' },
-	    { "range", 1, NULL, 'r' },
-	    { NULL,    0, NULL, 0 }
-	};
-
-	while ((c = getopt_long(argc, argv, "n:m:r:", longopts, NULL)) != -1) {
-		switch(c) {
-		case 'n':
-			ncpus = atoi(optarg);
-			break;
-		case 'm':
-			mask = strdup(optarg);
-			break;
-		case 'r':
-			range = strdup(optarg);
-			break;
-		default:
-			goto usage_err;
-		}
-	}
-
-	if (!mask && !range)
-		goto usage_err;
-
-	set = cpuset_alloc(ncpus, &setsize, &nbits);
-	if (!set)
-		err(EXIT_FAILURE, "failed to allocate cpu set");
-
-	/*
-	fprintf(stderr, "ncpus: %d, cpuset bits: %zd, cpuset bytes: %zd\n",
-			ncpus, nbits, setsize);
-	*/
-
-	buflen = 7 * nbits;
-	buf = malloc(buflen);
-	if (!buf)
-		err(EXIT_FAILURE, "failed to allocate cpu set buffer");
-
-	if (mask)
-		rc = cpumask_parse(mask, set, setsize);
-	else
-		rc = cpulist_parse(range, set, setsize, 0);
-
-	if (rc)
-		errx(EXIT_FAILURE, "failed to parse string: %s", mask ? : range);
-
-	printf("%-15s = %15s ", mask ? : range,
-				cpumask_create(buf, buflen, set, setsize));
-	printf("[%s]\n", cpulist_create(buf, buflen, set, setsize));
-
-	free(buf);
-	free(mask);
-	free(range);
-	cpuset_free(set);
-
-	return EXIT_SUCCESS;
+    cpu_set_t*                 set;
+    size_t                     setsize, buflen, nbits;
+    char *                     buf, *mask = NULL, *range = NULL;
+    int                        ncpus      = 2048, rc, c;
+
+    static const struct option longopts[] = {{"ncpus", 1, NULL, 'n'},
+                                             {"mask", 1, NULL, 'm'},
+                                             {"range", 1, NULL, 'r'},
+                                             {NULL, 0, NULL, 0}};
+
+    while ((c = getopt_long(argc, argv, "n:m:r:", longopts, NULL)) != -1)
+    {
+        switch (c)
+        {
+            case 'n': ncpus = atoi(optarg); break;
+            case 'm': mask = strdup(optarg); break;
+            case 'r': range = strdup(optarg); break;
+            default: goto usage_err;
+        }
+    }
+
+    if (!mask && !range) goto usage_err;
+
+    set = cpuset_alloc(ncpus, &setsize, &nbits);
+    if (!set) err(EXIT_FAILURE, "failed to allocate cpu set");
+
+    /*
+    fprintf(stderr, "ncpus: %d, cpuset bits: %zd, cpuset bytes: %zd\n",
+                    ncpus, nbits, setsize);
+    */
+
+    buflen = 7 * nbits;
+    buf    = malloc(buflen);
+    if (!buf) err(EXIT_FAILURE, "failed to allocate cpu set buffer");
+
+    if (mask) rc = cpumask_parse(mask, set, setsize);
+    else rc = cpulist_parse(range, set, setsize, 0);
+
+    if (rc) errx(EXIT_FAILURE, "failed to parse string: %s", mask ?: range);
+
+    printf("%-15s = %15s ", mask ?: range,
+           cpumask_create(buf, buflen, set, setsize));
+    printf("[%s]\n", cpulist_create(buf, buflen, set, setsize));
+
+    free(buf);
+    free(mask);
+    free(range);
+    cpuset_free(set);
+
+    return EXIT_SUCCESS;
 
 usage_err:
-	fprintf(stderr,
-		"usage: %s [--ncpus <num>] --mask <mask> | --range <list>\n",
-		program_invocation_short_name);
-	exit(EXIT_FAILURE);
+    fprintf(stderr,
+            "usage: %s [--ncpus <num>] --mask <mask> | --range <list>\n",
+            program_invocation_short_name);
+    exit(EXIT_FAILURE);
 }
+    #endif
 #endif
diff --git a/lib/path.c b/lib/path.c
index 75fa853..d833f9a 100644
--- a/lib/path.c
+++ b/lib/path.c
@@ -13,18 +13,18 @@
  *
  * Written by Karel Zak <kzak@redhat.com> [February 2018]
  */
+#include <errno.h>
+#include <inttypes.h>
 #include <stdarg.h>
+#include <stdio.h>
 #include <string.h>
 #include <unistd.h>
-#include <stdio.h>
-#include <inttypes.h>
-#include <errno.h>
 
+#include "all-io.h"
 #include "c.h"
+#include "debug.h"
 #include "fileutils.h"
-#include "all-io.h"
 #include "path.h"
-#include "debug.h"
 #include "strutils.h"
 
 /*
@@ -33,1216 +33,1176 @@
 static UL_DEBUG_DEFINE_MASK(ulpath);
 UL_DEBUG_DEFINE_MASKNAMES(ulpath) = UL_DEBUG_EMPTY_MASKNAMES;
 
-#define ULPATH_DEBUG_INIT	(1 << 1)
-#define ULPATH_DEBUG_CXT	(1 << 2)
+#define ULPATH_DEBUG_INIT     (1 << 1)
+#define ULPATH_DEBUG_CXT      (1 << 2)
 
-#define DBG(m, x)       __UL_DBG(ulpath, ULPATH_DEBUG_, m, x)
-#define ON_DBG(m, x)    __UL_DBG_CALL(ulpath, ULPATH_DEBUG_, m, x)
+#define DBG(m, x)             __UL_DBG(ulpath, ULPATH_DEBUG_, m, x)
+#define ON_DBG(m, x)          __UL_DBG_CALL(ulpath, ULPATH_DEBUG_, m, x)
 
-#define UL_DEBUG_CURRENT_MASK	UL_DEBUG_MASK(ulpath)
+#define UL_DEBUG_CURRENT_MASK UL_DEBUG_MASK(ulpath)
 #include "debugobj.h"
 
 void ul_path_init_debug(void)
 {
-	if (ulpath_debug_mask)
-		return;
-	__UL_INIT_DEBUG_FROM_ENV(ulpath, ULPATH_DEBUG_, 0, ULPATH_DEBUG);
+    if (ulpath_debug_mask) return;
+    __UL_INIT_DEBUG_FROM_ENV(ulpath, ULPATH_DEBUG_, 0, ULPATH_DEBUG);
 }
 
-struct path_cxt *ul_new_path(const char *dir, ...)
+struct path_cxt* ul_new_path(const char* dir, ...)
 {
-	struct path_cxt *pc = calloc(1, sizeof(*pc));
+    struct path_cxt* pc = calloc(1, sizeof(*pc));
 
-	if (!pc)
-		return NULL;
+    if (!pc) return NULL;
 
-	DBG(CXT, ul_debugobj(pc, "alloc"));
+    DBG(CXT, ul_debugobj(pc, "alloc"));
 
-	pc->refcount = 1;
-	pc->dir_fd = -1;
+    pc->refcount = 1;
+    pc->dir_fd   = -1;
 
-	if (dir) {
-		int rc;
-		va_list ap;
+    if (dir)
+    {
+        int     rc;
+        va_list ap;
 
-		va_start(ap, dir);
-		rc = vasprintf(&pc->dir_path, dir, ap);
-		va_end(ap);
+        va_start(ap, dir);
+        rc = vasprintf(&pc->dir_path, dir, ap);
+        va_end(ap);
 
-		if (rc < 0 || !pc->dir_path)
-			goto fail;
-	}
-	return pc;
+        if (rc < 0 || !pc->dir_path) goto fail;
+    }
+    return pc;
 fail:
-	ul_unref_path(pc);
-	return NULL;
+    ul_unref_path(pc);
+    return NULL;
 }
 
-void ul_ref_path(struct path_cxt *pc)
+void ul_ref_path(struct path_cxt* pc)
 {
-	if (pc)
-		pc->refcount++;
+    if (pc) pc->refcount++;
 }
 
-void ul_unref_path(struct path_cxt *pc)
+void ul_unref_path(struct path_cxt* pc)
 {
-	if (!pc)
-		return;
+    if (!pc) return;
 
-	pc->refcount--;
+    pc->refcount--;
 
-	if (pc->refcount <= 0) {
-		DBG(CXT, ul_debugobj(pc, "dealloc"));
-		if (pc->dialect)
-			pc->free_dialect(pc);
-		ul_path_close_dirfd(pc);
-		free(pc->dir_path);
-		free(pc->prefix);
-		free(pc);
-	}
+    if (pc->refcount <= 0)
+    {
+        DBG(CXT, ul_debugobj(pc, "dealloc"));
+        if (pc->dialect) pc->free_dialect(pc);
+        ul_path_close_dirfd(pc);
+        free(pc->dir_path);
+        free(pc->prefix);
+        free(pc);
+    }
 }
 
-int ul_path_set_prefix(struct path_cxt *pc, const char *prefix)
+int ul_path_set_prefix(struct path_cxt* pc, const char* prefix)
 {
-	char *p = NULL;
+    char* p = NULL;
 
-	assert(pc->dir_fd < 0);
+    assert(pc->dir_fd < 0);
 
-	if (prefix) {
-		p = strdup(prefix);
-		if (!p)
-			return -ENOMEM;
-	}
+    if (prefix)
+    {
+        p = strdup(prefix);
+        if (!p) return -ENOMEM;
+    }
 
-	free(pc->prefix);
-	pc->prefix = p;
-	DBG(CXT, ul_debugobj(pc, "new prefix: '%s'", p));
-	return 0;
+    free(pc->prefix);
+    pc->prefix = p;
+    DBG(CXT, ul_debugobj(pc, "new prefix: '%s'", p));
+    return 0;
 }
 
-const char *ul_path_get_prefix(struct path_cxt *pc)
+const char* ul_path_get_prefix(struct path_cxt* pc)
 {
-	return pc ? pc->prefix : NULL;
+    return pc ? pc->prefix : NULL;
 }
 
-int ul_path_set_dir(struct path_cxt *pc, const char *dir)
+int ul_path_set_dir(struct path_cxt* pc, const char* dir)
 {
-	char *p = NULL;
+    char* p = NULL;
 
-	if (dir) {
-		p = strdup(dir);
-		if (!p)
-			return -ENOMEM;
-	}
+    if (dir)
+    {
+        p = strdup(dir);
+        if (!p) return -ENOMEM;
+    }
 
-	if (pc->dir_fd >= 0) {
-		close(pc->dir_fd);
-		pc->dir_fd = -1;
-	}
+    if (pc->dir_fd >= 0)
+    {
+        close(pc->dir_fd);
+        pc->dir_fd = -1;
+    }
 
-	free(pc->dir_path);
-	pc->dir_path = p;
-	DBG(CXT, ul_debugobj(pc, "new dir: '%s'", p));
-	return 0;
+    free(pc->dir_path);
+    pc->dir_path = p;
+    DBG(CXT, ul_debugobj(pc, "new dir: '%s'", p));
+    return 0;
 }
 
-const char *ul_path_get_dir(struct path_cxt *pc)
+const char* ul_path_get_dir(struct path_cxt* pc)
 {
-	return pc ? pc->dir_path : NULL;
+    return pc ? pc->dir_path : NULL;
 }
 
-int ul_path_set_dialect(struct path_cxt *pc, void *data, void free_data(struct path_cxt *))
+int ul_path_set_dialect(struct path_cxt* pc, void* data,
+                        void free_data(struct path_cxt*))
 {
-	pc->dialect = data;
-	pc->free_dialect = free_data;
-	DBG(CXT, ul_debugobj(pc, "(re)set dialect"));
-	return 0;
+    pc->dialect      = data;
+    pc->free_dialect = free_data;
+    DBG(CXT, ul_debugobj(pc, "(re)set dialect"));
+    return 0;
 }
 
-void *ul_path_get_dialect(struct path_cxt *pc)
+void* ul_path_get_dialect(struct path_cxt* pc)
 {
-	return pc ? pc->dialect : NULL;
+    return pc ? pc->dialect : NULL;
 }
 
-int ul_path_set_enoent_redirect(struct path_cxt *pc, int (*func)(struct path_cxt *, const char *, int *))
+int ul_path_set_enoent_redirect(struct path_cxt* pc,
+                                int (*func)(struct path_cxt*, const char*,
+                                            int*))
 {
-	pc->redirect_on_enoent = func;
-	return 0;
+    pc->redirect_on_enoent = func;
+    return 0;
 }
 
-static const char *get_absdir(struct path_cxt *pc)
+static const char* get_absdir(struct path_cxt* pc)
 {
-	int rc;
-	const char *dirpath;
+    int         rc;
+    const char* dirpath;
 
-	if (!pc->prefix)
-		return pc->dir_path;
+    if (!pc->prefix) return pc->dir_path;
 
-	dirpath = pc->dir_path;
-	if (!dirpath)
-		return pc->prefix;
-	if (*dirpath == '/')
-		dirpath++;
+    dirpath = pc->dir_path;
+    if (!dirpath) return pc->prefix;
+    if (*dirpath == '/') dirpath++;
 
-	rc = snprintf(pc->path_buffer, sizeof(pc->path_buffer), "%s/%s", pc->prefix, dirpath);
-	if (rc < 0)
-		return NULL;
-	if ((size_t)rc >= sizeof(pc->path_buffer)) {
-		errno = ENAMETOOLONG;
-		return NULL;
-	}
+    rc = snprintf(pc->path_buffer, sizeof(pc->path_buffer), "%s/%s", pc->prefix,
+                  dirpath);
+    if (rc < 0) return NULL;
+    if ((size_t)rc >= sizeof(pc->path_buffer))
+    {
+        errno = ENAMETOOLONG;
+        return NULL;
+    }
 
-	return pc->path_buffer;
+    return pc->path_buffer;
 }
 
-int ul_path_is_accessible(struct path_cxt *pc)
+int ul_path_is_accessible(struct path_cxt* pc)
 {
-	const char *path;
-	assert(pc);
+    const char* path;
+    assert(pc);
 
-	if (pc->dir_fd >= 0)
-		return 1;
+    if (pc->dir_fd >= 0) return 1;
 
-	path = get_absdir(pc);
-	if (!path)
-		return 0;
-	return access(path, F_OK) == 0;
+    path = get_absdir(pc);
+    if (!path) return 0;
+    return access(path, F_OK) == 0;
 }
 
-int ul_path_get_dirfd(struct path_cxt *pc)
+int ul_path_get_dirfd(struct path_cxt* pc)
 {
-	assert(pc);
-	assert(pc->dir_path);
+    assert(pc);
+    assert(pc->dir_path);
 
-	if (pc->dir_fd < 0) {
-		const char *path = get_absdir(pc);
-		if (!path)
-			return -errno;
+    if (pc->dir_fd < 0)
+    {
+        const char* path = get_absdir(pc);
+        if (!path) return -errno;
 
-		DBG(CXT, ul_debugobj(pc, "opening dir: '%s'", path));
-		pc->dir_fd = open(path, O_RDONLY|O_CLOEXEC);
-	}
+        DBG(CXT, ul_debugobj(pc, "opening dir: '%s'", path));
+        pc->dir_fd = open(path, O_RDONLY | O_CLOEXEC);
+    }
 
-	return pc->dir_fd;
+    return pc->dir_fd;
 }
 
 /* Note that next ul_path_get_dirfd() will reopen the directory */
-void ul_path_close_dirfd(struct path_cxt *pc)
+void ul_path_close_dirfd(struct path_cxt* pc)
 {
-	assert(pc);
+    assert(pc);
 
-	if (pc->dir_fd >= 0) {
-		DBG(CXT, ul_debugobj(pc, "closing dir"));
-		close(pc->dir_fd);
-		pc->dir_fd = -1;
-	}
+    if (pc->dir_fd >= 0)
+    {
+        DBG(CXT, ul_debugobj(pc, "closing dir"));
+        close(pc->dir_fd);
+        pc->dir_fd = -1;
+    }
 }
 
-int ul_path_isopen_dirfd(struct path_cxt *pc)
-{
-	return pc && pc->dir_fd >= 0;
-}
+int ul_path_isopen_dirfd(struct path_cxt* pc) { return pc && pc->dir_fd >= 0; }
 
-static const char *ul_path_mkpath(struct path_cxt *pc, const char *path, va_list ap)
+static const char* ul_path_mkpath(struct path_cxt* pc, const char* path,
+                                  va_list ap)
 {
-	int rc;
+    int rc;
 
-	errno = 0;
+    errno = 0;
 
-	rc = vsnprintf(pc->path_buffer, sizeof(pc->path_buffer), path, ap);
-	if (rc < 0) {
-		if (!errno)
-			errno = EINVAL;
-		return NULL;
-	}
+    rc    = vsnprintf(pc->path_buffer, sizeof(pc->path_buffer), path, ap);
+    if (rc < 0)
+    {
+        if (!errno) errno = EINVAL;
+        return NULL;
+    }
 
-	if ((size_t)rc >= sizeof(pc->path_buffer)) {
-		errno = ENAMETOOLONG;
-		return NULL;
-	}
+    if ((size_t)rc >= sizeof(pc->path_buffer))
+    {
+        errno = ENAMETOOLONG;
+        return NULL;
+    }
 
-	return pc->path_buffer;
+    return pc->path_buffer;
 }
 
-char *ul_path_get_abspath(struct path_cxt *pc, char *buf, size_t bufsz, const char *path, ...)
+char* ul_path_get_abspath(struct path_cxt* pc, char* buf, size_t bufsz,
+                          const char* path, ...)
 {
-	if (path) {
-		int rc;
-		va_list ap;
-		const char *tail = NULL, *dirpath = pc->dir_path;
+    if (path)
+    {
+        int         rc;
+        va_list     ap;
+        const char *tail = NULL, *dirpath = pc->dir_path;
 
-		va_start(ap, path);
-		tail = ul_path_mkpath(pc, path, ap);
-		va_end(ap);
+        va_start(ap, path);
+        tail = ul_path_mkpath(pc, path, ap);
+        va_end(ap);
 
-		if (dirpath && *dirpath == '/')
-			dirpath++;
-		if (tail && *tail == '/')
-			tail++;
+        if (dirpath && *dirpath == '/') dirpath++;
+        if (tail && *tail == '/') tail++;
 
-		rc = snprintf(buf, bufsz, "%s/%s/%s",
-				pc->prefix ? pc->prefix : "",
-				dirpath ? dirpath : "",
-				tail ? tail : "");
+        rc = snprintf(buf, bufsz, "%s/%s/%s", pc->prefix ? pc->prefix : "",
+                      dirpath ? dirpath : "", tail ? tail : "");
 
-		if ((size_t)rc >= bufsz) {
-			errno = ENAMETOOLONG;
-			return NULL;
-		}
-	} else {
-		const char *tmp = get_absdir(pc);
+        if ((size_t)rc >= bufsz)
+        {
+            errno = ENAMETOOLONG;
+            return NULL;
+        }
+    }
+    else
+    {
+        const char* tmp = get_absdir(pc);
 
-		if (!tmp)
-			return NULL;
-		xstrncpy(buf, tmp, bufsz);
-	}
+        if (!tmp) return NULL;
+        xstrncpy(buf, tmp, bufsz);
+    }
 
-	return buf;
+    return buf;
 }
 
-
-int ul_path_access(struct path_cxt *pc, int mode, const char *path)
+int ul_path_access(struct path_cxt* pc, int mode, const char* path)
 {
-	int rc;
+    int rc;
 
-	if (!pc) {
-		rc = access(path, mode);
-		DBG(CXT, ul_debug("access '%s' [no context, rc=%d]", path, rc));
-	} else {
-		int dir = ul_path_get_dirfd(pc);
-		if (dir < 0)
-			return dir;
-		if (*path == '/')
-			path++;
+    if (!pc)
+    {
+        rc = access(path, mode);
+        DBG(CXT, ul_debug("access '%s' [no context, rc=%d]", path, rc));
+    }
+    else
+    {
+        int dir = ul_path_get_dirfd(pc);
+        if (dir < 0) return dir;
+        if (*path == '/') path++;
 
-		rc = faccessat(dir, path, mode, 0);
+        rc = faccessat(dir, path, mode, 0);
 
-		if (rc && errno == ENOENT
-		    && pc->redirect_on_enoent
-		    && pc->redirect_on_enoent(pc, path, &dir) == 0)
-			rc = faccessat(dir, path, mode, 0);
+        if (rc && errno == ENOENT && pc->redirect_on_enoent
+            && pc->redirect_on_enoent(pc, path, &dir) == 0)
+            rc = faccessat(dir, path, mode, 0);
 
-		DBG(CXT, ul_debugobj(pc, "access: '%s' [rc=%d]", path, rc));
-	}
-	return rc;
+        DBG(CXT, ul_debugobj(pc, "access: '%s' [rc=%d]", path, rc));
+    }
+    return rc;
 }
 
-int ul_path_accessf(struct path_cxt *pc, int mode, const char *path, ...)
+int ul_path_accessf(struct path_cxt* pc, int mode, const char* path, ...)
 {
-	va_list ap;
-	const char *p;
+    va_list     ap;
+    const char* p;
 
-	va_start(ap, path);
-	p = ul_path_mkpath(pc, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    p = ul_path_mkpath(pc, path, ap);
+    va_end(ap);
 
-	return !p ? -errno : ul_path_access(pc, mode, p);
+    return !p ? -errno : ul_path_access(pc, mode, p);
 }
 
-int ul_path_stat(struct path_cxt *pc, struct stat *sb, const char *path)
+int ul_path_stat(struct path_cxt* pc, struct stat* sb, const char* path)
 {
-	int rc;
+    int rc;
 
-	if (!pc) {
-		rc = stat(path, sb);
-		DBG(CXT, ul_debug("stat '%s' [no context, rc=%d]", path, rc));
-	} else {
-		int dir = ul_path_get_dirfd(pc);
-		if (dir < 0)
-			return dir;
-		if (*path == '/')
-			path++;
+    if (!pc)
+    {
+        rc = stat(path, sb);
+        DBG(CXT, ul_debug("stat '%s' [no context, rc=%d]", path, rc));
+    }
+    else
+    {
+        int dir = ul_path_get_dirfd(pc);
+        if (dir < 0) return dir;
+        if (*path == '/') path++;
 
-		rc = fstatat(dir, path, sb, 0);
+        rc = fstatat(dir, path, sb, 0);
 
-		if (rc && errno == ENOENT
-		    && pc->redirect_on_enoent
-		    && pc->redirect_on_enoent(pc, path, &dir) == 0)
-			rc = fstatat(dir, path, sb, 0);
+        if (rc && errno == ENOENT && pc->redirect_on_enoent
+            && pc->redirect_on_enoent(pc, path, &dir) == 0)
+            rc = fstatat(dir, path, sb, 0);
 
-		DBG(CXT, ul_debugobj(pc, "stat '%s' [rc=%d]", path, rc));
-	}
-	return rc;
+        DBG(CXT, ul_debugobj(pc, "stat '%s' [rc=%d]", path, rc));
+    }
+    return rc;
 }
 
-int ul_path_open(struct path_cxt *pc, int flags, const char *path)
+int ul_path_open(struct path_cxt* pc, int flags, const char* path)
 {
-	int fd;
+    int fd;
 
-	if (!pc) {
-		fd = open(path, flags);
-		DBG(CXT, ul_debug("opening '%s' [no context]", path));
-	} else {
-		int fdx;
-		int dir = ul_path_get_dirfd(pc);
-		if (dir < 0)
-			return dir;
+    if (!pc)
+    {
+        fd = open(path, flags);
+        DBG(CXT, ul_debug("opening '%s' [no context]", path));
+    }
+    else
+    {
+        int fdx;
+        int dir = ul_path_get_dirfd(pc);
+        if (dir < 0) return dir;
 
-		if (*path == '/')
-			path++;
+        if (*path == '/') path++;
 
-		fdx = fd = openat(dir, path, flags);
+        fdx = fd = openat(dir, path, flags);
 
-		if (fd < 0 && errno == ENOENT
-		    && pc->redirect_on_enoent
-		    && pc->redirect_on_enoent(pc, path, &dir) == 0)
-			fd = openat(dir, path, flags);
+        if (fd < 0 && errno == ENOENT && pc->redirect_on_enoent
+            && pc->redirect_on_enoent(pc, path, &dir) == 0)
+            fd = openat(dir, path, flags);
 
-		DBG(CXT, ul_debugobj(pc, "opening '%s'%s", path, fdx != fd ? " [redirected]" : ""));
-	}
-	return fd;
+        DBG(CXT, ul_debugobj(pc, "opening '%s'%s", path,
+                             fdx != fd ? " [redirected]" : ""));
+    }
+    return fd;
 }
 
-int ul_path_vopenf(struct path_cxt *pc, int flags, const char *path, va_list ap)
+int ul_path_vopenf(struct path_cxt* pc, int flags, const char* path, va_list ap)
 {
-	const char *p = ul_path_mkpath(pc, path, ap);
+    const char* p = ul_path_mkpath(pc, path, ap);
 
-	return !p ? -errno : ul_path_open(pc, flags, p);
+    return !p ? -errno : ul_path_open(pc, flags, p);
 }
 
-int ul_path_openf(struct path_cxt *pc, int flags, const char *path, ...)
+int ul_path_openf(struct path_cxt* pc, int flags, const char* path, ...)
 {
-	va_list ap;
-	int rc;
+    va_list ap;
+    int     rc;
 
-	va_start(ap, path);
-	rc = ul_path_vopenf(pc, flags, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    rc = ul_path_vopenf(pc, flags, path, ap);
+    va_end(ap);
 
-	return rc;
+    return rc;
 }
 
 /*
  * Maybe stupid, but good enough ;-)
  */
-static int mode2flags(const char *mode)
-{
-	int flags = 0;
-	const char *p;
-
-	for (p = mode; p && *p; p++) {
-		if (*p == 'r' && *(p + 1) == '+')
-			flags |= O_RDWR;
-		else if (*p == 'r')
-			flags |= O_RDONLY;
-
-		else if (*p == 'w' && *(p + 1) == '+')
-			flags |= O_RDWR | O_TRUNC;
-		else if (*p == 'w')
-			flags |= O_WRONLY | O_TRUNC;
-
-		else if (*p == 'a' && *(p + 1) == '+')
-			flags |= O_RDWR | O_APPEND;
-		else if (*p == 'a')
-			flags |= O_WRONLY | O_APPEND;
+static int mode2flags(const char* mode)
+{
+    int         flags = 0;
+    const char* p;
+
+    for (p = mode; p && *p; p++)
+    {
+        if (*p == 'r' && *(p + 1) == '+') flags |= O_RDWR;
+        else if (*p == 'r') flags |= O_RDONLY;
+
+        else if (*p == 'w' && *(p + 1) == '+') flags |= O_RDWR | O_TRUNC;
+        else if (*p == 'w') flags |= O_WRONLY | O_TRUNC;
+
+        else if (*p == 'a' && *(p + 1) == '+') flags |= O_RDWR | O_APPEND;
+        else if (*p == 'a') flags |= O_WRONLY | O_APPEND;
 #ifdef O_CLOEXEC
-		else if (*p == *UL_CLOEXECSTR)
-			flags |= O_CLOEXEC;
+        else if (*p == *UL_CLOEXECSTR) flags |= O_CLOEXEC;
 #endif
-	}
+    }
 
-	return flags;
+    return flags;
 }
 
-FILE *ul_path_fopen(struct path_cxt *pc, const char *mode, const char *path)
+FILE* ul_path_fopen(struct path_cxt* pc, const char* mode, const char* path)
 {
-	int flags = mode2flags(mode);
-	int fd = ul_path_open(pc, flags, path);
+    int flags = mode2flags(mode);
+    int fd    = ul_path_open(pc, flags, path);
 
-	if (fd < 0)
-		return NULL;
+    if (fd < 0) return NULL;
 
-	return fdopen(fd, mode);
+    return fdopen(fd, mode);
 }
 
-
-FILE *ul_path_vfopenf(struct path_cxt *pc, const char *mode, const char *path, va_list ap)
+FILE* ul_path_vfopenf(struct path_cxt* pc, const char* mode, const char* path,
+                      va_list ap)
 {
-	const char *p = ul_path_mkpath(pc, path, ap);
+    const char* p = ul_path_mkpath(pc, path, ap);
 
-	return !p ? NULL : ul_path_fopen(pc, mode, p);
+    return !p ? NULL : ul_path_fopen(pc, mode, p);
 }
 
-FILE *ul_path_fopenf(struct path_cxt *pc, const char *mode, const char *path, ...)
+FILE* ul_path_fopenf(struct path_cxt* pc, const char* mode, const char* path,
+                     ...)
 {
-	FILE *f;
-	va_list ap;
+    FILE*   f;
+    va_list ap;
 
-	va_start(ap, path);
-	f = ul_path_vfopenf(pc, mode, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    f = ul_path_vfopenf(pc, mode, path, ap);
+    va_end(ap);
 
-	return f;
+    return f;
 }
 
 /*
  * Open directory @path in read-onl mode. If the path is NULL then duplicate FD
  * to the directory addressed by @pc.
  */
-DIR *ul_path_opendir(struct path_cxt *pc, const char *path)
+DIR* ul_path_opendir(struct path_cxt* pc, const char* path)
 {
-	DIR *dir;
-	int fd = -1;
+    DIR* dir;
+    int  fd = -1;
 
-	if (path)
-		fd = ul_path_open(pc, O_RDONLY|O_CLOEXEC, path);
-	else if (pc->dir_path) {
-		int dirfd;
+    if (path) fd = ul_path_open(pc, O_RDONLY | O_CLOEXEC, path);
+    else if (pc->dir_path)
+    {
+        int dirfd;
 
-		DBG(CXT, ul_debugobj(pc, "duplicate dir path"));
-		dirfd = ul_path_get_dirfd(pc);
-		if (dirfd >= 0)
-			fd = dup_fd_cloexec(dirfd, STDERR_FILENO + 1);
-	}
+        DBG(CXT, ul_debugobj(pc, "duplicate dir path"));
+        dirfd = ul_path_get_dirfd(pc);
+        if (dirfd >= 0) fd = dup_fd_cloexec(dirfd, STDERR_FILENO + 1);
+    }
 
-	if (fd < 0)
-		return NULL;
+    if (fd < 0) return NULL;
 
-	dir = fdopendir(fd);
-	if (!dir) {
-		close(fd);
-		return NULL;
-	}
-	if (!path)
-		 rewinddir(dir);
-	return dir;
+    dir = fdopendir(fd);
+    if (!dir)
+    {
+        close(fd);
+        return NULL;
+    }
+    if (!path) rewinddir(dir);
+    return dir;
 }
 
-
 /*
  * Open directory @path in read-onl mode. If the path is NULL then duplicate FD
  * to the directory addressed by @pc.
  */
-DIR *ul_path_vopendirf(struct path_cxt *pc, const char *path, va_list ap)
+DIR* ul_path_vopendirf(struct path_cxt* pc, const char* path, va_list ap)
 {
-	const char *p = ul_path_mkpath(pc, path, ap);
+    const char* p = ul_path_mkpath(pc, path, ap);
 
-	return !p ? NULL : ul_path_opendir(pc, p);
+    return !p ? NULL : ul_path_opendir(pc, p);
 }
 
 /*
  * Open directory @path in read-onl mode. If the path is NULL then duplicate FD
  * to the directory addressed by @pc.
  */
-DIR *ul_path_opendirf(struct path_cxt *pc, const char *path, ...)
+DIR* ul_path_opendirf(struct path_cxt* pc, const char* path, ...)
 {
-	va_list ap;
-	DIR *dir;
+    va_list ap;
+    DIR*    dir;
 
-	va_start(ap, path);
-	dir = ul_path_vopendirf(pc, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    dir = ul_path_vopendirf(pc, path, ap);
+    va_end(ap);
 
-	return dir;
+    return dir;
 }
 
 /*
  * If @path is NULL then readlink is called on @pc directory.
  */
-ssize_t ul_path_readlink(struct path_cxt *pc, char *buf, size_t bufsiz, const char *path)
+ssize_t ul_path_readlink(struct path_cxt* pc, char* buf, size_t bufsiz,
+                         const char* path)
 {
-	int dirfd;
+    int dirfd;
 
-	if (!path) {
-		const char *p = get_absdir(pc);
-		if (!p)
-			return -errno;
-		return readlink(p, buf, bufsiz);
-	}
+    if (!path)
+    {
+        const char* p = get_absdir(pc);
+        if (!p) return -errno;
+        return readlink(p, buf, bufsiz);
+    }
 
-	dirfd = ul_path_get_dirfd(pc);
-	if (dirfd < 0)
-		return dirfd;
+    dirfd = ul_path_get_dirfd(pc);
+    if (dirfd < 0) return dirfd;
 
-	if (*path == '/')
-		path++;
+    if (*path == '/') path++;
 
-	return readlinkat(dirfd, path, buf, bufsiz);
+    return readlinkat(dirfd, path, buf, bufsiz);
 }
 
 /*
  * If @path is NULL then readlink is called on @pc directory.
  */
-ssize_t ul_path_readlinkf(struct path_cxt *pc, char *buf, size_t bufsiz, const char *path, ...)
+ssize_t ul_path_readlinkf(struct path_cxt* pc, char* buf, size_t bufsiz,
+                          const char* path, ...)
 {
-	const char *p;
-	va_list ap;
+    const char* p;
+    va_list     ap;
 
-	va_start(ap, path);
-	p = ul_path_mkpath(pc, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    p = ul_path_mkpath(pc, path, ap);
+    va_end(ap);
 
-	return !p ? -errno : ul_path_readlink(pc, buf, bufsiz, p);
+    return !p ? -errno : ul_path_readlink(pc, buf, bufsiz, p);
 }
 
-int ul_path_read(struct path_cxt *pc, char *buf, size_t len, const char *path)
+int ul_path_read(struct path_cxt* pc, char* buf, size_t len, const char* path)
 {
-	int rc, errsv;
-	int fd;
+    int rc, errsv;
+    int fd;
 
-	fd = ul_path_open(pc, O_RDONLY|O_CLOEXEC, path);
-	if (fd < 0)
-		return -errno;
+    fd = ul_path_open(pc, O_RDONLY | O_CLOEXEC, path);
+    if (fd < 0) return -errno;
 
-	DBG(CXT, ul_debug(" reading '%s'", path));
-	rc = read_all(fd, buf, len);
+    DBG(CXT, ul_debug(" reading '%s'", path));
+    rc    = read_all(fd, buf, len);
 
-	errsv = errno;
-	close(fd);
-	errno = errsv;
-	return rc;
+    errsv = errno;
+    close(fd);
+    errno = errsv;
+    return rc;
 }
 
-int ul_path_vreadf(struct path_cxt *pc, char *buf, size_t len, const char *path, va_list ap)
+int ul_path_vreadf(struct path_cxt* pc, char* buf, size_t len, const char* path,
+                   va_list ap)
 {
-	const char *p = ul_path_mkpath(pc, path, ap);
+    const char* p = ul_path_mkpath(pc, path, ap);
 
-	return !p ? -errno : ul_path_read(pc, buf, len, p);
+    return !p ? -errno : ul_path_read(pc, buf, len, p);
 }
 
-int ul_path_readf(struct path_cxt *pc, char *buf, size_t len, const char *path, ...)
+int ul_path_readf(struct path_cxt* pc, char* buf, size_t len, const char* path,
+                  ...)
 {
-	va_list ap;
-	int rc;
+    va_list ap;
+    int     rc;
 
-	va_start(ap, path);
-	rc = ul_path_vreadf(pc, buf, len, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    rc = ul_path_vreadf(pc, buf, len, path, ap);
+    va_end(ap);
 
-	return rc;
+    return rc;
 }
 
-
 /*
  * Returns newly allocated buffer with data from file. Maximal size is BUFSIZ
  * (send patch if you need something bigger;-)
  *
  * Returns size of the string!
  */
-int ul_path_read_string(struct path_cxt *pc, char **str, const char *path)
+int ul_path_read_string(struct path_cxt* pc, char** str, const char* path)
 {
-	char buf[BUFSIZ];
-	int rc;
+    char buf[BUFSIZ];
+    int  rc;
 
-	if (!str)
-		return -EINVAL;
+    if (!str) return -EINVAL;
 
-	*str = NULL;
-	rc = ul_path_read(pc, buf, sizeof(buf) - 1, path);
-	if (rc < 0)
-		return rc;
+    *str = NULL;
+    rc   = ul_path_read(pc, buf, sizeof(buf) - 1, path);
+    if (rc < 0) return rc;
 
-	/* Remove tailing newline (usual in sysfs) */
-	if (rc > 0 && *(buf + rc - 1) == '\n')
-		--rc;
+    /* Remove tailing newline (usual in sysfs) */
+    if (rc > 0 && *(buf + rc - 1) == '\n') --rc;
 
-	buf[rc] = '\0';
-	*str = strdup(buf);
-	if (!*str)
-		rc = -ENOMEM;
+    buf[rc] = '\0';
+    *str    = strdup(buf);
+    if (!*str) rc = -ENOMEM;
 
-	return rc;
+    return rc;
 }
 
-int ul_path_readf_string(struct path_cxt *pc, char **str, const char *path, ...)
+int ul_path_readf_string(struct path_cxt* pc, char** str, const char* path, ...)
 {
-	const char *p;
-	va_list ap;
+    const char* p;
+    va_list     ap;
 
-	va_start(ap, path);
-	p = ul_path_mkpath(pc, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    p = ul_path_mkpath(pc, path, ap);
+    va_end(ap);
 
-	return !p ? -errno : ul_path_read_string(pc, str, p);
+    return !p ? -errno : ul_path_read_string(pc, str, p);
 }
 
-int ul_path_read_buffer(struct path_cxt *pc, char *buf, size_t bufsz, const char *path)
+int ul_path_read_buffer(struct path_cxt* pc, char* buf, size_t bufsz,
+                        const char* path)
 {
-	int rc = ul_path_read(pc, buf, bufsz - 1, path);
-	if (rc < 0)
-		return rc;
+    int rc = ul_path_read(pc, buf, bufsz - 1, path);
+    if (rc < 0) return rc;
 
-	/* Remove tailing newline (usual in sysfs) */
-	if (rc > 0 && *(buf + rc - 1) == '\n')
-		buf[--rc] = '\0';
-	else
-		buf[rc - 1] = '\0';
+    /* Remove tailing newline (usual in sysfs) */
+    if (rc > 0 && *(buf + rc - 1) == '\n') buf[--rc] = '\0';
+    else buf[rc - 1] = '\0';
 
-	return rc;
+    return rc;
 }
 
-int ul_path_readf_buffer(struct path_cxt *pc, char *buf, size_t bufsz, const char *path, ...)
+int ul_path_readf_buffer(struct path_cxt* pc, char* buf, size_t bufsz,
+                         const char* path, ...)
 {
-	const char *p;
-	va_list ap;
+    const char* p;
+    va_list     ap;
 
-	va_start(ap, path);
-	p = ul_path_mkpath(pc, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    p = ul_path_mkpath(pc, path, ap);
+    va_end(ap);
 
-	return !p ? -errno : ul_path_read_buffer(pc, buf, bufsz, p);
+    return !p ? -errno : ul_path_read_buffer(pc, buf, bufsz, p);
 }
 
-int ul_path_scanf(struct path_cxt *pc, const char *path, const char *fmt, ...)
+int ul_path_scanf(struct path_cxt* pc, const char* path, const char* fmt, ...)
 {
-	FILE *f;
-	va_list fmt_ap;
-	int rc;
+    FILE*   f;
+    va_list fmt_ap;
+    int     rc;
 
-	f = ul_path_fopen(pc, "r" UL_CLOEXECSTR, path);
-	if (!f)
-		return -EINVAL;
+    f = ul_path_fopen(pc, "r" UL_CLOEXECSTR, path);
+    if (!f) return -EINVAL;
 
-	DBG(CXT, ul_debug(" fscanf [%s] '%s'", fmt, path));
+    DBG(CXT, ul_debug(" fscanf [%s] '%s'", fmt, path));
 
-	va_start(fmt_ap, fmt);
-	rc = vfscanf(f, fmt, fmt_ap);
-	va_end(fmt_ap);
+    va_start(fmt_ap, fmt);
+    rc = vfscanf(f, fmt, fmt_ap);
+    va_end(fmt_ap);
 
-	fclose(f);
-	return rc;
+    fclose(f);
+    return rc;
 }
 
-int ul_path_scanff(struct path_cxt *pc, const char *path, va_list ap, const char *fmt, ...)
+int ul_path_scanff(struct path_cxt* pc, const char* path, va_list ap,
+                   const char* fmt, ...)
 {
-	FILE *f;
-	va_list fmt_ap;
-	int rc;
+    FILE*   f;
+    va_list fmt_ap;
+    int     rc;
 
-	f = ul_path_vfopenf(pc, "r" UL_CLOEXECSTR, path, ap);
-	if (!f)
-		return -EINVAL;
+    f = ul_path_vfopenf(pc, "r" UL_CLOEXECSTR, path, ap);
+    if (!f) return -EINVAL;
 
-	va_start(fmt_ap, fmt);
-	rc = vfscanf(f, fmt, fmt_ap);
-	va_end(fmt_ap);
+    va_start(fmt_ap, fmt);
+    rc = vfscanf(f, fmt, fmt_ap);
+    va_end(fmt_ap);
 
-	fclose(f);
-	return rc;
+    fclose(f);
+    return rc;
 }
 
-
-int ul_path_read_s64(struct path_cxt *pc, int64_t *res, const char *path)
+int ul_path_read_s64(struct path_cxt* pc, int64_t* res, const char* path)
 {
-	int64_t x = 0;
-	int rc;
+    int64_t x = 0;
+    int     rc;
 
-	rc = ul_path_scanf(pc, path, "%"SCNd64, &x);
-	if (rc != 1)
-		return -1;
-	if (res)
-		*res = x;
-	return 0;
+    rc = ul_path_scanf(pc, path, "%" SCNd64, &x);
+    if (rc != 1) return -1;
+    if (res) *res = x;
+    return 0;
 }
 
-int ul_path_readf_s64(struct path_cxt *pc, int64_t *res, const char *path, ...)
+int ul_path_readf_s64(struct path_cxt* pc, int64_t* res, const char* path, ...)
 {
-	const char *p;
-	va_list ap;
+    const char* p;
+    va_list     ap;
 
-	va_start(ap, path);
-	p = ul_path_mkpath(pc, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    p = ul_path_mkpath(pc, path, ap);
+    va_end(ap);
 
-	return !p ? -errno : ul_path_read_s64(pc, res, p);
+    return !p ? -errno : ul_path_read_s64(pc, res, p);
 }
 
-int ul_path_read_u64(struct path_cxt *pc, uint64_t *res, const char *path)
+int ul_path_read_u64(struct path_cxt* pc, uint64_t* res, const char* path)
 {
-	uint64_t x = 0;
-	int rc;
+    uint64_t x = 0;
+    int      rc;
 
-	rc = ul_path_scanf(pc, path, "%"SCNu64, &x);
-	if (rc != 1)
-		return -1;
-	if (res)
-		*res = x;
-	return 0;
+    rc = ul_path_scanf(pc, path, "%" SCNu64, &x);
+    if (rc != 1) return -1;
+    if (res) *res = x;
+    return 0;
 }
 
-int ul_path_readf_u64(struct path_cxt *pc, uint64_t *res, const char *path, ...)
+int ul_path_readf_u64(struct path_cxt* pc, uint64_t* res, const char* path, ...)
 {
-	const char *p;
-	va_list ap;
+    const char* p;
+    va_list     ap;
 
-	va_start(ap, path);
-	p = ul_path_mkpath(pc, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    p = ul_path_mkpath(pc, path, ap);
+    va_end(ap);
 
-	return !p ? -errno : ul_path_read_u64(pc, res, p);
+    return !p ? -errno : ul_path_read_u64(pc, res, p);
 }
 
-int ul_path_read_s32(struct path_cxt *pc, int *res, const char *path)
+int ul_path_read_s32(struct path_cxt* pc, int* res, const char* path)
 {
-	int rc, x = 0;
+    int rc, x = 0;
 
-	rc = ul_path_scanf(pc, path, "%d", &x);
-	if (rc != 1)
-		return -1;
-	if (res)
-		*res = x;
-	return 0;
+    rc = ul_path_scanf(pc, path, "%d", &x);
+    if (rc != 1) return -1;
+    if (res) *res = x;
+    return 0;
 }
 
-int ul_path_readf_s32(struct path_cxt *pc, int *res, const char *path, ...)
+int ul_path_readf_s32(struct path_cxt* pc, int* res, const char* path, ...)
 {
-	const char *p;
-	va_list ap;
+    const char* p;
+    va_list     ap;
 
-	va_start(ap, path);
-	p = ul_path_mkpath(pc, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    p = ul_path_mkpath(pc, path, ap);
+    va_end(ap);
 
-	return !p ? -errno : ul_path_read_s32(pc, res, p);
+    return !p ? -errno : ul_path_read_s32(pc, res, p);
 }
 
-int ul_path_read_u32(struct path_cxt *pc, unsigned int *res, const char *path)
+int ul_path_read_u32(struct path_cxt* pc, unsigned int* res, const char* path)
 {
-	int rc;
-	unsigned int x;
+    int          rc;
+    unsigned int x;
 
-	rc = ul_path_scanf(pc, path, "%u", &x);
-	if (rc != 1)
-		return -1;
-	if (res)
-		*res = x;
-	return 0;
+    rc = ul_path_scanf(pc, path, "%u", &x);
+    if (rc != 1) return -1;
+    if (res) *res = x;
+    return 0;
 }
 
-int ul_path_readf_u32(struct path_cxt *pc, unsigned int *res, const char *path, ...)
+int ul_path_readf_u32(struct path_cxt* pc, unsigned int* res, const char* path,
+                      ...)
 {
-	const char *p;
-	va_list ap;
+    const char* p;
+    va_list     ap;
 
-	va_start(ap, path);
-	p = ul_path_mkpath(pc, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    p = ul_path_mkpath(pc, path, ap);
+    va_end(ap);
 
-	return !p ? -errno : ul_path_read_u32(pc, res, p);
+    return !p ? -errno : ul_path_read_u32(pc, res, p);
 }
 
-int ul_path_read_majmin(struct path_cxt *pc, dev_t *res, const char *path)
+int ul_path_read_majmin(struct path_cxt* pc, dev_t* res, const char* path)
 {
-	int rc, maj, min;
+    int rc, maj, min;
 
-	rc = ul_path_scanf(pc, path, "%d:%d", &maj, &min);
-	if (rc != 2)
-		return -1;
-	if (res)
-		*res = makedev(maj, min);
-	return 0;
+    rc = ul_path_scanf(pc, path, "%d:%d", &maj, &min);
+    if (rc != 2) return -1;
+    if (res) *res = makedev(maj, min);
+    return 0;
 }
 
-int ul_path_readf_majmin(struct path_cxt *pc, dev_t *res, const char *path, ...)
+int ul_path_readf_majmin(struct path_cxt* pc, dev_t* res, const char* path, ...)
 {
-	const char *p;
-	va_list ap;
+    const char* p;
+    va_list     ap;
 
-	va_start(ap, path);
-	p = ul_path_mkpath(pc, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    p = ul_path_mkpath(pc, path, ap);
+    va_end(ap);
 
-	return !p ? -errno : ul_path_read_majmin(pc, res, p);
+    return !p ? -errno : ul_path_read_majmin(pc, res, p);
 }
 
-int ul_path_write_string(struct path_cxt *pc, const char *str, const char *path)
+int ul_path_write_string(struct path_cxt* pc, const char* str, const char* path)
 {
-	int rc, errsv;
-	int fd;
+    int rc, errsv;
+    int fd;
 
-	fd = ul_path_open(pc, O_WRONLY|O_CLOEXEC, path);
-	if (fd < 0)
-		return -errno;
+    fd = ul_path_open(pc, O_WRONLY | O_CLOEXEC, path);
+    if (fd < 0) return -errno;
 
-	rc = write_all(fd, str, strlen(str));
+    rc    = write_all(fd, str, strlen(str));
 
-	errsv = errno;
-	close(fd);
-	errno = errsv;
-	return rc;
+    errsv = errno;
+    close(fd);
+    errno = errsv;
+    return rc;
 }
 
-int ul_path_writef_string(struct path_cxt *pc, const char *str, const char *path, ...)
+int ul_path_writef_string(struct path_cxt* pc, const char* str,
+                          const char* path, ...)
 {
-	const char *p;
-	va_list ap;
+    const char* p;
+    va_list     ap;
 
-	va_start(ap, path);
-	p = ul_path_mkpath(pc, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    p = ul_path_mkpath(pc, path, ap);
+    va_end(ap);
 
-	return !p ? -errno : ul_path_write_string(pc, str, p);
+    return !p ? -errno : ul_path_write_string(pc, str, p);
 }
 
-int ul_path_write_s64(struct path_cxt *pc, int64_t num, const char *path)
+int ul_path_write_s64(struct path_cxt* pc, int64_t num, const char* path)
 {
-	char buf[sizeof(stringify_value(LLONG_MAX))];
-	int rc, errsv;
-	int fd, len;
+    char buf[sizeof(stringify_value(LLONG_MAX))];
+    int  rc, errsv;
+    int  fd, len;
 
-	fd = ul_path_open(pc, O_WRONLY|O_CLOEXEC, path);
-	if (fd < 0)
-		return -errno;
+    fd = ul_path_open(pc, O_WRONLY | O_CLOEXEC, path);
+    if (fd < 0) return -errno;
 
-	len = snprintf(buf, sizeof(buf), "%" PRId64, num);
-	if (len < 0 || (size_t) len >= sizeof(buf))
-		rc = len < 0 ? -errno : -E2BIG;
-	else
-		rc = write_all(fd, buf, len);
+    len = snprintf(buf, sizeof(buf), "%" PRId64, num);
+    if (len < 0 || (size_t)len >= sizeof(buf)) rc = len < 0 ? -errno : -E2BIG;
+    else rc = write_all(fd, buf, len);
 
-	errsv = errno;
-	close(fd);
-	errno = errsv;
-	return rc;
+    errsv = errno;
+    close(fd);
+    errno = errsv;
+    return rc;
 }
 
-int ul_path_write_u64(struct path_cxt *pc, uint64_t num, const char *path)
+int ul_path_write_u64(struct path_cxt* pc, uint64_t num, const char* path)
 {
-	char buf[sizeof(stringify_value(ULLONG_MAX))];
-	int rc, errsv;
-	int fd, len;
+    char buf[sizeof(stringify_value(ULLONG_MAX))];
+    int  rc, errsv;
+    int  fd, len;
 
-	fd = ul_path_open(pc, O_WRONLY|O_CLOEXEC, path);
-	if (fd < 0)
-		return -errno;
+    fd = ul_path_open(pc, O_WRONLY | O_CLOEXEC, path);
+    if (fd < 0) return -errno;
 
-	len = snprintf(buf, sizeof(buf), "%" PRIu64, num);
-	if (len < 0 || (size_t) len >= sizeof(buf))
-		rc = len < 0 ? -errno : -E2BIG;
-	else
-		rc = write_all(fd, buf, len);
+    len = snprintf(buf, sizeof(buf), "%" PRIu64, num);
+    if (len < 0 || (size_t)len >= sizeof(buf)) rc = len < 0 ? -errno : -E2BIG;
+    else rc = write_all(fd, buf, len);
 
-	errsv = errno;
-	close(fd);
-	errno = errsv;
-	return rc;
+    errsv = errno;
+    close(fd);
+    errno = errsv;
+    return rc;
 }
 
-int ul_path_writef_u64(struct path_cxt *pc, uint64_t num, const char *path, ...)
+int ul_path_writef_u64(struct path_cxt* pc, uint64_t num, const char* path, ...)
 {
-	const char *p;
-	va_list ap;
+    const char* p;
+    va_list     ap;
 
-	va_start(ap, path);
-	p = ul_path_mkpath(pc, path, ap);
-	va_end(ap);
-
-	return !p ? -errno : ul_path_write_u64(pc, num, p);
+    va_start(ap, path);
+    p = ul_path_mkpath(pc, path, ap);
+    va_end(ap);
 
+    return !p ? -errno : ul_path_write_u64(pc, num, p);
 }
 
-int ul_path_count_dirents(struct path_cxt *pc, const char *path)
+int ul_path_count_dirents(struct path_cxt* pc, const char* path)
 {
-	DIR *dir;
-	int r = 0;
+    DIR* dir;
+    int  r = 0;
 
-	dir = ul_path_opendir(pc, path);
-	if (!dir)
-		return 0;
+    dir    = ul_path_opendir(pc, path);
+    if (!dir) return 0;
 
-	while (xreaddir(dir)) r++;
+    while (xreaddir(dir)) r++;
 
-	closedir(dir);
-	return r;
+    closedir(dir);
+    return r;
 }
 
-int ul_path_countf_dirents(struct path_cxt *pc, const char *path, ...)
+int ul_path_countf_dirents(struct path_cxt* pc, const char* path, ...)
 {
-	const char *p;
-	va_list ap;
+    const char* p;
+    va_list     ap;
 
-	va_start(ap, path);
-	p = ul_path_mkpath(pc, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    p = ul_path_mkpath(pc, path, ap);
+    va_end(ap);
 
-	return !p ? -errno : ul_path_count_dirents(pc, p);
+    return !p ? -errno : ul_path_count_dirents(pc, p);
 }
 
 /*
  * Like fopen() but, @path is always prefixed by @prefix. This function is
  * useful in case when ul_path_* API is overkill.
  */
-FILE *ul_prefix_fopen(const char *prefix, const char *path, const char *mode)
+FILE* ul_prefix_fopen(const char* prefix, const char* path, const char* mode)
 {
-	char buf[PATH_MAX];
+    char buf[PATH_MAX];
 
-	if (!path)
-		return NULL;
-	if (!prefix)
-		return fopen(path, mode);
-	if (*path == '/')
-		path++;
+    if (!path) return NULL;
+    if (!prefix) return fopen(path, mode);
+    if (*path == '/') path++;
 
-	snprintf(buf, sizeof(buf), "%s/%s", prefix, path);
-	return fopen(buf, mode);
+    snprintf(buf, sizeof(buf), "%s/%s", prefix, path);
+    return fopen(buf, mode);
 }
 
-#ifdef HAVE_CPU_SET_T
-static int ul_path_cpuparse(struct path_cxt *pc, cpu_set_t **set, int maxcpus, int islist, const char *path, va_list ap)
+#ifndef __cryptix__
+    #ifdef HAVE_CPU_SET_T
+static int ul_path_cpuparse(struct path_cxt* pc, cpu_set_t** set, int maxcpus,
+                            int islist, const char* path, va_list ap)
 {
-	FILE *f;
-	size_t setsize, len = maxcpus * 7;
-	char buf[len];
-	int rc;
+    FILE*  f;
+    size_t setsize, len = maxcpus * 7;
+    char   buf[len];
+    int    rc;
 
-	*set = NULL;
+    *set = NULL;
 
-	f = ul_path_vfopenf(pc, "r" UL_CLOEXECSTR, path, ap);
-	if (!f)
-		return -errno;
+    f    = ul_path_vfopenf(pc, "r" UL_CLOEXECSTR, path, ap);
+    if (!f) return -errno;
 
-	rc = fgets(buf, len, f) == NULL ? -errno : 0;
-	fclose(f);
+    rc = fgets(buf, len, f) == NULL ? -errno : 0;
+    fclose(f);
 
-	if (rc)
-		return rc;
+    if (rc) return rc;
 
-	len = strlen(buf);
-	if (buf[len - 1] == '\n')
-		buf[len - 1] = '\0';
+    len = strlen(buf);
+    if (buf[len - 1] == '\n') buf[len - 1] = '\0';
 
-	*set = cpuset_alloc(maxcpus, &setsize, NULL);
-	if (!*set)
-		return -ENOMEM;
+    *set = cpuset_alloc(maxcpus, &setsize, NULL);
+    if (!*set) return -ENOMEM;
 
-	if (islist) {
-		if (cpulist_parse(buf, *set, setsize, 0)) {
-			cpuset_free(*set);
-			return -EINVAL;
-		}
-	} else {
-		if (cpumask_parse(buf, *set, setsize)) {
-			cpuset_free(*set);
-			return -EINVAL;
-		}
-	}
-	return 0;
+    if (islist)
+    {
+        if (cpulist_parse(buf, *set, setsize, 0))
+        {
+            cpuset_free(*set);
+            return -EINVAL;
+        }
+    }
+    else
+    {
+        if (cpumask_parse(buf, *set, setsize))
+        {
+            cpuset_free(*set);
+            return -EINVAL;
+        }
+    }
+    return 0;
 }
 
-int ul_path_readf_cpuset(struct path_cxt *pc, cpu_set_t **set, int maxcpus, const char *path, ...)
+int ul_path_readf_cpuset(struct path_cxt* pc, cpu_set_t** set, int maxcpus,
+                         const char* path, ...)
 {
-	va_list ap;
-	int rc = 0;
+    va_list ap;
+    int     rc = 0;
 
-	va_start(ap, path);
-	rc = ul_path_cpuparse(pc, set, maxcpus, 0, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    rc = ul_path_cpuparse(pc, set, maxcpus, 0, path, ap);
+    va_end(ap);
 
-	return rc;
+    return rc;
 }
 
-int ul_path_readf_cpulist(struct path_cxt *pc, cpu_set_t **set, int maxcpus, const char *path, ...)
+int ul_path_readf_cpulist(struct path_cxt* pc, cpu_set_t** set, int maxcpus,
+                          const char* path, ...)
 {
-	va_list ap;
-	int rc = 0;
+    va_list ap;
+    int     rc = 0;
 
-	va_start(ap, path);
-	rc = ul_path_cpuparse(pc, set, maxcpus, 1, path, ap);
-	va_end(ap);
+    va_start(ap, path);
+    rc = ul_path_cpuparse(pc, set, maxcpus, 1, path, ap);
+    va_end(ap);
 
-	return rc;
+    return rc;
 }
 
-#endif /* HAVE_CPU_SET_T */
-
+    #endif /* HAVE_CPU_SET_T */
+#endif
 
 #ifdef TEST_PROGRAM_PATH
-#include <getopt.h>
+    #include <getopt.h>
 
 static void __attribute__((__noreturn__)) usage(void)
 {
-	fprintf(stdout, " %s [options] <dir> <command>\n\n", program_invocation_short_name);
-	fputs(" -p, --prefix <dir>      redirect hardcoded paths to <dir>\n", stdout);
-
-	fputs(" Commands:\n", stdout);
-	fputs(" read-u64 <file>            read uint64_t from file\n", stdout);
-	fputs(" read-s64 <file>            read  int64_t from file\n", stdout);
-	fputs(" read-u32 <file>            read uint32_t from file\n", stdout);
-	fputs(" read-s32 <file>            read  int32_t from file\n", stdout);
-	fputs(" read-string <file>         read string  from file\n", stdout);
-	fputs(" read-majmin <file>         read devno from file\n", stdout);
-	fputs(" read-link <file>           read symlink\n", stdout);
-	fputs(" write-string <file> <str>  write string from file\n", stdout);
-	fputs(" write-u64 <file> <str>     write uint64_t from file\n", stdout);
-
-	exit(EXIT_SUCCESS);
-}
-
-int main(int argc, char *argv[])
-{
-	int c;
-	const char *prefix = NULL, *dir, *file, *command;
-	struct path_cxt *pc = NULL;
-
-	static const struct option longopts[] = {
-		{ "prefix",	1, NULL, 'p' },
-		{ "help",       0, NULL, 'h' },
-		{ NULL, 0, NULL, 0 },
-	};
-
-	while((c = getopt_long(argc, argv, "p:h", longopts, NULL)) != -1) {
-		switch(c) {
-		case 'p':
-			prefix = optarg;
-			break;
-		case 'h':
-			usage();
-			break;
-		default:
-			err(EXIT_FAILURE, "try --help");
-		}
-	}
-
-	if (optind == argc)
-		errx(EXIT_FAILURE, "<dir> not defined");
-	dir = argv[optind++];
-
-	ul_path_init_debug();
-
-	pc = ul_new_path(dir);
-	if (!pc)
-		err(EXIT_FAILURE, "failed to initialize path context");
-	if (prefix)
-		ul_path_set_prefix(pc, prefix);
-
-	if (optind == argc)
-		errx(EXIT_FAILURE, "<command> not defined");
-	command = argv[optind++];
-
-	if (strcmp(command, "read-u32") == 0) {
-		uint32_t res;
-
-		if (optind == argc)
-			errx(EXIT_FAILURE, "<file> not defined");
-		file = argv[optind++];
-
-		if (ul_path_read_u32(pc, &res, file) != 0)
-			err(EXIT_FAILURE, "read u64 failed");
-		printf("read:  %s: %u\n", file, res);
-
-		if (ul_path_readf_u32(pc, &res, "%s", file) != 0)
-			err(EXIT_FAILURE, "readf u64 failed");
-		printf("readf: %s: %u\n", file, res);
-
-	} else if (strcmp(command, "read-s32") == 0) {
-		int32_t res;
-
-		if (optind == argc)
-			errx(EXIT_FAILURE, "<file> not defined");
-		file = argv[optind++];
-
-		if (ul_path_read_s32(pc, &res, file) != 0)
-			err(EXIT_FAILURE, "read u64 failed");
-		printf("read:  %s: %d\n", file, res);
-
-		if (ul_path_readf_s32(pc, &res, "%s", file) != 0)
-			err(EXIT_FAILURE, "readf u64 failed");
-		printf("readf: %s: %d\n", file, res);
-
-	} else if (strcmp(command, "read-u64") == 0) {
-		uint64_t res;
-
-		if (optind == argc)
-			errx(EXIT_FAILURE, "<file> not defined");
-		file = argv[optind++];
-
-		if (ul_path_read_u64(pc, &res, file) != 0)
-			err(EXIT_FAILURE, "read u64 failed");
-		printf("read:  %s: %" PRIu64 "\n", file, res);
-
-		if (ul_path_readf_u64(pc, &res, "%s", file) != 0)
-			err(EXIT_FAILURE, "readf u64 failed");
-		printf("readf: %s: %" PRIu64 "\n", file, res);
-
-	} else if (strcmp(command, "read-s64") == 0) {
-		int64_t res;
-
-		if (optind == argc)
-			errx(EXIT_FAILURE, "<file> not defined");
-		file = argv[optind++];
-
-		if (ul_path_read_s64(pc, &res, file) != 0)
-			err(EXIT_FAILURE, "read u64 failed");
-		printf("read:  %s: %" PRIu64 "\n", file, res);
-
-		if (ul_path_readf_s64(pc, &res, "%s", file) != 0)
-			err(EXIT_FAILURE, "readf u64 failed");
-		printf("readf: %s: %" PRIu64 "\n", file, res);
-
-	} else if (strcmp(command, "read-majmin") == 0) {
-		dev_t res;
-
-		if (optind == argc)
-			errx(EXIT_FAILURE, "<file> not defined");
-		file = argv[optind++];
-
-		if (ul_path_read_majmin(pc, &res, file) != 0)
-			err(EXIT_FAILURE, "read maj:min failed");
-		printf("read:  %s: %d\n", file, (int) res);
-
-		if (ul_path_readf_majmin(pc, &res, "%s", file) != 0)
-			err(EXIT_FAILURE, "readf maj:min failed");
-		printf("readf: %s: %d\n", file, (int) res);
-
-	} else if (strcmp(command, "read-string") == 0) {
-		char *res;
-
-		if (optind == argc)
-			errx(EXIT_FAILURE, "<file> not defined");
-		file = argv[optind++];
-
-		if (ul_path_read_string(pc, &res, file) < 0)
-			err(EXIT_FAILURE, "read string failed");
-		printf("read:  %s: %s\n", file, res);
-
-		if (ul_path_readf_string(pc, &res, "%s", file) < 0)
-			err(EXIT_FAILURE, "readf string failed");
-		printf("readf: %s: %s\n", file, res);
-
-	} else if (strcmp(command, "read-link") == 0) {
-		char res[PATH_MAX];
-
-		if (optind == argc)
-			errx(EXIT_FAILURE, "<file> not defined");
-		file = argv[optind++];
-
-		if (ul_path_readlink(pc, res, sizeof(res), file) < 0)
-			err(EXIT_FAILURE, "read symlink failed");
-		printf("read:  %s: %s\n", file, res);
-
-		if (ul_path_readlinkf(pc, res, sizeof(res), "%s", file) < 0)
-			err(EXIT_FAILURE, "readf symlink failed");
-		printf("readf: %s: %s\n", file, res);
-
-	} else if (strcmp(command, "write-string") == 0) {
-		char *str;
-
-		if (optind + 1 == argc)
-			errx(EXIT_FAILURE, "<file> <string> not defined");
-		file = argv[optind++];
-		str = argv[optind++];
-
-		if (ul_path_write_string(pc, str, file) != 0)
-			err(EXIT_FAILURE, "write string failed");
-		if (ul_path_writef_string(pc, str, "%s", file) != 0)
-			err(EXIT_FAILURE, "writef string failed");
-
-	} else if (strcmp(command, "write-u64") == 0) {
-		uint64_t num;
-
-		if (optind + 1 == argc)
-			errx(EXIT_FAILURE, "<file> <num> not defined");
-		file = argv[optind++];
-		num = strtoumax(argv[optind++], NULL, 0);
-
-		if (ul_path_write_u64(pc, num, file) != 0)
-			err(EXIT_FAILURE, "write u64 failed");
-		if (ul_path_writef_u64(pc, num, "%s", file) != 0)
-			err(EXIT_FAILURE, "writef u64 failed");
-	}
-
-	ul_unref_path(pc);
-	return EXIT_SUCCESS;
+    fprintf(stdout, " %s [options] <dir> <command>\n\n",
+            program_invocation_short_name);
+    fputs(" -p, --prefix <dir>      redirect hardcoded paths to <dir>\n",
+          stdout);
+
+    fputs(" Commands:\n", stdout);
+    fputs(" read-u64 <file>            read uint64_t from file\n", stdout);
+    fputs(" read-s64 <file>            read  int64_t from file\n", stdout);
+    fputs(" read-u32 <file>            read uint32_t from file\n", stdout);
+    fputs(" read-s32 <file>            read  int32_t from file\n", stdout);
+    fputs(" read-string <file>         read string  from file\n", stdout);
+    fputs(" read-majmin <file>         read devno from file\n", stdout);
+    fputs(" read-link <file>           read symlink\n", stdout);
+    fputs(" write-string <file> <str>  write string from file\n", stdout);
+    fputs(" write-u64 <file> <str>     write uint64_t from file\n", stdout);
+
+    exit(EXIT_SUCCESS);
+}
+
+int main(int argc, char* argv[])
+{
+    int                        c;
+    const char *               prefix     = NULL, *dir, *file, *command;
+    struct path_cxt*           pc         = NULL;
+
+    static const struct option longopts[] = {
+        {"prefix", 1, NULL, 'p'},
+        {"help", 0, NULL, 'h'},
+        {NULL, 0, NULL, 0},
+    };
+
+    while ((c = getopt_long(argc, argv, "p:h", longopts, NULL)) != -1)
+    {
+        switch (c)
+        {
+            case 'p': prefix = optarg; break;
+            case 'h': usage(); break;
+            default: err(EXIT_FAILURE, "try --help");
+        }
+    }
+
+    if (optind == argc) errx(EXIT_FAILURE, "<dir> not defined");
+    dir = argv[optind++];
+
+    ul_path_init_debug();
+
+    pc = ul_new_path(dir);
+    if (!pc) err(EXIT_FAILURE, "failed to initialize path context");
+    if (prefix) ul_path_set_prefix(pc, prefix);
+
+    if (optind == argc) errx(EXIT_FAILURE, "<command> not defined");
+    command = argv[optind++];
+
+    if (strcmp(command, "read-u32") == 0)
+    {
+        uint32_t res;
+
+        if (optind == argc) errx(EXIT_FAILURE, "<file> not defined");
+        file = argv[optind++];
+
+        if (ul_path_read_u32(pc, &res, file) != 0)
+            err(EXIT_FAILURE, "read u64 failed");
+        printf("read:  %s: %u\n", file, res);
+
+        if (ul_path_readf_u32(pc, &res, "%s", file) != 0)
+            err(EXIT_FAILURE, "readf u64 failed");
+        printf("readf: %s: %u\n", file, res);
+    }
+    else if (strcmp(command, "read-s32") == 0)
+    {
+        int32_t res;
+
+        if (optind == argc) errx(EXIT_FAILURE, "<file> not defined");
+        file = argv[optind++];
+
+        if (ul_path_read_s32(pc, &res, file) != 0)
+            err(EXIT_FAILURE, "read u64 failed");
+        printf("read:  %s: %d\n", file, res);
+
+        if (ul_path_readf_s32(pc, &res, "%s", file) != 0)
+            err(EXIT_FAILURE, "readf u64 failed");
+        printf("readf: %s: %d\n", file, res);
+    }
+    else if (strcmp(command, "read-u64") == 0)
+    {
+        uint64_t res;
+
+        if (optind == argc) errx(EXIT_FAILURE, "<file> not defined");
+        file = argv[optind++];
+
+        if (ul_path_read_u64(pc, &res, file) != 0)
+            err(EXIT_FAILURE, "read u64 failed");
+        printf("read:  %s: %" PRIu64 "\n", file, res);
+
+        if (ul_path_readf_u64(pc, &res, "%s", file) != 0)
+            err(EXIT_FAILURE, "readf u64 failed");
+        printf("readf: %s: %" PRIu64 "\n", file, res);
+    }
+    else if (strcmp(command, "read-s64") == 0)
+    {
+        int64_t res;
+
+        if (optind == argc) errx(EXIT_FAILURE, "<file> not defined");
+        file = argv[optind++];
+
+        if (ul_path_read_s64(pc, &res, file) != 0)
+            err(EXIT_FAILURE, "read u64 failed");
+        printf("read:  %s: %" PRIu64 "\n", file, res);
+
+        if (ul_path_readf_s64(pc, &res, "%s", file) != 0)
+            err(EXIT_FAILURE, "readf u64 failed");
+        printf("readf: %s: %" PRIu64 "\n", file, res);
+    }
+    else if (strcmp(command, "read-majmin") == 0)
+    {
+        dev_t res;
+
+        if (optind == argc) errx(EXIT_FAILURE, "<file> not defined");
+        file = argv[optind++];
+
+        if (ul_path_read_majmin(pc, &res, file) != 0)
+            err(EXIT_FAILURE, "read maj:min failed");
+        printf("read:  %s: %d\n", file, (int)res);
+
+        if (ul_path_readf_majmin(pc, &res, "%s", file) != 0)
+            err(EXIT_FAILURE, "readf maj:min failed");
+        printf("readf: %s: %d\n", file, (int)res);
+    }
+    else if (strcmp(command, "read-string") == 0)
+    {
+        char* res;
+
+        if (optind == argc) errx(EXIT_FAILURE, "<file> not defined");
+        file = argv[optind++];
+
+        if (ul_path_read_string(pc, &res, file) < 0)
+            err(EXIT_FAILURE, "read string failed");
+        printf("read:  %s: %s\n", file, res);
+
+        if (ul_path_readf_string(pc, &res, "%s", file) < 0)
+            err(EXIT_FAILURE, "readf string failed");
+        printf("readf: %s: %s\n", file, res);
+    }
+    else if (strcmp(command, "read-link") == 0)
+    {
+        char res[PATH_MAX];
+
+        if (optind == argc) errx(EXIT_FAILURE, "<file> not defined");
+        file = argv[optind++];
+
+        if (ul_path_readlink(pc, res, sizeof(res), file) < 0)
+            err(EXIT_FAILURE, "read symlink failed");
+        printf("read:  %s: %s\n", file, res);
+
+        if (ul_path_readlinkf(pc, res, sizeof(res), "%s", file) < 0)
+            err(EXIT_FAILURE, "readf symlink failed");
+        printf("readf: %s: %s\n", file, res);
+    }
+    else if (strcmp(command, "write-string") == 0)
+    {
+        char* str;
+
+        if (optind + 1 == argc)
+            errx(EXIT_FAILURE, "<file> <string> not defined");
+        file = argv[optind++];
+        str  = argv[optind++];
+
+        if (ul_path_write_string(pc, str, file) != 0)
+            err(EXIT_FAILURE, "write string failed");
+        if (ul_path_writef_string(pc, str, "%s", file) != 0)
+            err(EXIT_FAILURE, "writef string failed");
+    }
+    else if (strcmp(command, "write-u64") == 0)
+    {
+        uint64_t num;
+
+        if (optind + 1 == argc) errx(EXIT_FAILURE, "<file> <num> not defined");
+        file = argv[optind++];
+        num  = strtoumax(argv[optind++], NULL, 0);
+
+        if (ul_path_write_u64(pc, num, file) != 0)
+            err(EXIT_FAILURE, "write u64 failed");
+        if (ul_path_writef_u64(pc, num, "%s", file) != 0)
+            err(EXIT_FAILURE, "writef u64 failed");
+    }
+
+    ul_unref_path(pc);
+    return EXIT_SUCCESS;
 }
 #endif /* TEST_PROGRAM_PATH */
-
diff --git a/libblkid/src/topology/ioctl.c b/libblkid/src/topology/ioctl.c
index 3aba09e..320a14b 100644
--- a/libblkid/src/topology/ioctl.c
+++ b/libblkid/src/topology/ioctl.c
@@ -7,68 +7,63 @@
  * GNU Lesser General Public License.
  *
  */
+#include <errno.h>
+#include <stdint.h>
 #include <stdio.h>
-#include <string.h>
 #include <stdlib.h>
-#include <stdint.h>
-#include <sys/types.h>
+#include <string.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 #include <unistd.h>
-#include <errno.h>
+
+#include <linux/fs.h>
 
 #include "topology.h"
 
 /*
  * ioctl topology values
  */
-static struct topology_val {
+static struct topology_val
+{
 
-	long  ioc;
+    long ioc;
 
-	/* functions to set probing result */
-	int (*set_ulong)(blkid_probe, unsigned long);
-	int (*set_int)(blkid_probe, int);
+    /* functions to set probing result */
+    int (*set_ulong)(blkid_probe, unsigned long);
+    int (*set_int)(blkid_probe, int);
 
 } topology_vals[] = {
-	{ BLKALIGNOFF, NULL, blkid_topology_set_alignment_offset },
-	{ BLKIOMIN, blkid_topology_set_minimum_io_size },
-	{ BLKIOOPT, blkid_topology_set_optimal_io_size },
-	{ BLKPBSZGET, blkid_topology_set_physical_sector_size }
-	/* we read BLKSSZGET in topology.c */
+    {BLKALIGNOFF, NULL, blkid_topology_set_alignment_offset},
+    {BLKIOMIN, blkid_topology_set_minimum_io_size},
+    {BLKIOOPT, blkid_topology_set_optimal_io_size},
+    {BLKPBSZGET, blkid_topology_set_physical_sector_size}
+    /* we read BLKSSZGET in topology.c */
 };
 
-static int probe_ioctl_tp(blkid_probe pr,
-		const struct blkid_idmag *mag __attribute__((__unused__)))
+static int probe_ioctl_tp(blkid_probe pr, const struct blkid_idmag* mag
+                          __attribute__((__unused__)))
 {
-	size_t i;
+    size_t i;
 
-	for (i = 0; i < ARRAY_SIZE(topology_vals); i++) {
-		struct topology_val *val = &topology_vals[i];
-		int rc = 1;
-		unsigned int data;
+    for (i = 0; i < ARRAY_SIZE(topology_vals); i++)
+    {
+        struct topology_val* val = &topology_vals[i];
+        int                  rc  = 1;
+        unsigned int         data;
 
-		if (ioctl(pr->fd, val->ioc, &data) == -1)
-			goto nothing;
+        if (ioctl(pr->fd, val->ioc, &data) == -1) goto nothing;
 
-		if (val->set_int)
-			rc = val->set_int(pr, (int) data);
-		else
-			rc = val->set_ulong(pr, (unsigned long) data);
-		if (rc)
-			goto err;
-	}
+        if (val->set_int) rc = val->set_int(pr, (int)data);
+        else rc = val->set_ulong(pr, (unsigned long)data);
+        if (rc) goto err;
+    }
 
-	return 0;
+    return 0;
 nothing:
-	return 1;
+    return 1;
 err:
-	return -1;
+    return -1;
 }
 
-const struct blkid_idinfo ioctl_tp_idinfo =
-{
-	.name		= "ioctl",
-	.probefunc	= probe_ioctl_tp,
-	.magics		= BLKID_NONE_MAGIC
-};
-
+const struct blkid_idinfo ioctl_tp_idinfo = {
+    .name = "ioctl", .probefunc = probe_ioctl_tp, .magics = BLKID_NONE_MAGIC};
diff --git a/login-utils/logindefs.c b/login-utils/logindefs.c
index 97150dc..1e5e69c 100644
--- a/login-utils/logindefs.c
+++ b/login-utils/logindefs.c
@@ -23,13 +23,13 @@
 #include <ctype.h>
 #include <errno.h>
 #include <limits.h>
+#include <pwd.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/syslog.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#include <pwd.h>
+#include <syslog.h>
 
 #include "c.h"
 #include "closestream.h"
@@ -38,184 +38,170 @@
 #include "pathnames.h"
 #include "xalloc.h"
 
+static void (*logindefs_loader)(void*) = NULL;
+static void* logindefs_loader_data     = NULL;
 
-static void (*logindefs_loader)(void *) = NULL;
-static void *logindefs_loader_data = NULL;
-
-void logindefs_set_loader(void (*loader)(void *data), void *data)
+void         logindefs_set_loader(void (*loader)(void* data), void* data)
 {
-	logindefs_loader = loader;
-	logindefs_loader_data = data;
+    logindefs_loader      = loader;
+    logindefs_loader_data = data;
 }
 
 #ifndef HAVE_LIBECONF
 
-struct item {
-	char *name;		/* name of the option.  */
-	char *value;		/* value of the option.  */
-	char *path;		/* name of config file for this option.  */
+struct item
+{
+    char*        name;  /* name of the option.  */
+    char*        value; /* value of the option.  */
+    char*        path;  /* name of config file for this option.  */
 
-	struct item *next;	/* pointer to next option.  */
+    struct item* next; /* pointer to next option.  */
 };
 
-static struct item *list = NULL;
+static struct item* list = NULL;
 
-void free_getlogindefs_data(void)
+void                free_getlogindefs_data(void)
 {
-	struct item *ptr;
+    struct item* ptr;
 
-	ptr = list;
-	while (ptr) {
-		struct item *tmp = ptr->next;
+    ptr = list;
+    while (ptr)
+    {
+        struct item* tmp = ptr->next;
 
-		free(ptr->path);
-		free(ptr->name);
-		free(ptr->value);
-		free(ptr);
-		ptr = tmp;
-	}
+        free(ptr->path);
+        free(ptr->name);
+        free(ptr->value);
+        free(ptr);
+        ptr = tmp;
+    }
 
-	list = NULL;
+    list = NULL;
 }
 
-static void store(const char *name, const char *value, const char *path)
+static void store(const char* name, const char* value, const char* path)
 {
-	struct item *new = xmalloc(sizeof(struct item));
+    struct item* new = xmalloc(sizeof(struct item));
 
-	if (!name)
-		abort();
+    if (!name) abort();
 
-	new->name = xstrdup(name);
-	new->value = value && *value ? xstrdup(value) : NULL;
-	new->path = xstrdup(path);
-	new->next = list;
-	list = new;
+    new->name  = xstrdup(name);
+    new->value = value && *value ? xstrdup(value) : NULL;
+    new->path  = xstrdup(path);
+    new->next  = list;
+    list       = new;
 }
 
-void logindefs_load_file(const char *filename)
+void logindefs_load_file(const char* filename)
 {
-	FILE *f;
-	char buf[BUFSIZ];
-
-	f = fopen(filename, "r");
-	if (!f)
-		return;
-
-	while (fgets(buf, sizeof(buf), f)) {
-
-		char *p, *name, *data = NULL;
-
-		if (*buf == '#' || *buf == '\n')
-			continue;	/* only comment or empty line */
-
-		p = strchr(buf, '#');
-		if (p)
-			*p = '\0';
-		else {
-			size_t n = strlen(buf);
-			if (n && *(buf + n - 1) == '\n')
-				*(buf + n - 1) = '\0';
-		}
-
-		if (!*buf)
-			continue;	/* empty line */
-
-		/* ignore space at begin of the line */
-		name = buf;
-		while (*name && isspace((unsigned)*name))
-			name++;
-
-		/* go to the end of the name */
-		data = name;
-		while (*data && !(isspace((unsigned)*data) || *data == '='))
-			data++;
-		if (data > name && *data)
-			*data++ = '\0';
-
-		if (!*name || data == name)
-			continue;
-
-		/* go to the begin of the value */
-		while (*data
-		       && (isspace((unsigned)*data) || *data == '='
-			   || *data == '"'))
-			data++;
-
-		/* remove space at the end of the value */
-		p = data + strlen(data);
-		if (p > data)
-			p--;
-		while (p > data && (isspace((unsigned)*p) || *p == '"'))
-			*p-- = '\0';
-
-		store(name, data, filename);
-	}
-
-	fclose(f);
+    FILE* f;
+    char  buf[BUFSIZ];
+
+    f = fopen(filename, "r");
+    if (!f) return;
+
+    while (fgets(buf, sizeof(buf), f))
+    {
+
+        char *p, *name, *data = NULL;
+
+        if (*buf == '#' || *buf == '\n')
+            continue; /* only comment or empty line */
+
+        p = strchr(buf, '#');
+        if (p) *p = '\0';
+        else
+        {
+            size_t n = strlen(buf);
+            if (n && *(buf + n - 1) == '\n') *(buf + n - 1) = '\0';
+        }
+
+        if (!*buf) continue; /* empty line */
+
+        /* ignore space at begin of the line */
+        name = buf;
+        while (*name && isspace((unsigned)*name)) name++;
+
+        /* go to the end of the name */
+        data = name;
+        while (*data && !(isspace((unsigned)*data) || *data == '=')) data++;
+        if (data > name && *data) *data++ = '\0';
+
+        if (!*name || data == name) continue;
+
+        /* go to the begin of the value */
+        while (*data
+               && (isspace((unsigned)*data) || *data == '=' || *data == '"'))
+            data++;
+
+        /* remove space at the end of the value */
+        p = data + strlen(data);
+        if (p > data) p--;
+        while (p > data && (isspace((unsigned)*p) || *p == '"')) *p-- = '\0';
+
+        store(name, data, filename);
+    }
+
+    fclose(f);
 }
 
 static void load_defaults(void)
 {
-	if (logindefs_loader)
-		logindefs_loader(logindefs_loader_data);
-	else
-		logindefs_load_file(_PATH_LOGINDEFS);
+    if (logindefs_loader) logindefs_loader(logindefs_loader_data);
+    else logindefs_load_file(_PATH_LOGINDEFS);
 }
 
-static struct item *search(const char *name)
+static struct item* search(const char* name)
 {
-	struct item *ptr;
+    struct item* ptr;
 
-	if (!list)
-		load_defaults();
+    if (!list) load_defaults();
 
-	ptr = list;
-	while (ptr != NULL) {
-		if (strcasecmp(name, ptr->name) == 0)
-			return ptr;
-		ptr = ptr->next;
-	}
+    ptr = list;
+    while (ptr != NULL)
+    {
+        if (strcasecmp(name, ptr->name) == 0) return ptr;
+        ptr = ptr->next;
+    }
 
-	return NULL;
+    return NULL;
 }
 
-static const char *search_config(const char *name)
+static const char* search_config(const char* name)
 {
-	struct item *ptr;
+    struct item* ptr;
 
-	ptr = list;
-	while (ptr != NULL) {
-		if (strcasecmp(name, ptr->name) == 0)
-			return ptr->path;
-		ptr = ptr->next;
-	}
+    ptr = list;
+    while (ptr != NULL)
+    {
+        if (strcasecmp(name, ptr->name) == 0) return ptr->path;
+        ptr = ptr->next;
+    }
 
-	return NULL;
+    return NULL;
 }
 
-int getlogindefs_bool(const char *name, int dflt)
+int getlogindefs_bool(const char* name, int dflt)
 {
-	struct item *ptr = search(name);
-	return ptr && ptr->value ? (strcasecmp(ptr->value, "yes") == 0) : dflt;
+    struct item* ptr = search(name);
+    return ptr && ptr->value ? (strcasecmp(ptr->value, "yes") == 0) : dflt;
 }
 
-unsigned long getlogindefs_num(const char *name, unsigned long dflt)
+unsigned long getlogindefs_num(const char* name, unsigned long dflt)
 {
-	struct item *ptr = search(name);
-	char *end = NULL;
-	unsigned long retval;
+    struct item*  ptr = search(name);
+    char*         end = NULL;
+    unsigned long retval;
 
-	if (!ptr || !ptr->value)
-		return dflt;
+    if (!ptr || !ptr->value) return dflt;
 
-	errno = 0;
-	retval = strtoul(ptr->value, &end, 0);
-	if (end && *end == '\0' && !errno)
-		return retval;
+    errno  = 0;
+    retval = strtoul(ptr->value, &end, 0);
+    if (end && *end == '\0' && !errno) return retval;
 
-	syslog(LOG_NOTICE, _("%s: %s contains invalid numerical value: %s"),
-	       search_config(name), name, ptr->value);
-	return dflt;
+    syslog(LOG_NOTICE, _("%s: %s contains invalid numerical value: %s"),
+           search_config(name), name, ptr->value);
+    return dflt;
 }
 
 /*
@@ -224,137 +210,134 @@ unsigned long getlogindefs_num(const char *name, unsigned long dflt)
  *	""		(empty string) if found, but value not defined
  *	"string"	if found
  */
-const char *getlogindefs_str(const char *name, const char *dflt)
+const char* getlogindefs_str(const char* name, const char* dflt)
 {
-	struct item *ptr = search(name);
+    struct item* ptr = search(name);
 
-	if (!ptr)
-		return dflt;
-	if (!ptr->value)
-		return "";
-	return ptr->value;
+    if (!ptr) return dflt;
+    if (!ptr->value) return "";
+    return ptr->value;
 }
 
 #else /* !HAVE_LIBECONF */
 
-#include <libeconf.h>
+    #include <libeconf.h>
 
-static econf_file *file = NULL;
+static econf_file* file = NULL;
 
-void free_getlogindefs_data(void)
+void               free_getlogindefs_data(void)
 {
-	econf_free (file);
-	file = NULL;
+    econf_free(file);
+    file = NULL;
 }
 
 static void load_defaults(void)
 {
-	econf_err error;
+    econf_err error;
 
-	if (file != NULL)
-	        free_getlogindefs_data();
+    if (file != NULL) free_getlogindefs_data();
 
-	error = econf_readDirs(&file,
-#if USE_VENDORDIR
-			_PATH_VENDORDIR,
-#else
-			NULL,
-#endif
-			"/etc", "login", "defs", "= \t", "#");
-
-	if (error)
-	  syslog(LOG_NOTICE, _("Error reading login.defs: %s"),
-		 econf_errString(error));
+    error = econf_readDirs(&file,
+    #if USE_VENDORDIR
+                           _PATH_VENDORDIR,
+    #else
+                           NULL,
+    #endif
+                           "/etc", "login", "defs", "= \t", "#");
 
-	if (logindefs_loader)
-		logindefs_loader(logindefs_loader_data);
+    if (error)
+        syslog(LOG_NOTICE, _("Error reading login.defs: %s"),
+               econf_errString(error));
 
+    if (logindefs_loader) logindefs_loader(logindefs_loader_data);
 }
 
-void logindefs_load_file(const char *filename)
+void logindefs_load_file(const char* filename)
 {
-	econf_file *file_l = NULL, *file_m = NULL;
-	char *path;
-
-	logindefs_loader = NULL; /* No recursion */
-
-#if USE_VENDORDIR
-	xasprintf(&path, _PATH_VENDORDIR"/%s", filename);
-
-	if (!econf_readFile(&file_l, path, "= \t", "#")) {
-	        if (file == NULL)
-		        file = file_l;
-	        else if (!econf_mergeFiles(&file_m, file, file_l)) {
-		        econf_free(file);
-			file = file_m;
-			econf_free(file_l);
-		}
-	}
-	free (path);
-#endif
-
-	xasprintf(&path, "/etc/%s", filename);
-
-	if (!econf_readFile(&file_l, path, "= \t", "#")) {
-	        if (file == NULL)
-		        file = file_l;
-	        else if (!econf_mergeFiles(&file_m, file, file_l)) {
-	                econf_free(file);
-			file = file_m;
-			econf_free(file_l);
-		}
-
-	/* Try original filename, could be relative */
-	} else if (!econf_readFile(&file_l, filename, "= \t", "#")) {
-		if (file == NULL)
-			file = file_l;
-		else if (!econf_mergeFiles(&file_m, file, file_l)) {
-			econf_free(file);
-			file = file_m;
-			econf_free(file_l);
-		}
-	}
-	free (path);
+    econf_file *file_l = NULL, *file_m = NULL;
+    char*       path;
+
+    logindefs_loader = NULL; /* No recursion */
+
+    #if USE_VENDORDIR
+    xasprintf(&path, _PATH_VENDORDIR "/%s", filename);
+
+    if (!econf_readFile(&file_l, path, "= \t", "#"))
+    {
+        if (file == NULL) file = file_l;
+        else if (!econf_mergeFiles(&file_m, file, file_l))
+        {
+            econf_free(file);
+            file = file_m;
+            econf_free(file_l);
+        }
+    }
+    free(path);
+    #endif
+
+    xasprintf(&path, "/etc/%s", filename);
+
+    if (!econf_readFile(&file_l, path, "= \t", "#"))
+    {
+        if (file == NULL) file = file_l;
+        else if (!econf_mergeFiles(&file_m, file, file_l))
+        {
+            econf_free(file);
+            file = file_m;
+            econf_free(file_l);
+        }
+
+        /* Try original filename, could be relative */
+    }
+    else if (!econf_readFile(&file_l, filename, "= \t", "#"))
+    {
+        if (file == NULL) file = file_l;
+        else if (!econf_mergeFiles(&file_m, file, file_l))
+        {
+            econf_free(file);
+            file = file_m;
+            econf_free(file_l);
+        }
+    }
+    free(path);
 }
 
-int getlogindefs_bool(const char *name, int dflt)
+int getlogindefs_bool(const char* name, int dflt)
 {
-        bool value;
-	econf_err error;
-
-	if (!file)
-	        load_defaults();
-
-	if (!file)
-		return dflt;
-
-	if ((error = econf_getBoolValue(file, NULL, name, &value))) {
-	        if (error != ECONF_NOKEY)
-	                syslog(LOG_NOTICE, _("couldn't fetch %s: %s"), name,
-			       econf_errString(error));
-		return dflt;
-	}
-	return value;
+    bool      value;
+    econf_err error;
+
+    if (!file) load_defaults();
+
+    if (!file) return dflt;
+
+    if ((error = econf_getBoolValue(file, NULL, name, &value)))
+    {
+        if (error != ECONF_NOKEY)
+            syslog(LOG_NOTICE, _("couldn't fetch %s: %s"), name,
+                   econf_errString(error));
+        return dflt;
+    }
+    return value;
 }
 
-unsigned long getlogindefs_num(const char *name, unsigned long dflt)
+unsigned long getlogindefs_num(const char* name, unsigned long dflt)
 {
-	uint64_t value;
-	econf_err error;
-
-	if (!file)
-	        load_defaults();
-
-	if (!file)
-		return dflt;
-
-	if ((error = econf_getUInt64Value(file, NULL, name, &value))) {
-	        if (error != ECONF_NOKEY)
-		        syslog(LOG_NOTICE, _("couldn't fetch %s: %s"), name,
-			       econf_errString(error));
-		return dflt;
-	}
-	return value;
+    uint64_t  value;
+    econf_err error;
+
+    if (!file) load_defaults();
+
+    if (!file) return dflt;
+
+    if ((error = econf_getUInt64Value(file, NULL, name, &value)))
+    {
+        if (error != ECONF_NOKEY)
+            syslog(LOG_NOTICE, _("couldn't fetch %s: %s"), name,
+                   econf_errString(error));
+        return dflt;
+    }
+    return value;
 }
 
 /*
@@ -363,27 +346,25 @@ unsigned long getlogindefs_num(const char *name, unsigned long dflt)
  *	""		(empty string) if found, but value not defined
  *	"string"	if found
  */
-const char *getlogindefs_str(const char *name, const char *dflt)
+const char* getlogindefs_str(const char* name, const char* dflt)
 {
-        char *value;
-	econf_err error;
+    char*     value;
+    econf_err error;
 
-	if (!file)
-	        load_defaults();
+    if (!file) load_defaults();
 
-	if (!file)
-		return dflt;
+    if (!file) return dflt;
 
-	if ((error = econf_getStringValue(file, NULL, name, &value))) {
-	        if (error != ECONF_NOKEY)
-		  syslog(LOG_NOTICE, _("couldn't fetch %s: %s"), name,
-			 econf_errString(error));
-		return dflt;
-	}
-	if (value)
-		return value;
+    if ((error = econf_getStringValue(file, NULL, name, &value)))
+    {
+        if (error != ECONF_NOKEY)
+            syslog(LOG_NOTICE, _("couldn't fetch %s: %s"), name,
+                   econf_errString(error));
+        return dflt;
+    }
+    if (value) return value;
 
-	return xstrdup("");
+    return xstrdup("");
 }
 #endif /* !HAVE_LIBECONF */
 
@@ -400,28 +381,27 @@ const char *getlogindefs_str(const char *name, const char *dflt)
  *
  * the FOO= prefix has to be remove before we call setenv().
  */
-int logindefs_setenv(const char *name, const char *conf, const char *dflt)
+int logindefs_setenv(const char* name, const char* conf, const char* dflt)
 {
-	const char *val = getlogindefs_str(conf, dflt);
-	const char *p;
-
-	if (!val)
-		return -1;
-
-	p = strchr(val, '=');
-	if (p) {
-		size_t sz = strlen(name);
-
-		if (strncmp(val, name, sz) == 0 && *(p + 1)) {
-			val = p + 1;
-			if (*val == '"')
-				val++;
-			if (!*val)
-				val = dflt;
-		}
-	}
-
-	return val ? setenv(name, val, 1) : -1;
+    const char* val = getlogindefs_str(conf, dflt);
+    const char* p;
+
+    if (!val) return -1;
+
+    p = strchr(val, '=');
+    if (p)
+    {
+        size_t sz = strlen(name);
+
+        if (strncmp(val, name, sz) == 0 && *(p + 1))
+        {
+            val = p + 1;
+            if (*val == '"') val++;
+            if (!*val) val = dflt;
+        }
+    }
+
+    return val ? setenv(name, val, 1) : -1;
 }
 
 /*
@@ -430,12 +410,11 @@ int logindefs_setenv(const char *name, const char *conf, const char *dflt)
  * real UID/GID.  Then open(2) seems as the surest solution.
  * -- kzak@redhat.com (10-Apr-2009)
  */
-int effective_access(const char *path, int mode)
+int effective_access(const char* path, int mode)
 {
-	int fd = open(path, mode);
-	if (fd != -1)
-		close(fd);
-	return fd == -1 ? -1 : 0;
+    int fd = open(path, mode);
+    if (fd != -1) close(fd);
+    return fd == -1 ? -1 : 0;
 }
 
 /*
@@ -468,141 +447,136 @@ int effective_access(const char *path, int mode)
  * BSD setreuid().
  */
 
-int get_hushlogin_status(struct passwd *pwd, int force_check)
+int get_hushlogin_status(struct passwd* pwd, int force_check)
 {
-	const char *files[] = { _PATH_HUSHLOGINS, _PATH_HUSHLOGIN, NULL };
-	const char *file;
-	char buf[BUFSIZ];
-	int i;
-
-	file = getlogindefs_str("HUSHLOGIN_FILE", NULL);
-	if (file) {
-		if (!*file)
-			return 0;	/* empty HUSHLOGIN_FILE defined */
-
-		files[0] = file;
-		files[1] = NULL;
-	}
-
-	for (i = 0; files[i]; i++) {
-		int ok = 0;
-
-		file = files[i];
-
-		/* global hush-file */
-		if (*file == '/') {
-			struct stat st;
-			FILE *f;
-
-			if (stat(file, &st) != 0)
-				continue;	/* file does not exist */
-
-			if (st.st_size == 0)
-				return 1;	/* for all accounts */
-
-			f = fopen(file, "r");
-			if (!f)
-				continue;	/* ignore errors... */
-
-			while (ok == 0 && fgets(buf, sizeof(buf), f)) {
-				if (buf[0] != '\0')
-					buf[strlen(buf) - 1] = '\0';
-				ok = !strcmp(buf, *buf == '/' ? pwd->pw_shell :
-								pwd->pw_name);
-			}
-			fclose(f);
-			if (ok)
-				return 1;	/* found username/shell */
-
-			return 0;		/* ignore per-account files */
-		}
-
-		/* per-account setting */
-		if (strlen(pwd->pw_dir) + strlen(file) + 2 > sizeof(buf))
-			continue;
-
-		sprintf(buf, "%s/%s", pwd->pw_dir, file);
-
-		if (force_check) {
-			uid_t ruid = getuid();
-			gid_t egid = getegid();
-
-			if (setregid(-1, pwd->pw_gid) == 0 &&
-			    setreuid(0, pwd->pw_uid) == 0)
-				ok = effective_access(buf, O_RDONLY) == 0;
-
-			if (setuid(0) != 0 ||
-			    setreuid(ruid, 0) != 0 ||
-			    setregid(-1, egid) != 0) {
-				syslog(LOG_ALERT, _("hush login status: restore original IDs failed"));
-				exit(EXIT_FAILURE);
-			}
-			if (ok)
-				return 1;	/* enabled by user */
-		}
-		else {
-			int rc;
-			rc = effective_access(buf, O_RDONLY);
-			if (rc == 0)
-				return 1;
-
-			if (rc == -1 && errno == EACCES)
-				return -1;
-		}
-
-	}
-
-	return 0;
+    const char* files[] = {_PATH_HUSHLOGINS, _PATH_HUSHLOGIN, NULL};
+    const char* file;
+    char        buf[BUFSIZ];
+    int         i;
+
+    file = getlogindefs_str("HUSHLOGIN_FILE", NULL);
+    if (file)
+    {
+        if (!*file) return 0; /* empty HUSHLOGIN_FILE defined */
+
+        files[0] = file;
+        files[1] = NULL;
+    }
+
+    for (i = 0; files[i]; i++)
+    {
+        int ok = 0;
+
+        file   = files[i];
+
+        /* global hush-file */
+        if (*file == '/')
+        {
+            struct stat st;
+            FILE*       f;
+
+            if (stat(file, &st) != 0) continue; /* file does not exist */
+
+            if (st.st_size == 0) return 1; /* for all accounts */
+
+            f = fopen(file, "r");
+            if (!f) continue; /* ignore errors... */
+
+            while (ok == 0 && fgets(buf, sizeof(buf), f))
+            {
+                if (buf[0] != '\0') buf[strlen(buf) - 1] = '\0';
+                ok = !strcmp(buf, *buf == '/' ? pwd->pw_shell : pwd->pw_name);
+            }
+            fclose(f);
+            if (ok) return 1; /* found username/shell */
+
+            return 0; /* ignore per-account files */
+        }
+
+        /* per-account setting */
+        if (strlen(pwd->pw_dir) + strlen(file) + 2 > sizeof(buf)) continue;
+
+        sprintf(buf, "%s/%s", pwd->pw_dir, file);
+
+        if (force_check)
+        {
+            uid_t ruid = getuid();
+            gid_t egid = getegid();
+
+            if (setregid(-1, pwd->pw_gid) == 0 && setreuid(0, pwd->pw_uid) == 0)
+                ok = effective_access(buf, O_RDONLY) == 0;
+
+            if (setuid(0) != 0 || setreuid(ruid, 0) != 0
+                || setregid(-1, egid) != 0)
+            {
+                syslog(LOG_ALERT,
+                       _("hush login status: restore original IDs failed"));
+                exit(EXIT_FAILURE);
+            }
+            if (ok) return 1; /* enabled by user */
+        }
+        else
+        {
+            int rc;
+            rc = effective_access(buf, O_RDONLY);
+            if (rc == 0) return 1;
+
+            if (rc == -1 && errno == EACCES) return -1;
+        }
+    }
+
+    return 0;
 }
 #ifdef TEST_PROGRAM
-int main(int argc, char *argv[])
+int main(int argc, char* argv[])
 {
-	char *name, *type;
-	close_stdout_atexit();
-
-	if (argc <= 1)
-		errx(EXIT_FAILURE, "usage: %s <filename> "
-		     "[<str|num|bool> <valname>]", argv[0]);
-
-	logindefs_load_file(argv[1]);
-
-	if (argc != 4) {	/* list all */
-#ifdef HAVE_LIBECONF
-		int i;
-		char *keys[] = {"END", "EMPTY", "CRAZY3", "CRAZY2", "CRAZY1",
-				"BOOLEAN", "NUMBER", "STRING", "HELLO_WORLD",
-				NULL};
-
-		for (i = 0; keys[i] != NULL; i++) {
-		  	char *value = NULL;
-
-			econf_getStringValue(file, NULL, keys[i], &value);
-		        printf ("%s: $%s: '%s'\n", argv[1], keys[i], value);
-		}
-
-		econf_free (file);
-
-#else
-		struct item *ptr;
-
-		for (ptr = list; ptr; ptr = ptr->next)
-			printf("%s: $%s: '%s'\n", ptr->path, ptr->name,
-			       ptr->value);
-#endif
-		return EXIT_SUCCESS;
-	}
-
-	type = argv[2];
-	name = argv[3];
-
-	if (strcmp(type, "str") == 0)
-		printf("$%s: '%s'\n", name, getlogindefs_str(name, "DEFAULT"));
-	else if (strcmp(type, "num") == 0)
-		printf("$%s: '%ld'\n", name, getlogindefs_num(name, 0));
-	else if (strcmp(type, "bool") == 0)
-		printf("$%s: '%s'\n", name,
-		       getlogindefs_bool(name, 0) ? "Y" : "N");
-
-	return EXIT_SUCCESS;
+    char *name, *type;
+    close_stdout_atexit();
+
+    if (argc <= 1)
+        errx(EXIT_FAILURE,
+             "usage: %s <filename> "
+             "[<str|num|bool> <valname>]",
+             argv[0]);
+
+    logindefs_load_file(argv[1]);
+
+    if (argc != 4)
+    { /* list all */
+    #ifdef HAVE_LIBECONF
+        int   i;
+        char* keys[] = {"END",     "EMPTY",  "CRAZY3", "CRAZY2",      "CRAZY1",
+                        "BOOLEAN", "NUMBER", "STRING", "HELLO_WORLD", NULL};
+
+        for (i = 0; keys[i] != NULL; i++)
+        {
+            char* value = NULL;
+
+            econf_getStringValue(file, NULL, keys[i], &value);
+            printf("%s: $%s: '%s'\n", argv[1], keys[i], value);
+        }
+
+        econf_free(file);
+
+    #else
+        struct item* ptr;
+
+        for (ptr = list; ptr; ptr = ptr->next)
+            printf("%s: $%s: '%s'\n", ptr->path, ptr->name, ptr->value);
+    #endif
+        return EXIT_SUCCESS;
+    }
+
+    type = argv[2];
+    name = argv[3];
+
+    if (strcmp(type, "str") == 0)
+        printf("$%s: '%s'\n", name, getlogindefs_str(name, "DEFAULT"));
+    else if (strcmp(type, "num") == 0)
+        printf("$%s: '%ld'\n", name, getlogindefs_num(name, 0));
+    else if (strcmp(type, "bool") == 0)
+        printf("$%s: '%s'\n", name, getlogindefs_bool(name, 0) ? "Y" : "N");
+
+    return EXIT_SUCCESS;
 }
 #endif
diff --git a/login-utils/lslogins.c b/login-utils/lslogins.c
index 773d13a..0e5e66f 100644
--- a/login-utils/lslogins.c
+++ b/login-utils/lslogins.c
@@ -19,62 +19,63 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
+#include <err.h>
 #include <getopt.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/syslog.h>
-#include <pwd.h>
 #include <grp.h>
-#include <shadow.h>
+#include <lastlog.h>
+#include <limits.h>
 #include <paths.h>
+#include <pwd.h>
+#include <search.h>
+#include <shadow.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <syslog.h>
 #include <time.h>
+#include <unistd.h>
 #include <utmpx.h>
-#include <signal.h>
-#include <err.h>
-#include <limits.h>
-#include <search.h>
-#include <lastlog.h>
 
 #include <libsmartcols.h>
 #ifdef HAVE_LIBSELINUX
-# include <selinux/selinux.h>
+    #include <selinux/selinux.h>
 #endif
 
 #ifdef HAVE_LIBSYSTEMD
-# include <systemd/sd-journal.h>
+    #include <systemd/sd-journal.h>
 #endif
 
 #include "c.h"
-#include "nls.h"
 #include "closestream.h"
-#include "xalloc.h"
 #include "list.h"
-#include "strutils.h"
+#include "logindefs.h"
+#include "nls.h"
 #include "optutils.h"
 #include "pathnames.h"
-#include "logindefs.h"
 #include "procutils.h"
+#include "strutils.h"
 #include "timeutils.h"
+#include "xalloc.h"
 
 /*
  * column description
  */
-struct lslogins_coldesc {
-	const char *name;
-	const char *help;
-	const char *pretty_name;
+struct lslogins_coldesc
+{
+    const char* name;
+    const char* help;
+    const char* pretty_name;
 
-	double whint;	/* width hint */
-	long flag;
+    double      whint; /* width hint */
+    long        flag;
 };
 
 static int lslogins_flag;
 
-#define UL_UID_MIN 1000
-#define UL_UID_MAX 60000
+#define UL_UID_MIN     1000
+#define UL_UID_MAX     60000
 #define UL_SYS_UID_MIN 101
 #define UL_SYS_UID_MAX 999
 
@@ -87,1577 +88,1577 @@ static int outmode;
 /*
  * output modes
  */
-enum {
-	OUT_COLON = 1,
-	OUT_EXPORT,
-	OUT_NEWLINE,
-	OUT_RAW,
-	OUT_NUL,
-	OUT_PRETTY
+enum
+{
+    OUT_COLON = 1,
+    OUT_EXPORT,
+    OUT_NEWLINE,
+    OUT_RAW,
+    OUT_NUL,
+    OUT_PRETTY
 };
 
-enum {
-	LASTLOG_TIME,
-	LASTLOG_LINE,
-	LASTLOG_HOST
+enum
+{
+    LASTLOG_TIME,
+    LASTLOG_LINE,
+    LASTLOG_HOST
 };
 
-struct lslogins_user {
-	char *login;
-	uid_t uid;
-	char *group;
-	gid_t gid;
-	char *gecos;
-
-	int pwd_empty;
-	int nologin;
-	int pwd_lock;
-	int pwd_deny;
-
-	gid_t *sgroups;
-	size_t nsgroups;
-
-	char *pwd_ctime;
-	char *pwd_warn;
-	char *pwd_expire;
-	char *pwd_ctime_min;
-	char *pwd_ctime_max;
-	const char *pwd_method;
-
-	char *last_login;
-	char *last_tty;
-	char *last_hostname;
-
-	char *failed_login;
-	char *failed_tty;
+struct lslogins_user
+{
+    char*       login;
+    uid_t       uid;
+    char*       group;
+    gid_t       gid;
+    char*       gecos;
+
+    int         pwd_empty;
+    int         nologin;
+    int         pwd_lock;
+    int         pwd_deny;
+
+    gid_t*      sgroups;
+    size_t      nsgroups;
+
+    char*       pwd_ctime;
+    char*       pwd_warn;
+    char*       pwd_expire;
+    char*       pwd_ctime_min;
+    char*       pwd_ctime_max;
+    const char* pwd_method;
+
+    char*       last_login;
+    char*       last_tty;
+    char*       last_hostname;
+
+    char*       failed_login;
+    char*       failed_tty;
 
 #ifdef HAVE_LIBSELINUX
-	security_context_t context;
+    security_context_t context;
 #endif
-	char *homedir;
-	char *shell;
-	char *pwd_status;
-	int   hushed;
-	char *nprocs;
-
+    char* homedir;
+    char* shell;
+    char* pwd_status;
+    int   hushed;
+    char* nprocs;
 };
 
 /*
  * time modes
  * */
-enum {
-	TIME_INVALID = 0,
-	TIME_SHORT,
-	TIME_FULL,
-	TIME_ISO,
-	TIME_ISO_SHORT,
+enum
+{
+    TIME_INVALID = 0,
+    TIME_SHORT,
+    TIME_FULL,
+    TIME_ISO,
+    TIME_ISO_SHORT,
 };
 
 /*
  * flags
  */
-enum {
-	F_SYSAC	= (1 << 3),
-	F_USRAC	= (1 << 4),
+enum
+{
+    F_SYSAC = (1 << 3),
+    F_USRAC = (1 << 4),
 };
 
 /*
  * IDs
  */
-enum {
-	COL_USER = 0,
-	COL_UID,
-	COL_GECOS,
-	COL_HOME,
-	COL_SHELL,
-	COL_NOLOGIN,
-	COL_PWDLOCK,
-	COL_PWDEMPTY,
-	COL_PWDDENY,
-	COL_PWDMETHOD,
-	COL_GROUP,
-	COL_GID,
-	COL_SGROUPS,
-	COL_SGIDS,
-	COL_LAST_LOGIN,
-	COL_LAST_TTY,
-	COL_LAST_HOSTNAME,
-	COL_FAILED_LOGIN,
-	COL_FAILED_TTY,
-	COL_HUSH_STATUS,
-	COL_PWD_WARN,
-	COL_PWD_CTIME,
-	COL_PWD_CTIME_MIN,
-	COL_PWD_CTIME_MAX,
-	COL_PWD_EXPIR,
-	COL_SELINUX,
-	COL_NPROCS,
+enum
+{
+    COL_USER = 0,
+    COL_UID,
+    COL_GECOS,
+    COL_HOME,
+    COL_SHELL,
+    COL_NOLOGIN,
+    COL_PWDLOCK,
+    COL_PWDEMPTY,
+    COL_PWDDENY,
+    COL_PWDMETHOD,
+    COL_GROUP,
+    COL_GID,
+    COL_SGROUPS,
+    COL_SGIDS,
+    COL_LAST_LOGIN,
+    COL_LAST_TTY,
+    COL_LAST_HOSTNAME,
+    COL_FAILED_LOGIN,
+    COL_FAILED_TTY,
+    COL_HUSH_STATUS,
+    COL_PWD_WARN,
+    COL_PWD_CTIME,
+    COL_PWD_CTIME_MIN,
+    COL_PWD_CTIME_MAX,
+    COL_PWD_EXPIR,
+    COL_SELINUX,
+    COL_NPROCS,
 };
 
-#define is_wtmp_col(x)	((x) == COL_LAST_LOGIN     || \
-			 (x) == COL_LAST_TTY       || \
-			 (x) == COL_LAST_HOSTNAME)
-
-#define is_btmp_col(x)	((x) == COL_FAILED_LOGIN   || \
-			 (x) == COL_FAILED_TTY)
+#define is_wtmp_col(x)                                                         \
+    ((x) == COL_LAST_LOGIN || (x) == COL_LAST_TTY || (x) == COL_LAST_HOSTNAME)
 
-enum {
-	STATUS_FALSE = 0,
-	STATUS_TRUE,
-	STATUS_UNKNOWN
-};
+#define is_btmp_col(x) ((x) == COL_FAILED_LOGIN || (x) == COL_FAILED_TTY)
 
-static const char *const status[] = {
-	[STATUS_FALSE]	= "0",
-	[STATUS_TRUE]	= "1",
-	[STATUS_UNKNOWN]= NULL
+enum
+{
+    STATUS_FALSE = 0,
+    STATUS_TRUE,
+    STATUS_UNKNOWN
 };
 
-static const char *const pretty_status[] = {
-	[STATUS_FALSE]	= N_("no"),
-	[STATUS_TRUE]	= N_("yes"),
-	[STATUS_UNKNOWN]= NULL
+static const char* const status[]
+    = {[STATUS_FALSE] = "0", [STATUS_TRUE] = "1", [STATUS_UNKNOWN] = NULL};
+
+static const char* const pretty_status[] = {[STATUS_FALSE]   = N_("no"),
+                                            [STATUS_TRUE]    = N_("yes"),
+                                            [STATUS_UNKNOWN] = NULL};
+
+#define get_status(x) (outmode == OUT_PRETTY ? pretty_status[(x)] : status[(x)])
+
+static const struct lslogins_coldesc coldescs[] = {
+    [COL_USER]
+    = {"USER", N_("user name"), N_("Username"), 0.1, SCOLS_FL_NOEXTREMES},
+    [COL_UID]       = {"UID", N_("user ID"), "UID", 1, SCOLS_FL_RIGHT},
+    [COL_PWDEMPTY]  = {"PWD-EMPTY", N_("password not required"),
+                       N_("Password not required"), 1, SCOLS_FL_RIGHT},
+    [COL_PWDDENY]   = {"PWD-DENY", N_("login by password disabled"),
+                       N_("Login by password disabled"), 1, SCOLS_FL_RIGHT},
+    [COL_PWDLOCK]   = {"PWD-LOCK", N_("password defined, but locked"),
+                       N_("Password is locked"), 1, SCOLS_FL_RIGHT},
+    [COL_PWDMETHOD] = {"PWD-METHOD", N_("password encryption method"),
+                       N_("Password encryption method"), 0.1},
+    [COL_NOLOGIN]
+    = {"NOLOGIN", N_("log in disabled by nologin(8) or pam_nologin(8)"),
+       N_("No login"), 1, SCOLS_FL_RIGHT},
+    [COL_GROUP] = {"GROUP", N_("primary group name"), N_("Primary group"), 0.1},
+    [COL_GID]   = {"GID", N_("primary group ID"), "GID", 1, SCOLS_FL_RIGHT},
+    [COL_SGROUPS] = {"SUPP-GROUPS", N_("supplementary group names"),
+                     N_("Supplementary groups"), 0.1},
+    [COL_SGIDS]   = {"SUPP-GIDS", N_("supplementary group IDs"),
+                     N_("Supplementary group IDs"), 0.1},
+    [COL_HOME]  = {"HOMEDIR", N_("home directory"), N_("Home directory"), 0.1},
+    [COL_SHELL] = {"SHELL", N_("login shell"), N_("Shell"), 0.1},
+    [COL_GECOS]
+    = {"GECOS", N_("full user name"), N_("Gecos field"), 0.1, SCOLS_FL_TRUNC},
+    [COL_LAST_LOGIN] = {"LAST-LOGIN", N_("date of last login"),
+                        N_("Last login"), 0.1, SCOLS_FL_RIGHT},
+    [COL_LAST_TTY]
+    = {"LAST-TTY", N_("last tty used"), N_("Last terminal"), 0.05},
+    [COL_LAST_HOSTNAME]
+    = {"LAST-HOSTNAME", N_("hostname during the last session"),
+       N_("Last hostname"), 0.1},
+    [COL_FAILED_LOGIN] = {"FAILED-LOGIN", N_("date of last failed login"),
+                          N_("Failed login"), 0.1},
+    [COL_FAILED_TTY]   = {"FAILED-TTY", N_("where did the login fail?"),
+                          N_("Failed login terminal"), 0.05},
+    [COL_HUSH_STATUS]
+    = {"HUSHED", N_("user's hush settings"), N_("Hushed"), 1, SCOLS_FL_RIGHT},
+    [COL_PWD_WARN]
+    = {"PWD-WARN", N_("days user is warned of password expiration"),
+       N_("Password expiration warn interval"), 0.1, SCOLS_FL_RIGHT},
+    [COL_PWD_EXPIR] = {"PWD-EXPIR", N_("password expiration date"),
+                       N_("Password expiration"), 0.1, SCOLS_FL_RIGHT},
+    [COL_PWD_CTIME] = {"PWD-CHANGE", N_("date of last password change"),
+                       N_("Password changed"), 0.1, SCOLS_FL_RIGHT},
+    [COL_PWD_CTIME_MIN]
+    = {"PWD-MIN", N_("number of days required between changes"),
+       N_("Minimum change time"), 0.1, SCOLS_FL_RIGHT},
+    [COL_PWD_CTIME_MAX]
+    = {"PWD-MAX", N_("max number of days a password may remain unchanged"),
+       N_("Maximum change time"), 0.1, SCOLS_FL_RIGHT},
+    [COL_SELINUX] = {"CONTEXT", N_("the user's security context"),
+                     N_("Selinux context"), 0.1},
+    [COL_NPROCS]  = {"PROC", N_("number of processes run by the user"),
+                     N_("Running processes"), 1, SCOLS_FL_RIGHT},
 };
 
-#define get_status(x)	(outmode == OUT_PRETTY ? pretty_status[(x)] : status[(x)])
-
-static const struct lslogins_coldesc coldescs[] =
+struct lslogins_control
 {
-	[COL_USER]          = { "USER",		N_("user name"), N_("Username"), 0.1, SCOLS_FL_NOEXTREMES },
-	[COL_UID]           = { "UID",		N_("user ID"), "UID", 1, SCOLS_FL_RIGHT},
-	[COL_PWDEMPTY]      = { "PWD-EMPTY",	N_("password not required"), N_("Password not required"), 1, SCOLS_FL_RIGHT },
-	[COL_PWDDENY]       = { "PWD-DENY",	N_("login by password disabled"), N_("Login by password disabled"), 1, SCOLS_FL_RIGHT },
-	[COL_PWDLOCK]       = { "PWD-LOCK",	N_("password defined, but locked"), N_("Password is locked"), 1, SCOLS_FL_RIGHT },
-	[COL_PWDMETHOD]     = { "PWD-METHOD",   N_("password encryption method"), N_("Password encryption method"), 0.1 },
-	[COL_NOLOGIN]       = { "NOLOGIN",	N_("log in disabled by nologin(8) or pam_nologin(8)"), N_("No login"), 1, SCOLS_FL_RIGHT },
-	[COL_GROUP]         = { "GROUP",	N_("primary group name"), N_("Primary group"), 0.1 },
-	[COL_GID]           = { "GID",		N_("primary group ID"), "GID", 1, SCOLS_FL_RIGHT },
-	[COL_SGROUPS]       = { "SUPP-GROUPS",	N_("supplementary group names"), N_("Supplementary groups"), 0.1 },
-	[COL_SGIDS]         = { "SUPP-GIDS",    N_("supplementary group IDs"), N_("Supplementary group IDs"), 0.1 },
-	[COL_HOME]          = { "HOMEDIR",	N_("home directory"), N_("Home directory"), 0.1 },
-	[COL_SHELL]         = { "SHELL",	N_("login shell"), N_("Shell"), 0.1 },
-	[COL_GECOS]         = { "GECOS",	N_("full user name"), N_("Gecos field"), 0.1, SCOLS_FL_TRUNC },
-	[COL_LAST_LOGIN]    = { "LAST-LOGIN",	N_("date of last login"), N_("Last login"), 0.1, SCOLS_FL_RIGHT },
-	[COL_LAST_TTY]      = { "LAST-TTY",	N_("last tty used"), N_("Last terminal"), 0.05 },
-	[COL_LAST_HOSTNAME] = { "LAST-HOSTNAME",N_("hostname during the last session"), N_("Last hostname"),  0.1},
-	[COL_FAILED_LOGIN]  = { "FAILED-LOGIN",	N_("date of last failed login"), N_("Failed login"), 0.1 },
-	[COL_FAILED_TTY]    = { "FAILED-TTY",	N_("where did the login fail?"), N_("Failed login terminal"), 0.05 },
-	[COL_HUSH_STATUS]   = { "HUSHED",	N_("user's hush settings"), N_("Hushed"), 1, SCOLS_FL_RIGHT },
-	[COL_PWD_WARN]      = { "PWD-WARN",	N_("days user is warned of password expiration"), N_("Password expiration warn interval"), 0.1, SCOLS_FL_RIGHT },
-	[COL_PWD_EXPIR]     = { "PWD-EXPIR",	N_("password expiration date"), N_("Password expiration"), 0.1, SCOLS_FL_RIGHT },
-	[COL_PWD_CTIME]     = { "PWD-CHANGE",	N_("date of last password change"), N_("Password changed"), 0.1, SCOLS_FL_RIGHT},
-	[COL_PWD_CTIME_MIN] = { "PWD-MIN",	N_("number of days required between changes"), N_("Minimum change time"), 0.1, SCOLS_FL_RIGHT },
-	[COL_PWD_CTIME_MAX] = { "PWD-MAX",	N_("max number of days a password may remain unchanged"), N_("Maximum change time"), 0.1, SCOLS_FL_RIGHT },
-	[COL_SELINUX]       = { "CONTEXT",	N_("the user's security context"), N_("Selinux context"), 0.1 },
-	[COL_NPROCS]        = { "PROC",         N_("number of processes run by the user"), N_("Running processes"), 1, SCOLS_FL_RIGHT },
-};
+    struct utmpx* wtmp;
+    size_t        wtmp_size;
 
-struct lslogins_control {
-	struct utmpx *wtmp;
-	size_t wtmp_size;
+    struct utmpx* btmp;
+    size_t        btmp_size;
 
-	struct utmpx *btmp;
-	size_t btmp_size;
+    int           lastlogin_fd;
 
-	int lastlogin_fd;
+    void*         usertree;
 
-	void *usertree;
+    uid_t         uid;
+    uid_t         UID_MIN;
+    uid_t         UID_MAX;
 
-	uid_t uid;
-	uid_t UID_MIN;
-	uid_t UID_MAX;
+    uid_t         SYS_UID_MIN;
+    uid_t         SYS_UID_MAX;
 
-	uid_t SYS_UID_MIN;
-	uid_t SYS_UID_MAX;
+    char**        ulist;
+    size_t        ulsiz;
 
-	char **ulist;
-	size_t ulsiz;
+    unsigned int  time_mode;
 
-	unsigned int time_mode;
+    const char*   journal_path;
 
-	const char *journal_path;
-
-	unsigned int selinux_enabled : 1,
-		     fail_on_unknown : 1,		/* fail if user does not exist */
-		     ulist_on : 1,
-		     noheadings : 1,
-		     notrunc : 1;
+    unsigned int  selinux_enabled : 1,
+        fail_on_unknown           : 1, /* fail if user does not exist */
+        ulist_on : 1, noheadings : 1, notrunc : 1;
 };
 
 /* these have to remain global since there's no other reasonable way to pass
  * them for each call of fill_table() via twalk() */
-static struct libscols_table *tb;
+static struct libscols_table* tb;
 
 /* columns[] array specifies all currently wanted output column. The columns
  * are defined by coldescs[] array and you can specify (on command line) each
  * column twice. That's enough, dynamically allocated array of the columns is
  * unnecessary overkill and over-engineering in this case */
-static int columns[ARRAY_SIZE(coldescs) * 2];
-static size_t ncolumns;
+static int                    columns[ARRAY_SIZE(coldescs) * 2];
+static size_t                 ncolumns;
 
-static inline size_t err_columns_index(size_t arysz, size_t idx)
+static inline size_t          err_columns_index(size_t arysz, size_t idx)
 {
-	if (idx >= arysz)
-		errx(EXIT_FAILURE, _("too many columns specified, "
-				     "the limit is %zu columns"),
-				arysz - 1);
-	return idx;
+    if (idx >= arysz)
+        errx(EXIT_FAILURE,
+             _("too many columns specified, "
+               "the limit is %zu columns"),
+             arysz - 1);
+    return idx;
 }
 
-#define add_column(ary, n, id)	\
-		((ary)[ err_columns_index(ARRAY_SIZE(ary), (n)) ] = (id))
+#define add_column(ary, n, id)                                                 \
+    ((ary)[err_columns_index(ARRAY_SIZE(ary), (n))] = (id))
 
-static int column_name_to_id(const char *name, size_t namesz)
+static int column_name_to_id(const char* name, size_t namesz)
 {
-	size_t i;
+    size_t i;
 
-	for (i = 0; i < ARRAY_SIZE(coldescs); i++) {
-		const char *cn = coldescs[i].name;
+    for (i = 0; i < ARRAY_SIZE(coldescs); i++)
+    {
+        const char* cn = coldescs[i].name;
 
-		if (!strncasecmp(name, cn, namesz) && !*(cn + namesz))
-			return i;
-	}
-	warnx(_("unknown column: %s"), name);
-	return -1;
+        if (!strncasecmp(name, cn, namesz) && !*(cn + namesz)) return i;
+    }
+    warnx(_("unknown column: %s"), name);
+    return -1;
 }
 
 static struct timeval now;
 
-static char *make_time(int mode, time_t time)
+static char*          make_time(int mode, time_t time)
 {
-	int rc = 0;
-	char buf[64] = {0};
-
-	switch(mode) {
-	case TIME_FULL:
-	{
-		char *s;
-		struct tm tm;
-		localtime_r(&time, &tm);
-
-		asctime_r(&tm, buf);
-		if (*(s = buf + strlen(buf) - 1) == '\n')
-			*s = '\0';
-		rc = 0;
-		break;
-	}
-	case TIME_SHORT:
-		rc = strtime_short(&time, &now, UL_SHORTTIME_THISYEAR_HHMM,
-				buf, sizeof(buf));
-		break;
-	case TIME_ISO:
-		rc = strtime_iso(&time, ISO_TIMESTAMP_T, buf, sizeof(buf));
-		break;
-	case TIME_ISO_SHORT:
-		rc = strtime_iso(&time, ISO_DATE, buf, sizeof(buf));
-		break;
-	default:
-		errx(EXIT_FAILURE, _("unsupported time type"));
-	}
-
-	if (rc)
-		 errx(EXIT_FAILURE, _("failed to compose time string"));
-
-	return xstrdup(buf);
+    int  rc      = 0;
+    char buf[64] = {0};
+
+    switch (mode)
+    {
+        case TIME_FULL:
+        {
+            char*     s;
+            struct tm tm;
+            localtime_r(&time, &tm);
+
+            asctime_r(&tm, buf);
+            if (*(s = buf + strlen(buf) - 1) == '\n') *s = '\0';
+            rc = 0;
+            break;
+        }
+        case TIME_SHORT:
+            rc = strtime_short(&time, &now, UL_SHORTTIME_THISYEAR_HHMM, buf,
+                               sizeof(buf));
+            break;
+        case TIME_ISO:
+            rc = strtime_iso(&time, ISO_TIMESTAMP_T, buf, sizeof(buf));
+            break;
+        case TIME_ISO_SHORT:
+            rc = strtime_iso(&time, ISO_DATE, buf, sizeof(buf));
+            break;
+        default: errx(EXIT_FAILURE, _("unsupported time type"));
+    }
+
+    if (rc) errx(EXIT_FAILURE, _("failed to compose time string"));
+
+    return xstrdup(buf);
 }
 
-
-static char *uidtostr(uid_t uid)
+static char* uidtostr(uid_t uid)
 {
-	char *str_uid = NULL;
-	xasprintf(&str_uid, "%u", uid);
-	return str_uid;
+    char* str_uid = NULL;
+    xasprintf(&str_uid, "%u", uid);
+    return str_uid;
 }
 
-static char *gidtostr(gid_t gid)
+static char* gidtostr(gid_t gid)
 {
-	char *str_gid = NULL;
-	xasprintf(&str_gid, "%u", gid);
-	return str_gid;
+    char* str_gid = NULL;
+    xasprintf(&str_gid, "%u", gid);
+    return str_gid;
 }
 
-static char *build_sgroups_string(gid_t *sgroups, size_t nsgroups, int want_names)
+static char* build_sgroups_string(gid_t* sgroups, size_t nsgroups,
+                                  int want_names)
 {
-	size_t n = 0, maxlen, len;
-	char *res, *p;
-
-	if (!nsgroups)
-		return NULL;
-
-	len = maxlen = nsgroups * 10;
-	res = p = xmalloc(maxlen);
-
-	while (n < nsgroups) {
-		int x;
-again:
-		if (!want_names)
-			x = snprintf(p, len, "%u,", sgroups[n]);
-		else {
-			struct group *grp = getgrgid(sgroups[n]);
-			if (!grp) {
-				free(res);
-				return NULL;
-			}
-			x = snprintf(p, len, "%s,", grp->gr_name);
-		}
-
-		if (x < 0 || (size_t) x >= len) {
-			size_t cur = p - res;
-
-			maxlen *= 2;
-			res = xrealloc(res, maxlen);
-			p = res + cur;
-			len = maxlen - cur;
-			goto again;
-		}
-
-		len -= x;
-		p += x;
-		++n;
-	}
-
-	if (p > res)
-		*(p - 1) = '\0';
-
-	return res;
+    size_t n = 0, maxlen, len;
+    char * res, *p;
+
+    if (!nsgroups) return NULL;
+
+    len = maxlen = nsgroups * 10;
+    res = p = xmalloc(maxlen);
+
+    while (n < nsgroups)
+    {
+        int x;
+    again:
+        if (!want_names) x = snprintf(p, len, "%u,", sgroups[n]);
+        else
+        {
+            struct group* grp = getgrgid(sgroups[n]);
+            if (!grp)
+            {
+                free(res);
+                return NULL;
+            }
+            x = snprintf(p, len, "%s,", grp->gr_name);
+        }
+
+        if (x < 0 || (size_t)x >= len)
+        {
+            size_t cur = p - res;
+
+            maxlen *= 2;
+            res = xrealloc(res, maxlen);
+            p   = res + cur;
+            len = maxlen - cur;
+            goto again;
+        }
+
+        len -= x;
+        p += x;
+        ++n;
+    }
+
+    if (p > res) *(p - 1) = '\0';
+
+    return res;
 }
 
-static struct utmpx *get_last_wtmp(struct lslogins_control *ctl, const char *username)
+static struct utmpx* get_last_wtmp(struct lslogins_control* ctl,
+                                   const char*              username)
 {
-	size_t n = 0;
+    size_t n = 0;
 
-	if (!username)
-		return NULL;
-
-	n = ctl->wtmp_size - 1;
-	do {
-		if (!strncmp(username, ctl->wtmp[n].ut_user,
-		             sizeof(ctl->wtmp[0].ut_user)))
-			return ctl->wtmp + n;
-	} while (n--);
-	return NULL;
+    if (!username) return NULL;
 
+    n = ctl->wtmp_size - 1;
+    do {
+        if (!strncmp(username, ctl->wtmp[n].ut_user,
+                     sizeof(ctl->wtmp[0].ut_user)))
+            return ctl->wtmp + n;
+    } while (n--);
+    return NULL;
 }
 
 static int require_wtmp(void)
 {
-	size_t i;
-	for (i = 0; i < ncolumns; i++)
-		if (is_wtmp_col(columns[i]))
-			return 1;
-	return 0;
+    size_t i;
+    for (i = 0; i < ncolumns; i++)
+        if (is_wtmp_col(columns[i])) return 1;
+    return 0;
 }
 
 static int require_btmp(void)
 {
-	size_t i;
-	for (i = 0; i < ncolumns; i++)
-		if (is_btmp_col(columns[i]))
-			return 1;
-	return 0;
+    size_t i;
+    for (i = 0; i < ncolumns; i++)
+        if (is_btmp_col(columns[i])) return 1;
+    return 0;
 }
 
-static struct utmpx *get_last_btmp(struct lslogins_control *ctl, const char *username)
+static struct utmpx* get_last_btmp(struct lslogins_control* ctl,
+                                   const char*              username)
 {
-	size_t n = 0;
-
-	if (!username)
-		return NULL;
+    size_t n = 0;
 
-	n = ctl->btmp_size - 1;
-	do {
-		if (!strncmp(username, ctl->btmp[n].ut_user,
-		             sizeof(ctl->wtmp[0].ut_user)))
-			return ctl->btmp + n;
-	}while (n--);
-	return NULL;
+    if (!username) return NULL;
 
+    n = ctl->btmp_size - 1;
+    do {
+        if (!strncmp(username, ctl->btmp[n].ut_user,
+                     sizeof(ctl->wtmp[0].ut_user)))
+            return ctl->btmp + n;
+    } while (n--);
+    return NULL;
 }
 
-static int read_utmp(char const *file, size_t *nents, struct utmpx **res)
+static int read_utmp(char const* file, size_t* nents, struct utmpx** res)
 {
-	size_t n_read = 0, n_alloc = 0;
-	struct utmpx *utmp = NULL, *u;
-
-	if (utmpxname(file) < 0)
-		return -errno;
-
-	setutxent();
-	errno = 0;
-
-	while ((u = getutxent()) != NULL) {
-		if (n_read == n_alloc) {
-			n_alloc += 32;
-			utmp = xrealloc(utmp, n_alloc * sizeof (struct utmpx));
-		}
-		utmp[n_read++] = *u;
-	}
-	if (!u && errno) {
-		free(utmp);
-		return -errno;
-	}
-
-	endutxent();
-
-	*nents = n_read;
-	*res = utmp;
-
-	return 0;
+    size_t        n_read = 0, n_alloc = 0;
+    struct utmpx *utmp = NULL, *u;
+
+    if (utmpxname(file) < 0) return -errno;
+
+    setutxent();
+    errno = 0;
+
+    while ((u = getutxent()) != NULL)
+    {
+        if (n_read == n_alloc)
+        {
+            n_alloc += 32;
+            utmp = xrealloc(utmp, n_alloc * sizeof(struct utmpx));
+        }
+        utmp[n_read++] = *u;
+    }
+    if (!u && errno)
+    {
+        free(utmp);
+        return -errno;
+    }
+
+    endutxent();
+
+    *nents = n_read;
+    *res   = utmp;
+
+    return 0;
 }
 
-static int parse_wtmp(struct lslogins_control *ctl, char *path)
+static int parse_wtmp(struct lslogins_control* ctl, char* path)
 {
-	int rc = 0;
+    int rc = 0;
 
-	rc = read_utmp(path, &ctl->wtmp_size, &ctl->wtmp);
-	if (rc < 0 && errno != EACCES)
-		err(EXIT_FAILURE, "%s", path);
-	return rc;
+    rc     = read_utmp(path, &ctl->wtmp_size, &ctl->wtmp);
+    if (rc < 0 && errno != EACCES) err(EXIT_FAILURE, "%s", path);
+    return rc;
 }
 
-static int parse_btmp(struct lslogins_control *ctl, char *path)
+static int parse_btmp(struct lslogins_control* ctl, char* path)
 {
-	int rc = 0;
+    int rc = 0;
 
-	rc = read_utmp(path, &ctl->btmp_size, &ctl->btmp);
-	if (rc < 0 && errno != EACCES)
-		err(EXIT_FAILURE, "%s", path);
-	return rc;
+    rc     = read_utmp(path, &ctl->btmp_size, &ctl->btmp);
+    if (rc < 0 && errno != EACCES) err(EXIT_FAILURE, "%s", path);
+    return rc;
 }
 
-static void get_lastlog(struct lslogins_control *ctl, uid_t uid, void *dst, int what)
+static void get_lastlog(struct lslogins_control* ctl, uid_t uid, void* dst,
+                        int what)
 {
-	struct lastlog ll;
-
-	if (ctl->lastlogin_fd < 0 ||
-	    pread(ctl->lastlogin_fd, (void *)&ll, sizeof(ll), uid * sizeof(ll)) != sizeof(ll))
-		return;
-
-	switch (what) {
-	case LASTLOG_TIME: {
-		time_t *t = (time_t *)dst;
-		*t = ll.ll_time;
-		break;
-		}
-	case LASTLOG_LINE:
-		mem2strcpy(dst, ll.ll_line, sizeof(ll.ll_line), sizeof(ll.ll_line) + 1);
-		break;
-	case LASTLOG_HOST:
-		mem2strcpy(dst, ll.ll_host, sizeof(ll.ll_host), sizeof(ll.ll_host) + 1);
-		break;
-	default:
-		abort();
-	}
+    struct lastlog ll;
+
+    if (ctl->lastlogin_fd < 0
+        || pread(ctl->lastlogin_fd, (void*)&ll, sizeof(ll), uid * sizeof(ll))
+               != sizeof(ll))
+        return;
+
+    switch (what)
+    {
+        case LASTLOG_TIME:
+        {
+            time_t* t = (time_t*)dst;
+            *t        = ll.ll_time;
+            break;
+        }
+        case LASTLOG_LINE:
+            mem2strcpy(dst, ll.ll_line, sizeof(ll.ll_line),
+                       sizeof(ll.ll_line) + 1);
+            break;
+        case LASTLOG_HOST:
+            mem2strcpy(dst, ll.ll_host, sizeof(ll.ll_host),
+                       sizeof(ll.ll_host) + 1);
+            break;
+        default: abort();
+    }
 }
 
-static int get_sgroups(gid_t **list, size_t *len, struct passwd *pwd)
+static int get_sgroups(gid_t** list, size_t* len, struct passwd* pwd)
 {
-	size_t n = 0;
-	int ngroups = 0;
+    size_t n       = 0;
+    int    ngroups = 0;
 
-	*len = 0;
-	*list = NULL;
+    *len           = 0;
+    *list          = NULL;
 
-	/* first let's get a supp. group count */
-	getgrouplist(pwd->pw_name, pwd->pw_gid, *list, &ngroups);
-	if (!ngroups)
-		return -1;
+    /* first let's get a supp. group count */
+    getgrouplist(pwd->pw_name, pwd->pw_gid, *list, &ngroups);
+    if (!ngroups) return -1;
 
-	*list = xcalloc(1, ngroups * sizeof(gid_t));
+    *list = xcalloc(1, ngroups * sizeof(gid_t));
 
-	/* now for the actual list of GIDs */
-	if (-1 == getgrouplist(pwd->pw_name, pwd->pw_gid, *list, &ngroups))
-		return -1;
+    /* now for the actual list of GIDs */
+    if (-1 == getgrouplist(pwd->pw_name, pwd->pw_gid, *list, &ngroups))
+        return -1;
 
-	*len = (size_t) ngroups;
+    *len = (size_t)ngroups;
 
-	/* getgroups also returns the user's primary GID - dispose of it */
-	while (n < *len) {
-		if ((*list)[n] == pwd->pw_gid)
-			break;
-		++n;
-	}
+    /* getgroups also returns the user's primary GID - dispose of it */
+    while (n < *len)
+    {
+        if ((*list)[n] == pwd->pw_gid) break;
+        ++n;
+    }
 
-	if (*len)
-		(*list)[n] = (*list)[--(*len)];
+    if (*len) (*list)[n] = (*list)[--(*len)];
 
-	return 0;
+    return 0;
 }
 
 static int get_nprocs(const uid_t uid)
 {
-	int nprocs = 0;
-	pid_t pid;
-	struct proc_processes *proc = proc_open_processes();
+    int                    nprocs = 0;
+    pid_t                  pid;
+    struct proc_processes* proc = proc_open_processes();
 
-	proc_processes_filter_by_uid(proc, uid);
+    proc_processes_filter_by_uid(proc, uid);
 
-	while (!proc_next_pid(proc, &pid))
-		++nprocs;
+    while (!proc_next_pid(proc, &pid)) ++nprocs;
 
-	proc_close_processes(proc);
-	return nprocs;
+    proc_close_processes(proc);
+    return nprocs;
 }
 
-static const char *get_pwd_method(const char *str, const char **next, unsigned int *sz)
+static const char* get_pwd_method(const char* str, const char** next,
+                                  unsigned int* sz)
 {
-	const char *p = str;
-	const char *res = NULL;
-
-	if (!p || *p++ != '$')
-		return NULL;
-
-	if (sz)
-		*sz = 0;
-
-	switch (*p) {
-	case '1':
-		res = "MD5";
-		if (sz)
-			*sz = 22;
-		break;
-	case '2':
-		p++;
-		if (*p == 'a' || *p == 'y')
-			res = "Blowfish";
-		break;
-	case '5':
-		res = "SHA-256";
-		if (sz)
-			*sz = 43;
-		break;
-	case '6':
-		res = "SHA-512";
-		if (sz)
-			*sz = 86;
-		break;
-	default:
-		return NULL;
-	}
-	p++;
-
-	if (*p != '$')
-		return NULL;
-	if (next)
-		*next = ++p;
-	return res;
+    const char* p   = str;
+    const char* res = NULL;
+
+    if (!p || *p++ != '$') return NULL;
+
+    if (sz) *sz = 0;
+
+    switch (*p)
+    {
+        case '1':
+            res = "MD5";
+            if (sz) *sz = 22;
+            break;
+        case '2':
+            p++;
+            if (*p == 'a' || *p == 'y') res = "Blowfish";
+            break;
+        case '5':
+            res = "SHA-256";
+            if (sz) *sz = 43;
+            break;
+        case '6':
+            res = "SHA-512";
+            if (sz) *sz = 86;
+            break;
+        default: return NULL;
+    }
+    p++;
+
+    if (*p != '$') return NULL;
+    if (next) *next = ++p;
+    return res;
 }
 
-#define is_valid_pwd_char(x)	(isalnum((unsigned char) (x)) || (x) ==  '.' || (x) == '/')
+#define is_valid_pwd_char(x)                                                   \
+    (isalnum((unsigned char)(x)) || (x) == '.' || (x) == '/')
 
 /*
  * This function do not accept empty passwords or locked accouns.
  */
-static int valid_pwd(const char *str)
+static int valid_pwd(const char* str)
 {
-	const char *p = str;
-	unsigned int sz = 0, n;
-
-	if (!str || !*str)
-		return 0;
-
-	/* $id$ */
-	if (get_pwd_method(str, &p, &sz) == NULL)
-		return 0;
-	if (!p || !*p)
-		return 0;
-
-	/* salt$ */
-	for (; *p; p++) {
-		if (*p == '$') {
-			p++;
-			break;
-		}
-		if (!is_valid_pwd_char(*p))
-			return 0;
-	}
-	if (!*p)
-		return 0;
-
-	/* encrypted */
-	for (n = 0; *p; p++, n++) {
-		if (!is_valid_pwd_char(*p))
-			return 0;
-	}
-
-	if (sz && n != sz)
-		return 0;
-	return 1;
+    const char*  p  = str;
+    unsigned int sz = 0, n;
+
+    if (!str || !*str) return 0;
+
+    /* $id$ */
+    if (get_pwd_method(str, &p, &sz) == NULL) return 0;
+    if (!p || !*p) return 0;
+
+    /* salt$ */
+    for (; *p; p++)
+    {
+        if (*p == '$')
+        {
+            p++;
+            break;
+        }
+        if (!is_valid_pwd_char(*p)) return 0;
+    }
+    if (!*p) return 0;
+
+    /* encrypted */
+    for (n = 0; *p; p++, n++)
+    {
+        if (!is_valid_pwd_char(*p)) return 0;
+    }
+
+    if (sz && n != sz) return 0;
+    return 1;
 }
 
-static struct lslogins_user *get_user_info(struct lslogins_control *ctl, const char *username)
+static struct lslogins_user* get_user_info(struct lslogins_control* ctl,
+                                           const char*              username)
 {
-	struct lslogins_user *user;
-	struct passwd *pwd;
-	struct group *grp;
-	struct spwd *shadow;
-	struct utmpx *user_wtmp = NULL, *user_btmp = NULL;
-	size_t n = 0;
-	time_t time;
-	uid_t uid;
-	errno = 0;
-
-	errno = 0;
-	pwd = username ? getpwnam(username) : getpwent();
-	if (!pwd)
-		return NULL;
-
-	ctl->uid = uid = pwd->pw_uid;
-
-	/* nfsnobody is an exception to the UID_MAX limit.  This is "nobody" on
-	 * some systems; the decisive point is the UID - 65534 */
-	if ((lslogins_flag & F_USRAC) &&
-	    strcmp("nfsnobody", pwd->pw_name) != 0 &&
-	    uid != 0) {
-		if (uid < ctl->UID_MIN || uid > ctl->UID_MAX) {
-			errno = EAGAIN;
-			return NULL;
-		}
-
-	} else if ((lslogins_flag & F_SYSAC) &&
-		   (uid < ctl->SYS_UID_MIN || uid > ctl->SYS_UID_MAX)) {
-		errno = EAGAIN;
-		return NULL;
-	}
-
-	errno = 0;
-	grp = getgrgid(pwd->pw_gid);
-	if (!grp)
-		return NULL;
-
-	user = xcalloc(1, sizeof(struct lslogins_user));
-
-	if (ctl->wtmp)
-		user_wtmp = get_last_wtmp(ctl, pwd->pw_name);
-	if (ctl->btmp)
-		user_btmp = get_last_btmp(ctl, pwd->pw_name);
-
-	lckpwdf();
-	shadow = getspnam(pwd->pw_name);
-	ulckpwdf();
-
-	/* required  by tseach() stuff */
-	user->uid = pwd->pw_uid;
-
-	while (n < ncolumns) {
-		switch (columns[n++]) {
-		case COL_USER:
-			user->login = xstrdup(pwd->pw_name);
-			break;
-		case COL_UID:
-			user->uid = pwd->pw_uid;
-			break;
-		case COL_GROUP:
-			user->group = xstrdup(grp->gr_name);
-			break;
-		case COL_GID:
-			user->gid = pwd->pw_gid;
-			break;
-		case COL_SGROUPS:
-		case COL_SGIDS:
-			if (get_sgroups(&user->sgroups, &user->nsgroups, pwd))
-				err(EXIT_FAILURE, _("failed to get supplementary groups"));
-			break;
-		case COL_HOME:
-			user->homedir = xstrdup(pwd->pw_dir);
-			break;
-		case COL_SHELL:
-			user->shell = xstrdup(pwd->pw_shell);
-			break;
-		case COL_GECOS:
-			user->gecos = xstrdup(pwd->pw_gecos);
-			break;
-		case COL_LAST_LOGIN:
-			if (user_wtmp) {
-				time = user_wtmp->ut_tv.tv_sec;
-				user->last_login = make_time(ctl->time_mode, time);
-			} else {
-				time = 0;
-				get_lastlog(ctl, pwd->pw_uid, &time, LASTLOG_TIME);
-				if (time)
-					user->last_login = make_time(ctl->time_mode, time);
-			}
-			break;
-		case COL_LAST_TTY:
-			user->last_tty = xcalloc(1, sizeof(user_wtmp->ut_line) + 1);
-			if (user_wtmp) {
-				mem2strcpy(user->last_tty, user_wtmp->ut_line,
-						sizeof(user_wtmp->ut_line),
-						sizeof(user_wtmp->ut_line) + 1);;
-			}  else
-				get_lastlog(ctl, user->uid, user->last_tty, LASTLOG_LINE);
-			break;
-		case COL_LAST_HOSTNAME:
-			user->last_hostname = xcalloc(1, sizeof(user_wtmp->ut_host) + 1);
-			if (user_wtmp) {
-				mem2strcpy(user->last_hostname, user_wtmp->ut_host,
-						sizeof(user_wtmp->ut_host),
-						sizeof(user_wtmp->ut_host) + 1);;
-			}  else
-				get_lastlog(ctl, user->uid, user->last_hostname, LASTLOG_HOST);
-			break;
-		case COL_FAILED_LOGIN:
-			if (user_btmp) {
-				time = user_btmp->ut_tv.tv_sec;
-				user->failed_login = make_time(ctl->time_mode, time);
-			}
-			break;
-		case COL_FAILED_TTY:
-			if (user_btmp) {
-				user->failed_tty = xmalloc(sizeof(user_btmp->ut_line) + 1);
-				mem2strcpy(user->failed_tty, user_btmp->ut_line,
-						sizeof(user_btmp->ut_line),
-						sizeof(user_btmp->ut_line) + 1);;
-			}
-			break;
-		case COL_HUSH_STATUS:
-			user->hushed = get_hushlogin_status(pwd, 0);
-			if (user->hushed == -1)
-				user->hushed = STATUS_UNKNOWN;
-			break;
-		case COL_PWDEMPTY:
-			if (shadow) {
-				if (!*shadow->sp_pwdp) /* '\0' */
-					user->pwd_empty = STATUS_TRUE;
-			} else
-				user->pwd_empty = STATUS_UNKNOWN;
-			break;
-		case COL_PWDDENY:
-			if (shadow) {
-				if ((*shadow->sp_pwdp == '!' ||
-				     *shadow->sp_pwdp == '*') &&
-				    !valid_pwd(shadow->sp_pwdp + 1))
-					user->pwd_deny = STATUS_TRUE;
-			} else
-				user->pwd_deny = STATUS_UNKNOWN;
-			break;
-		case COL_PWDLOCK:
-			if (shadow) {
-				if (*shadow->sp_pwdp == '!' && valid_pwd(shadow->sp_pwdp + 1))
-					user->pwd_lock = STATUS_TRUE;
-			} else
-				user->pwd_lock = STATUS_UNKNOWN;
-			break;
-		case COL_PWDMETHOD:
-			if (shadow) {
-				const char *p = shadow->sp_pwdp;
-
-				if (*p == '!' || *p == '*')
-					p++;
-				user->pwd_method = get_pwd_method(p, NULL, NULL);
-			} else
-				user->pwd_method = NULL;
-			break;
-		case COL_NOLOGIN:
-			if (strstr(pwd->pw_shell, "nologin"))
-				user->nologin = 1;
-			else if (pwd->pw_uid)
-				user->nologin = access(_PATH_NOLOGIN, F_OK) == 0 ||
-						access(_PATH_VAR_NOLOGIN, F_OK) == 0;
-			break;
-		case COL_PWD_WARN:
-			if (shadow && shadow->sp_warn >= 0)
-				xasprintf(&user->pwd_warn, "%ld", shadow->sp_warn);
-			break;
-		case COL_PWD_EXPIR:
-			if (shadow && shadow->sp_expire >= 0)
-				user->pwd_expire = make_time(ctl->time_mode == TIME_ISO ?
-						TIME_ISO_SHORT : ctl->time_mode,
-						shadow->sp_expire * 86400);
-			break;
-		case COL_PWD_CTIME:
-			/* sp_lstchg is specified in days, showing hours
-			 * (especially in non-GMT timezones) would only serve
-			 * to confuse */
-			if (shadow)
-				user->pwd_ctime = make_time(ctl->time_mode == TIME_ISO ?
-						TIME_ISO_SHORT : ctl->time_mode,
-						shadow->sp_lstchg * 86400);
-			break;
-		case COL_PWD_CTIME_MIN:
-			if (shadow && shadow->sp_min > 0)
-				xasprintf(&user->pwd_ctime_min, "%ld", shadow->sp_min);
-			break;
-		case COL_PWD_CTIME_MAX:
-			if (shadow && shadow->sp_max > 0)
-				xasprintf(&user->pwd_ctime_max, "%ld", shadow->sp_max);
-			break;
-		case COL_SELINUX:
+    struct lslogins_user* user;
+    struct passwd*        pwd;
+    struct group*         grp;
+    struct spwd*          shadow;
+    struct utmpx *        user_wtmp = NULL, *user_btmp = NULL;
+    size_t                n = 0;
+    time_t                time;
+    uid_t                 uid;
+    errno = 0;
+
+    errno = 0;
+    pwd   = username ? getpwnam(username) : getpwent();
+    if (!pwd) return NULL;
+
+    ctl->uid = uid = pwd->pw_uid;
+
+    /* nfsnobody is an exception to the UID_MAX limit.  This is "nobody" on
+     * some systems; the decisive point is the UID - 65534 */
+    if ((lslogins_flag & F_USRAC) && strcmp("nfsnobody", pwd->pw_name) != 0
+        && uid != 0)
+    {
+        if (uid < ctl->UID_MIN || uid > ctl->UID_MAX)
+        {
+            errno = EAGAIN;
+            return NULL;
+        }
+    }
+    else if ((lslogins_flag & F_SYSAC)
+             && (uid < ctl->SYS_UID_MIN || uid > ctl->SYS_UID_MAX))
+    {
+        errno = EAGAIN;
+        return NULL;
+    }
+
+    errno = 0;
+    grp   = getgrgid(pwd->pw_gid);
+    if (!grp) return NULL;
+
+    user = xcalloc(1, sizeof(struct lslogins_user));
+
+    if (ctl->wtmp) user_wtmp = get_last_wtmp(ctl, pwd->pw_name);
+    if (ctl->btmp) user_btmp = get_last_btmp(ctl, pwd->pw_name);
+
+    lckpwdf();
+    shadow = getspnam(pwd->pw_name);
+    ulckpwdf();
+
+    /* required  by tseach() stuff */
+    user->uid = pwd->pw_uid;
+
+    while (n < ncolumns)
+    {
+        switch (columns[n++])
+        {
+            case COL_USER: user->login = xstrdup(pwd->pw_name); break;
+            case COL_UID: user->uid = pwd->pw_uid; break;
+            case COL_GROUP: user->group = xstrdup(grp->gr_name); break;
+            case COL_GID: user->gid = pwd->pw_gid; break;
+            case COL_SGROUPS:
+            case COL_SGIDS:
+                if (get_sgroups(&user->sgroups, &user->nsgroups, pwd))
+                    err(EXIT_FAILURE, _("failed to get supplementary groups"));
+                break;
+            case COL_HOME: user->homedir = xstrdup(pwd->pw_dir); break;
+            case COL_SHELL: user->shell = xstrdup(pwd->pw_shell); break;
+            case COL_GECOS: user->gecos = xstrdup(pwd->pw_gecos); break;
+            case COL_LAST_LOGIN:
+                if (user_wtmp)
+                {
+                    time             = user_wtmp->ut_tv.tv_sec;
+                    user->last_login = make_time(ctl->time_mode, time);
+                }
+                else
+                {
+                    time = 0;
+                    get_lastlog(ctl, pwd->pw_uid, &time, LASTLOG_TIME);
+                    if (time)
+                        user->last_login = make_time(ctl->time_mode, time);
+                }
+                break;
+            case COL_LAST_TTY:
+                user->last_tty = xcalloc(1, sizeof(user_wtmp->ut_line) + 1);
+                if (user_wtmp)
+                {
+                    mem2strcpy(user->last_tty, user_wtmp->ut_line,
+                               sizeof(user_wtmp->ut_line),
+                               sizeof(user_wtmp->ut_line) + 1);
+                    ;
+                }
+                else get_lastlog(ctl, user->uid, user->last_tty, LASTLOG_LINE);
+                break;
+            case COL_LAST_HOSTNAME:
+                user->last_hostname
+                    = xcalloc(1, sizeof(user_wtmp->ut_host) + 1);
+                if (user_wtmp)
+                {
+                    mem2strcpy(user->last_hostname, user_wtmp->ut_host,
+                               sizeof(user_wtmp->ut_host),
+                               sizeof(user_wtmp->ut_host) + 1);
+                    ;
+                }
+                else
+                    get_lastlog(ctl, user->uid, user->last_hostname,
+                                LASTLOG_HOST);
+                break;
+            case COL_FAILED_LOGIN:
+                if (user_btmp)
+                {
+                    time               = user_btmp->ut_tv.tv_sec;
+                    user->failed_login = make_time(ctl->time_mode, time);
+                }
+                break;
+            case COL_FAILED_TTY:
+                if (user_btmp)
+                {
+                    user->failed_tty = xmalloc(sizeof(user_btmp->ut_line) + 1);
+                    mem2strcpy(user->failed_tty, user_btmp->ut_line,
+                               sizeof(user_btmp->ut_line),
+                               sizeof(user_btmp->ut_line) + 1);
+                    ;
+                }
+                break;
+            case COL_HUSH_STATUS:
+                user->hushed = get_hushlogin_status(pwd, 0);
+                if (user->hushed == -1) user->hushed = STATUS_UNKNOWN;
+                break;
+            case COL_PWDEMPTY:
+                if (shadow)
+                {
+                    if (!*shadow->sp_pwdp) /* '\0' */
+                        user->pwd_empty = STATUS_TRUE;
+                }
+                else user->pwd_empty = STATUS_UNKNOWN;
+                break;
+            case COL_PWDDENY:
+                if (shadow)
+                {
+                    if ((*shadow->sp_pwdp == '!' || *shadow->sp_pwdp == '*')
+                        && !valid_pwd(shadow->sp_pwdp + 1))
+                        user->pwd_deny = STATUS_TRUE;
+                }
+                else user->pwd_deny = STATUS_UNKNOWN;
+                break;
+            case COL_PWDLOCK:
+                if (shadow)
+                {
+                    if (*shadow->sp_pwdp == '!'
+                        && valid_pwd(shadow->sp_pwdp + 1))
+                        user->pwd_lock = STATUS_TRUE;
+                }
+                else user->pwd_lock = STATUS_UNKNOWN;
+                break;
+            case COL_PWDMETHOD:
+                if (shadow)
+                {
+                    const char* p = shadow->sp_pwdp;
+
+                    if (*p == '!' || *p == '*') p++;
+                    user->pwd_method = get_pwd_method(p, NULL, NULL);
+                }
+                else user->pwd_method = NULL;
+                break;
+            case COL_NOLOGIN:
+                if (strstr(pwd->pw_shell, "nologin")) user->nologin = 1;
+                else if (pwd->pw_uid)
+                    user->nologin = access(_PATH_NOLOGIN, F_OK) == 0
+                                 || access(_PATH_VAR_NOLOGIN, F_OK) == 0;
+                break;
+            case COL_PWD_WARN:
+                if (shadow && shadow->sp_warn >= 0)
+                    xasprintf(&user->pwd_warn, "%ld", shadow->sp_warn);
+                break;
+            case COL_PWD_EXPIR:
+                if (shadow && shadow->sp_expire >= 0)
+                    user->pwd_expire
+                        = make_time(ctl->time_mode == TIME_ISO ? TIME_ISO_SHORT
+                                                               : ctl->time_mode,
+                                    shadow->sp_expire * 86400);
+                break;
+            case COL_PWD_CTIME:
+                /* sp_lstchg is specified in days, showing hours
+                 * (especially in non-GMT timezones) would only serve
+                 * to confuse */
+                if (shadow)
+                    user->pwd_ctime
+                        = make_time(ctl->time_mode == TIME_ISO ? TIME_ISO_SHORT
+                                                               : ctl->time_mode,
+                                    shadow->sp_lstchg * 86400);
+                break;
+            case COL_PWD_CTIME_MIN:
+                if (shadow && shadow->sp_min > 0)
+                    xasprintf(&user->pwd_ctime_min, "%ld", shadow->sp_min);
+                break;
+            case COL_PWD_CTIME_MAX:
+                if (shadow && shadow->sp_max > 0)
+                    xasprintf(&user->pwd_ctime_max, "%ld", shadow->sp_max);
+                break;
+            case COL_SELINUX:
 #ifdef HAVE_LIBSELINUX
-			if (ctl->selinux_enabled) {
-				/* typedefs and pointers are pure evil */
-				security_context_t con = NULL;
-				if (getcon(&con) == 0)
-					user->context = con;
-			}
+                if (ctl->selinux_enabled)
+                {
+                    /* typedefs and pointers are pure evil */
+                    security_context_t con = NULL;
+                    if (getcon(&con) == 0) user->context = con;
+                }
 #endif
-			break;
-		case COL_NPROCS:
-			xasprintf(&user->nprocs, "%d", get_nprocs(pwd->pw_uid));
-			break;
-		default:
-			/* something went very wrong here */
-			err(EXIT_FAILURE, "fatal: unknown error");
-			break;
-		}
-	}
-
-	return user;
+                break;
+            case COL_NPROCS:
+                xasprintf(&user->nprocs, "%d", get_nprocs(pwd->pw_uid));
+                break;
+            default:
+                /* something went very wrong here */
+                err(EXIT_FAILURE, "fatal: unknown error");
+                break;
+        }
+    }
+
+    return user;
 }
 
-static int str_to_uint(char *s, unsigned int *ul)
+static int str_to_uint(char* s, unsigned int* ul)
 {
-	char *end;
-	if (!s || !*s)
-		return -1;
-	*ul = strtoul(s, &end, 0);
-	if (!*end)
-		return 0;
-	return 1;
+    char* end;
+    if (!s || !*s) return -1;
+    *ul = strtoul(s, &end, 0);
+    if (!*end) return 0;
+    return 1;
 }
 
 /* get a definitive list of users we want info about... */
-static int get_ulist(struct lslogins_control *ctl, char *logins, char *groups)
+static int get_ulist(struct lslogins_control* ctl, char* logins, char* groups)
 {
-	char *u, *g;
-	size_t i = 0, n = 0, *arsiz;
-	struct group *grp;
-	struct passwd *pwd;
-	char ***ar;
-	uid_t uid;
-	gid_t gid;
-
-	ar = &ctl->ulist;
-	arsiz = &ctl->ulsiz;
-
-	/* an arbitrary starting value */
-	*arsiz = 32;
-	*ar = xcalloc(1, sizeof(char *) * (*arsiz));
-
-	if (logins) {
-		while ((u = strtok(logins, ","))) {
-			logins = NULL;
-
-			/* user specified by UID? */
-			if (!str_to_uint(u, &uid)) {
-				pwd = getpwuid(uid);
-				if (!pwd)
-					continue;
-				u = pwd->pw_name;
-			}
-			(*ar)[i++] = xstrdup(u);
-
-			if (i == *arsiz)
-				*ar = xrealloc(*ar, sizeof(char *) * (*arsiz += 32));
-		}
-		ctl->ulist_on = 1;
-	}
-
-	if (groups) {
-		/* FIXME: this might lead to duplicate entries, although not visible
-		 * in output, crunching a user's info multiple times is very redundant */
-		while ((g = strtok(groups, ","))) {
-			n = 0;
-			groups = NULL;
-
-			/* user specified by GID? */
-			if (!str_to_uint(g, &gid))
-				grp = getgrgid(gid);
-			else
-				grp = getgrnam(g);
-
-			if (!grp)
-				continue;
-
-			while ((u = grp->gr_mem[n++])) {
-				(*ar)[i++] = xstrdup(u);
-
-				if (i == *arsiz)
-					*ar = xrealloc(*ar, sizeof(char *) * (*arsiz += 32));
-			}
-		}
-		ctl->ulist_on = 1;
-	}
-	*arsiz = i;
-	return 0;
+    char *         u, *g;
+    size_t         i = 0, n = 0, *arsiz;
+    struct group*  grp;
+    struct passwd* pwd;
+    char***        ar;
+    uid_t          uid;
+    gid_t          gid;
+
+    ar     = &ctl->ulist;
+    arsiz  = &ctl->ulsiz;
+
+    /* an arbitrary starting value */
+    *arsiz = 32;
+    *ar    = xcalloc(1, sizeof(char*) * (*arsiz));
+
+    if (logins)
+    {
+        while ((u = strtok(logins, ",")))
+        {
+            logins = NULL;
+
+            /* user specified by UID? */
+            if (!str_to_uint(u, &uid))
+            {
+                pwd = getpwuid(uid);
+                if (!pwd) continue;
+                u = pwd->pw_name;
+            }
+            (*ar)[i++] = xstrdup(u);
+
+            if (i == *arsiz)
+                *ar = xrealloc(*ar, sizeof(char*) * (*arsiz += 32));
+        }
+        ctl->ulist_on = 1;
+    }
+
+    if (groups)
+    {
+        /* FIXME: this might lead to duplicate entries, although not visible
+         * in output, crunching a user's info multiple times is very redundant
+         */
+        while ((g = strtok(groups, ",")))
+        {
+            n      = 0;
+            groups = NULL;
+
+            /* user specified by GID? */
+            if (!str_to_uint(g, &gid)) grp = getgrgid(gid);
+            else grp = getgrnam(g);
+
+            if (!grp) continue;
+
+            while ((u = grp->gr_mem[n++]))
+            {
+                (*ar)[i++] = xstrdup(u);
+
+                if (i == *arsiz)
+                    *ar = xrealloc(*ar, sizeof(char*) * (*arsiz += 32));
+            }
+        }
+        ctl->ulist_on = 1;
+    }
+    *arsiz = i;
+    return 0;
 }
 
-static void free_ctl(struct lslogins_control *ctl)
+static void free_ctl(struct lslogins_control* ctl)
 {
-	size_t n = 0;
+    size_t n = 0;
 
-	free(ctl->wtmp);
-	free(ctl->btmp);
+    free(ctl->wtmp);
+    free(ctl->btmp);
 
-	while (n < ctl->ulsiz)
-		free(ctl->ulist[n++]);
+    while (n < ctl->ulsiz) free(ctl->ulist[n++]);
 
-	free(ctl->ulist);
-	free(ctl);
+    free(ctl->ulist);
+    free(ctl);
 }
 
-static struct lslogins_user *get_next_user(struct lslogins_control *ctl)
+static struct lslogins_user* get_next_user(struct lslogins_control* ctl)
 {
-	struct lslogins_user *u;
-	errno = 0;
-	while (!(u = get_user_info(ctl, NULL))) {
-		/* no "false" errno-s here, iff we're unable to
-		 * get a valid user entry for any reason, quit */
-		if (errno == EAGAIN)
-			continue;
-		return NULL;
-	}
-	return u;
+    struct lslogins_user* u;
+    errno = 0;
+    while (!(u = get_user_info(ctl, NULL)))
+    {
+        /* no "false" errno-s here, iff we're unable to
+         * get a valid user entry for any reason, quit */
+        if (errno == EAGAIN) continue;
+        return NULL;
+    }
+    return u;
 }
 
 /* some UNIX implementations set errno iff a passwd/grp/...
  * entry was not found. The original UNIX logins(1) utility always
  * ignores invalid login/group names, so we're going to as well.*/
-#define IS_REAL_ERRNO(e) !((e) == ENOENT || (e) == ESRCH || \
-		(e) == EBADF || (e) == EPERM || (e) == EAGAIN)
+#define IS_REAL_ERRNO(e)                                                       \
+    !((e) == ENOENT || (e) == ESRCH || (e) == EBADF || (e) == EPERM            \
+      || (e) == EAGAIN)
 
-static int get_user(struct lslogins_control *ctl, struct lslogins_user **user,
-		    const char *username)
+static int get_user(struct lslogins_control* ctl, struct lslogins_user** user,
+                    const char* username)
 {
-	*user = get_user_info(ctl, username);
-	if (!*user && IS_REAL_ERRNO(errno))
-		return -1;
-	return 0;
+    *user = get_user_info(ctl, username);
+    if (!*user && IS_REAL_ERRNO(errno)) return -1;
+    return 0;
 }
 
-static int cmp_uid(const void *a, const void *b)
+static int cmp_uid(const void* a, const void* b)
 {
-	uid_t x = ((const struct lslogins_user *)a)->uid;
-	uid_t z = ((const struct lslogins_user *)b)->uid;
-	return x > z ? 1 : (x < z ? -1 : 0);
+    uid_t x = ((const struct lslogins_user*)a)->uid;
+    uid_t z = ((const struct lslogins_user*)b)->uid;
+    return x > z ? 1 : (x < z ? -1 : 0);
 }
 
-static int create_usertree(struct lslogins_control *ctl)
+static int create_usertree(struct lslogins_control* ctl)
 {
-	struct lslogins_user *user = NULL;
-	size_t n = 0;
-
-	if (ctl->ulist_on) {
-		for (n = 0; n < ctl->ulsiz; n++) {
-			int rc = get_user(ctl, &user, ctl->ulist[n]);
-
-			if (ctl->fail_on_unknown && !user) {
-				warnx(_("cannot found '%s'"), ctl->ulist[n]);
-				return -1;
-			}
-			if (rc || !user)
-				continue;
-
-			tsearch(user, &ctl->usertree, cmp_uid);
-		}
-	} else {
-		while ((user = get_next_user(ctl)))
-			tsearch(user, &ctl->usertree, cmp_uid);
-	}
-	return 0;
+    struct lslogins_user* user = NULL;
+    size_t                n    = 0;
+
+    if (ctl->ulist_on)
+    {
+        for (n = 0; n < ctl->ulsiz; n++)
+        {
+            int rc = get_user(ctl, &user, ctl->ulist[n]);
+
+            if (ctl->fail_on_unknown && !user)
+            {
+                warnx(_("cannot found '%s'"), ctl->ulist[n]);
+                return -1;
+            }
+            if (rc || !user) continue;
+
+            tsearch(user, &ctl->usertree, cmp_uid);
+        }
+    }
+    else
+    {
+        while ((user = get_next_user(ctl)))
+            tsearch(user, &ctl->usertree, cmp_uid);
+    }
+    return 0;
 }
 
-static struct libscols_table *setup_table(struct lslogins_control *ctl)
+static struct libscols_table* setup_table(struct lslogins_control* ctl)
 {
-	struct libscols_table *table = scols_new_table();
-	size_t n = 0;
-
-	if (!table)
-		err(EXIT_FAILURE, _("failed to allocate output table"));
-	if (ctl->noheadings)
-		scols_table_enable_noheadings(table, 1);
-
-	switch(outmode) {
-	case OUT_COLON:
-		scols_table_enable_raw(table, 1);
-		scols_table_set_column_separator(table, ":");
-		break;
-	case OUT_NEWLINE:
-		scols_table_set_column_separator(table, "\n");
-		/* fallthrough */
-	case OUT_EXPORT:
-		scols_table_enable_export(table, 1);
-		break;
-	case OUT_NUL:
-		scols_table_set_line_separator(table, "\0");
-		/* fallthrough */
-	case OUT_RAW:
-		scols_table_enable_raw(table, 1);
-		break;
-	case OUT_PRETTY:
-		scols_table_enable_noheadings(table, 1);
-	default:
-		break;
-	}
-
-	while (n < ncolumns) {
-		int flags = coldescs[columns[n]].flag;
-
-		if (ctl->notrunc)
-			flags &= ~SCOLS_FL_TRUNC;
-
-		if (!scols_table_new_column(table,
-				coldescs[columns[n]].name,
-				coldescs[columns[n]].whint,
-				flags))
-			goto fail;
-		++n;
-	}
-
-	return table;
+    struct libscols_table* table = scols_new_table();
+    size_t                 n     = 0;
+
+    if (!table) err(EXIT_FAILURE, _("failed to allocate output table"));
+    if (ctl->noheadings) scols_table_enable_noheadings(table, 1);
+
+    switch (outmode)
+    {
+        case OUT_COLON:
+            scols_table_enable_raw(table, 1);
+            scols_table_set_column_separator(table, ":");
+            break;
+        case OUT_NEWLINE:
+            scols_table_set_column_separator(table, "\n");
+            /* fallthrough */
+        case OUT_EXPORT: scols_table_enable_export(table, 1); break;
+        case OUT_NUL:
+            scols_table_set_line_separator(table, "\0");
+            /* fallthrough */
+        case OUT_RAW: scols_table_enable_raw(table, 1); break;
+        case OUT_PRETTY: scols_table_enable_noheadings(table, 1);
+        default: break;
+    }
+
+    while (n < ncolumns)
+    {
+        int flags = coldescs[columns[n]].flag;
+
+        if (ctl->notrunc) flags &= ~SCOLS_FL_TRUNC;
+
+        if (!scols_table_new_column(table, coldescs[columns[n]].name,
+                                    coldescs[columns[n]].whint, flags))
+            goto fail;
+        ++n;
+    }
+
+    return table;
 fail:
-	scols_unref_table(table);
-	return NULL;
+    scols_unref_table(table);
+    return NULL;
 }
 
-static void fill_table(const void *u, const VISIT which, const int depth __attribute__((unused)))
+static void fill_table(const void* u, const VISIT which,
+                       const int depth __attribute__((unused)))
 {
-	struct libscols_line *ln;
-	const struct lslogins_user *user = *(struct lslogins_user * const *)u;
-	size_t n = 0;
-
-	if (which == preorder || which == endorder)
-		return;
-
-	ln = scols_table_new_line(tb, NULL);
-	if (!ln)
-		err(EXIT_FAILURE, _("failed to allocate output line"));
-
-	while (n < ncolumns) {
-		int rc = 0;
-
-		switch (columns[n]) {
-		case COL_USER:
-			rc = scols_line_set_data(ln, n, user->login);
-			break;
-		case COL_UID:
-			rc = scols_line_refer_data(ln, n, uidtostr(user->uid));
-			break;
-		case COL_PWDEMPTY:
-			rc = scols_line_set_data(ln, n, get_status(user->pwd_empty));
-			break;
-		case COL_NOLOGIN:
-			rc = scols_line_set_data(ln, n, get_status(user->nologin));
-			break;
-		case COL_PWDLOCK:
-			rc = scols_line_set_data(ln, n, get_status(user->pwd_lock));
-			break;
-		case COL_PWDDENY:
-			rc = scols_line_set_data(ln, n, get_status(user->pwd_deny));
-			break;
-		case COL_PWDMETHOD:
-			rc = scols_line_set_data(ln, n, user->pwd_method);
-			break;
-		case COL_GROUP:
-			rc = scols_line_set_data(ln, n, user->group);
-			break;
-		case COL_GID:
-			rc = scols_line_refer_data(ln, n, gidtostr(user->gid));
-			break;
-		case COL_SGROUPS:
-			rc = scols_line_refer_data(ln, n,
-				build_sgroups_string(user->sgroups,
-						     user->nsgroups,
-						     TRUE));
-			break;
-		case COL_SGIDS:
-			rc = scols_line_refer_data(ln, n,
-				build_sgroups_string(user->sgroups,
-						     user->nsgroups,
-						     FALSE));
-			break;
-		case COL_HOME:
-			rc = scols_line_set_data(ln, n, user->homedir);
-			break;
-		case COL_SHELL:
-			rc = scols_line_set_data(ln, n, user->shell);
-			break;
-		case COL_GECOS:
-			rc = scols_line_set_data(ln, n, user->gecos);
-			break;
-		case COL_LAST_LOGIN:
-			rc = scols_line_set_data(ln, n, user->last_login);
-			break;
-		case COL_LAST_TTY:
-			rc = scols_line_set_data(ln, n, user->last_tty);
-			break;
-		case COL_LAST_HOSTNAME:
-			rc = scols_line_set_data(ln, n, user->last_hostname);
-			break;
-		case COL_FAILED_LOGIN:
-			rc = scols_line_set_data(ln, n, user->failed_login);
-			break;
-		case COL_FAILED_TTY:
-			rc = scols_line_set_data(ln, n, user->failed_tty);
-			break;
-		case COL_HUSH_STATUS:
-			rc = scols_line_set_data(ln, n, get_status(user->hushed));
-			break;
-		case COL_PWD_WARN:
-			rc = scols_line_set_data(ln, n, user->pwd_warn);
-			break;
-		case COL_PWD_EXPIR:
-			rc = scols_line_set_data(ln, n, user->pwd_expire);
-			break;
-		case COL_PWD_CTIME:
-			rc = scols_line_set_data(ln, n, user->pwd_ctime);
-			break;
-		case COL_PWD_CTIME_MIN:
-			rc = scols_line_set_data(ln, n, user->pwd_ctime_min);
-			break;
-		case COL_PWD_CTIME_MAX:
-			rc = scols_line_set_data(ln, n, user->pwd_ctime_max);
-			break;
-		case COL_SELINUX:
+    struct libscols_line*       ln;
+    const struct lslogins_user* user = *(struct lslogins_user* const*)u;
+    size_t                      n    = 0;
+
+    if (which == preorder || which == endorder) return;
+
+    ln = scols_table_new_line(tb, NULL);
+    if (!ln) err(EXIT_FAILURE, _("failed to allocate output line"));
+
+    while (n < ncolumns)
+    {
+        int rc = 0;
+
+        switch (columns[n])
+        {
+            case COL_USER: rc = scols_line_set_data(ln, n, user->login); break;
+            case COL_UID:
+                rc = scols_line_refer_data(ln, n, uidtostr(user->uid));
+                break;
+            case COL_PWDEMPTY:
+                rc = scols_line_set_data(ln, n, get_status(user->pwd_empty));
+                break;
+            case COL_NOLOGIN:
+                rc = scols_line_set_data(ln, n, get_status(user->nologin));
+                break;
+            case COL_PWDLOCK:
+                rc = scols_line_set_data(ln, n, get_status(user->pwd_lock));
+                break;
+            case COL_PWDDENY:
+                rc = scols_line_set_data(ln, n, get_status(user->pwd_deny));
+                break;
+            case COL_PWDMETHOD:
+                rc = scols_line_set_data(ln, n, user->pwd_method);
+                break;
+            case COL_GROUP: rc = scols_line_set_data(ln, n, user->group); break;
+            case COL_GID:
+                rc = scols_line_refer_data(ln, n, gidtostr(user->gid));
+                break;
+            case COL_SGROUPS:
+                rc = scols_line_refer_data(
+                    ln, n,
+                    build_sgroups_string(user->sgroups, user->nsgroups, TRUE));
+                break;
+            case COL_SGIDS:
+                rc = scols_line_refer_data(
+                    ln, n,
+                    build_sgroups_string(user->sgroups, user->nsgroups, FALSE));
+                break;
+            case COL_HOME:
+                rc = scols_line_set_data(ln, n, user->homedir);
+                break;
+            case COL_SHELL: rc = scols_line_set_data(ln, n, user->shell); break;
+            case COL_GECOS: rc = scols_line_set_data(ln, n, user->gecos); break;
+            case COL_LAST_LOGIN:
+                rc = scols_line_set_data(ln, n, user->last_login);
+                break;
+            case COL_LAST_TTY:
+                rc = scols_line_set_data(ln, n, user->last_tty);
+                break;
+            case COL_LAST_HOSTNAME:
+                rc = scols_line_set_data(ln, n, user->last_hostname);
+                break;
+            case COL_FAILED_LOGIN:
+                rc = scols_line_set_data(ln, n, user->failed_login);
+                break;
+            case COL_FAILED_TTY:
+                rc = scols_line_set_data(ln, n, user->failed_tty);
+                break;
+            case COL_HUSH_STATUS:
+                rc = scols_line_set_data(ln, n, get_status(user->hushed));
+                break;
+            case COL_PWD_WARN:
+                rc = scols_line_set_data(ln, n, user->pwd_warn);
+                break;
+            case COL_PWD_EXPIR:
+                rc = scols_line_set_data(ln, n, user->pwd_expire);
+                break;
+            case COL_PWD_CTIME:
+                rc = scols_line_set_data(ln, n, user->pwd_ctime);
+                break;
+            case COL_PWD_CTIME_MIN:
+                rc = scols_line_set_data(ln, n, user->pwd_ctime_min);
+                break;
+            case COL_PWD_CTIME_MAX:
+                rc = scols_line_set_data(ln, n, user->pwd_ctime_max);
+                break;
+            case COL_SELINUX:
 #ifdef HAVE_LIBSELINUX
-			rc = scols_line_set_data(ln, n, user->context);
+                rc = scols_line_set_data(ln, n, user->context);
 #endif
-			break;
-		case COL_NPROCS:
-			rc = scols_line_set_data(ln, n, user->nprocs);
-			break;
-		default:
-			/* something went very wrong here */
-			err(EXIT_FAILURE, _("internal error: unknown column"));
-		}
-
-		if (rc)
-			err(EXIT_FAILURE, _("failed to add output data"));
-		++n;
-	}
+                break;
+            case COL_NPROCS:
+                rc = scols_line_set_data(ln, n, user->nprocs);
+                break;
+            default:
+                /* something went very wrong here */
+                err(EXIT_FAILURE, _("internal error: unknown column"));
+        }
+
+        if (rc) err(EXIT_FAILURE, _("failed to add output data"));
+        ++n;
+    }
 }
 #ifdef HAVE_LIBSYSTEMD
-static void print_journal_tail(const char *journal_path, uid_t uid, size_t len, int time_mode)
+static void print_journal_tail(const char* journal_path, uid_t uid, size_t len,
+                               int time_mode)
 {
-	sd_journal *j;
-	char *match, *timestamp;
-	uint64_t x;
-	time_t t;
-	const char *identifier, *pid, *message;
-	size_t identifier_len, pid_len, message_len;
-
-	if (journal_path)
-		sd_journal_open_directory(&j, journal_path, 0);
-	else
-		sd_journal_open(&j, SD_JOURNAL_LOCAL_ONLY);
-
-	xasprintf(&match, "_UID=%d", uid);
-
-	sd_journal_add_match(j, match, 0);
-	sd_journal_seek_tail(j);
-	sd_journal_previous_skip(j, len);
-
-	do {
-		if (0 > sd_journal_get_data(j, "SYSLOG_IDENTIFIER",
-				(const void **) &identifier, &identifier_len))
-			goto done;
-		if (0 > sd_journal_get_data(j, "_PID",
-				(const void **) &pid, &pid_len))
-			goto done;
-		if (0 > sd_journal_get_data(j, "MESSAGE",
-				(const void **) &message, &message_len))
-			goto done;
-
-		sd_journal_get_realtime_usec(j, &x);
-		t = x / 1000000;
-		timestamp = make_time(time_mode, t);
-		/* Get rid of journal entry field identifiers */
-		identifier = strchr(identifier, '=') + 1;
-		pid = strchr(pid, '=') + 1;
-		message = strchr(message, '=') + 1;
-
-		fprintf(stdout, "%s %s[%s]: %s\n", timestamp, identifier, pid,
-			message);
-		free(timestamp);
-	} while (sd_journal_next(j));
+    sd_journal* j;
+    char *      match, *timestamp;
+    uint64_t    x;
+    time_t      t;
+    const char *identifier, *pid, *message;
+    size_t      identifier_len, pid_len, message_len;
+
+    if (journal_path) sd_journal_open_directory(&j, journal_path, 0);
+    else sd_journal_open(&j, SD_JOURNAL_LOCAL_ONLY);
+
+    xasprintf(&match, "_UID=%d", uid);
+
+    sd_journal_add_match(j, match, 0);
+    sd_journal_seek_tail(j);
+    sd_journal_previous_skip(j, len);
+
+    do {
+        if (0 > sd_journal_get_data(j, "SYSLOG_IDENTIFIER",
+                                    (const void**)&identifier, &identifier_len))
+            goto done;
+        if (0 > sd_journal_get_data(j, "_PID", (const void**)&pid, &pid_len))
+            goto done;
+        if (0 > sd_journal_get_data(j, "MESSAGE", (const void**)&message,
+                                    &message_len))
+            goto done;
+
+        sd_journal_get_realtime_usec(j, &x);
+        t          = x / 1000000;
+        timestamp  = make_time(time_mode, t);
+        /* Get rid of journal entry field identifiers */
+        identifier = strchr(identifier, '=') + 1;
+        pid        = strchr(pid, '=') + 1;
+        message    = strchr(message, '=') + 1;
+
+        fprintf(stdout, "%s %s[%s]: %s\n", timestamp, identifier, pid, message);
+        free(timestamp);
+    } while (sd_journal_next(j));
 
 done:
-	free(match);
-	sd_journal_flush_matches(j);
-	sd_journal_close(j);
+    free(match);
+    sd_journal_flush_matches(j);
+    sd_journal_close(j);
 }
 #endif
 
-static int print_pretty(struct libscols_table *table)
+static int print_pretty(struct libscols_table* table)
 {
-	struct libscols_iter *itr = scols_new_iter(SCOLS_ITER_FORWARD);
-	struct libscols_column *col;
-	struct libscols_cell *data;
-	struct libscols_line *ln;
-	const char *hstr, *dstr;
-	int n = 0;
-
-	ln = scols_table_get_line(table, 0);
-	while (!scols_table_next_column(table, itr, &col)) {
+    struct libscols_iter*   itr = scols_new_iter(SCOLS_ITER_FORWARD);
+    struct libscols_column* col;
+    struct libscols_cell*   data;
+    struct libscols_line*   ln;
+    const char *            hstr, *dstr;
+    int                     n = 0;
 
-		data = scols_line_get_cell(ln, n);
+    ln                        = scols_table_get_line(table, 0);
+    while (!scols_table_next_column(table, itr, &col))
+    {
 
-		hstr = _(coldescs[columns[n]].pretty_name);
-		dstr = scols_cell_get_data(data);
+        data = scols_line_get_cell(ln, n);
 
-		if (dstr)
-			printf("%s:%*c%-36s\n", hstr, 35 - (int)strlen(hstr), ' ', dstr);
-		++n;
-	}
+        hstr = _(coldescs[columns[n]].pretty_name);
+        dstr = scols_cell_get_data(data);
 
-	scols_free_iter(itr);
-	return 0;
+        if (dstr)
+            printf("%s:%*c%-36s\n", hstr, 35 - (int)strlen(hstr), ' ', dstr);
+        ++n;
+    }
 
+    scols_free_iter(itr);
+    return 0;
 }
 
-static int print_user_table(struct lslogins_control *ctl)
+static int print_user_table(struct lslogins_control* ctl)
 {
-	tb = setup_table(ctl);
-	if (!tb)
-		return -1;
+    tb = setup_table(ctl);
+    if (!tb) return -1;
 
-	twalk(ctl->usertree, fill_table);
-	if (outmode == OUT_PRETTY) {
-		print_pretty(tb);
+    twalk(ctl->usertree, fill_table);
+    if (outmode == OUT_PRETTY)
+    {
+        print_pretty(tb);
 #ifdef HAVE_LIBSYSTEMD
-		fprintf(stdout, _("\nLast logs:\n"));
-		print_journal_tail(ctl->journal_path, ctl->uid, 3, ctl->time_mode);
-		fputc('\n', stdout);
+        fprintf(stdout, _("\nLast logs:\n"));
+        print_journal_tail(ctl->journal_path, ctl->uid, 3, ctl->time_mode);
+        fputc('\n', stdout);
 #endif
-	} else
-		scols_print_table(tb);
-	return 0;
+    }
+    else scols_print_table(tb);
+    return 0;
 }
 
-static void free_user(void *f)
+static void free_user(void* f)
 {
-	struct lslogins_user *u = f;
-	free(u->login);
-	free(u->group);
-	free(u->gecos);
-	free(u->sgroups);
-	free(u->pwd_ctime);
-	free(u->pwd_warn);
-	free(u->pwd_ctime_min);
-	free(u->pwd_ctime_max);
-	free(u->last_login);
-	free(u->last_tty);
-	free(u->last_hostname);
-	free(u->failed_login);
-	free(u->failed_tty);
-	free(u->homedir);
-	free(u->shell);
-	free(u->pwd_status);
+    struct lslogins_user* u = f;
+    free(u->login);
+    free(u->group);
+    free(u->gecos);
+    free(u->sgroups);
+    free(u->pwd_ctime);
+    free(u->pwd_warn);
+    free(u->pwd_ctime_min);
+    free(u->pwd_ctime_max);
+    free(u->last_login);
+    free(u->last_tty);
+    free(u->last_hostname);
+    free(u->failed_login);
+    free(u->failed_tty);
+    free(u->homedir);
+    free(u->shell);
+    free(u->pwd_status);
 #ifdef HAVE_LIBSELINUX
-	freecon(u->context);
+    freecon(u->context);
 #endif
-	free(u);
+    free(u);
 }
 
-static int parse_time_mode(const char *s)
+static int parse_time_mode(const char* s)
 {
-	struct lslogins_timefmt {
-		const char *name;
-		const int val;
-	};
-	static const struct lslogins_timefmt timefmts[] = {
-		{"iso", TIME_ISO},
-		{"full", TIME_FULL},
-		{"short", TIME_SHORT},
-	};
-	size_t i;
-
-	for (i = 0; i < ARRAY_SIZE(timefmts); i++) {
-		if (strcmp(timefmts[i].name, s) == 0)
-			return timefmts[i].val;
-	}
-	errx(EXIT_FAILURE, _("unknown time format: %s"), s);
+    struct lslogins_timefmt
+    {
+        const char* name;
+        const int   val;
+    };
+    static const struct lslogins_timefmt timefmts[] = {
+        {"iso", TIME_ISO},
+        {"full", TIME_FULL},
+        {"short", TIME_SHORT},
+    };
+    size_t i;
+
+    for (i = 0; i < ARRAY_SIZE(timefmts); i++)
+    {
+        if (strcmp(timefmts[i].name, s) == 0) return timefmts[i].val;
+    }
+    errx(EXIT_FAILURE, _("unknown time format: %s"), s);
 }
 
 static void __attribute__((__noreturn__)) usage(void)
 {
-	FILE *out = stdout;
-	size_t i;
-
-	fputs(USAGE_HEADER, out);
-	fprintf(out, _(" %s [options] [<username>]\n"), program_invocation_short_name);
-
-	fputs(USAGE_SEPARATOR, out);
-	fputs(_("Display information about known users in the system.\n"), out);
-
-	fputs(USAGE_OPTIONS, out);
-	fputs(_(" -a, --acc-expiration     display info about passwords expiration\n"), out);
-	fputs(_(" -c, --colon-separate     display data in a format similar to /etc/passwd\n"), out);
-	fputs(_(" -e, --export             display in an export-able output format\n"), out);
-	fputs(_(" -f, --failed             display data about the users' last failed logins\n"), out);
-	fputs(_(" -G, --supp-groups        display information about groups\n"), out);
-	fputs(_(" -g, --groups=<groups>    display users belonging to a group in <groups>\n"), out);
-	fputs(_(" -L, --last               show info about the users' last login sessions\n"), out);
-	fputs(_(" -l, --logins=<logins>    display only users from <logins>\n"), out);
-	fputs(_(" -n, --newline            display each piece of information on a new line\n"), out);
-	fputs(_("     --noheadings         don't print headings\n"), out);
-	fputs(_("     --notruncate         don't truncate output\n"), out);
-	fputs(_(" -o, --output[=<list>]    define the columns to output\n"), out);
-	fputs(_("     --output-all         output all columns\n"), out);
-	fputs(_(" -p, --pwd                display information related to login by password.\n"), out);
-	fputs(_(" -r, --raw                display in raw mode\n"), out);
-	fputs(_(" -s, --system-accs        display system accounts\n"), out);
-	fputs(_("     --time-format=<type> display dates in short, full or iso format\n"), out);
-	fputs(_(" -u, --user-accs          display user accounts\n"), out);
-	fputs(_(" -Z, --context            display SELinux contexts\n"), out);
-	fputs(_(" -z, --print0             delimit user entries with a nul character\n"), out);
-	fputs(_("     --wtmp-file <path>   set an alternate path for wtmp\n"), out);
-	fputs(_("     --btmp-file <path>   set an alternate path for btmp\n"), out);
-	fputs(_("     --lastlog <path>     set an alternate path for lastlog\n"), out);
-	fputs(USAGE_SEPARATOR, out);
-	printf(USAGE_HELP_OPTIONS(26));
-
-	fputs(USAGE_COLUMNS, out);
-	for (i = 0; i < ARRAY_SIZE(coldescs); i++)
-		fprintf(out, " %14s  %s\n", coldescs[i].name, _(coldescs[i].help));
-
-	printf(USAGE_MAN_TAIL("lslogins(1)"));
-
-	exit(EXIT_SUCCESS);
+    FILE*  out = stdout;
+    size_t i;
+
+    fputs(USAGE_HEADER, out);
+    fprintf(out, _(" %s [options] [<username>]\n"),
+            program_invocation_short_name);
+
+    fputs(USAGE_SEPARATOR, out);
+    fputs(_("Display information about known users in the system.\n"), out);
+
+    fputs(USAGE_OPTIONS, out);
+    fputs(_(" -a, --acc-expiration     display info about passwords "
+            "expiration\n"),
+          out);
+    fputs(_(" -c, --colon-separate     display data in a format similar to "
+            "/etc/passwd\n"),
+          out);
+    fputs(_(" -e, --export             display in an export-able output "
+            "format\n"),
+          out);
+    fputs(_(" -f, --failed             display data about the users' last "
+            "failed logins\n"),
+          out);
+    fputs(_(" -G, --supp-groups        display information about groups\n"),
+          out);
+    fputs(_(" -g, --groups=<groups>    display users belonging to a group in "
+            "<groups>\n"),
+          out);
+    fputs(_(" -L, --last               show info about the users' last login "
+            "sessions\n"),
+          out);
+    fputs(_(" -l, --logins=<logins>    display only users from <logins>\n"),
+          out);
+    fputs(_(" -n, --newline            display each piece of information on a "
+            "new line\n"),
+          out);
+    fputs(_("     --noheadings         don't print headings\n"), out);
+    fputs(_("     --notruncate         don't truncate output\n"), out);
+    fputs(_(" -o, --output[=<list>]    define the columns to output\n"), out);
+    fputs(_("     --output-all         output all columns\n"), out);
+    fputs(_(" -p, --pwd                display information related to login by "
+            "password.\n"),
+          out);
+    fputs(_(" -r, --raw                display in raw mode\n"), out);
+    fputs(_(" -s, --system-accs        display system accounts\n"), out);
+    fputs(_("     --time-format=<type> display dates in short, full or iso "
+            "format\n"),
+          out);
+    fputs(_(" -u, --user-accs          display user accounts\n"), out);
+    fputs(_(" -Z, --context            display SELinux contexts\n"), out);
+    fputs(_(" -z, --print0             delimit user entries with a nul "
+            "character\n"),
+          out);
+    fputs(_("     --wtmp-file <path>   set an alternate path for wtmp\n"), out);
+    fputs(_("     --btmp-file <path>   set an alternate path for btmp\n"), out);
+    fputs(_("     --lastlog <path>     set an alternate path for lastlog\n"),
+          out);
+    fputs(USAGE_SEPARATOR, out);
+    printf(USAGE_HELP_OPTIONS(26));
+
+    fputs(USAGE_COLUMNS, out);
+    for (i = 0; i < ARRAY_SIZE(coldescs); i++)
+        fprintf(out, " %14s  %s\n", coldescs[i].name, _(coldescs[i].help));
+
+    printf(USAGE_MAN_TAIL("lslogins(1)"));
+
+    exit(EXIT_SUCCESS);
 }
 
-int main(int argc, char *argv[])
+int main(int argc, char* argv[])
 {
-	int c;
-	char *logins = NULL, *groups = NULL, *outarg = NULL;
-	char *path_lastlog = _PATH_LASTLOG, *path_wtmp = _PATH_WTMP, *path_btmp = _PATH_BTMP;
-	struct lslogins_control *ctl = xcalloc(1, sizeof(struct lslogins_control));
-	size_t i;
-
-	/* long only options. */
-	enum {
-		OPT_WTMP = CHAR_MAX + 1,
-		OPT_BTMP,
-		OPT_LASTLOG,
-		OPT_NOTRUNC,
-		OPT_NOHEAD,
-		OPT_TIME_FMT,
-		OPT_OUTPUT_ALL,
-	};
-
-	static const struct option longopts[] = {
-		{ "acc-expiration", no_argument,	0, 'a' },
-		{ "colon-separate", no_argument,	0, 'c' },
-		{ "export",         no_argument,	0, 'e' },
-		{ "failed",         no_argument,	0, 'f' },
-		{ "groups",         required_argument,	0, 'g' },
-		{ "help",           no_argument,	0, 'h' },
-		{ "logins",         required_argument,	0, 'l' },
-		{ "supp-groups",    no_argument,	0, 'G' },
-		{ "newline",        no_argument,	0, 'n' },
-		{ "notruncate",     no_argument,	0, OPT_NOTRUNC },
-		{ "noheadings",     no_argument,	0, OPT_NOHEAD },
-		{ "output",         required_argument,	0, 'o' },
-		{ "output-all",     no_argument,	0, OPT_OUTPUT_ALL },
-		{ "last",           no_argument,	0, 'L', },
-		{ "raw",            no_argument,	0, 'r' },
-		{ "system-accs",    no_argument,	0, 's' },
-		{ "time-format",    required_argument,	0, OPT_TIME_FMT },
-		{ "user-accs",      no_argument,	0, 'u' },
-		{ "version",        no_argument,	0, 'V' },
-		{ "pwd",            no_argument,	0, 'p' },
-		{ "print0",         no_argument,	0, 'z' },
-		{ "wtmp-file",      required_argument,	0, OPT_WTMP },
-		{ "btmp-file",      required_argument,	0, OPT_BTMP },
-		{ "lastlog-file",   required_argument,	0, OPT_LASTLOG },
+    int   c;
+    char *logins = NULL, *groups = NULL, *outarg = NULL;
+    char *path_lastlog = _PATH_LASTLOG, *path_wtmp = _PATH_WTMP,
+         *path_btmp              = _PATH_BTMP;
+    struct lslogins_control* ctl = xcalloc(1, sizeof(struct lslogins_control));
+    size_t                   i;
+
+    /* long only options. */
+    enum
+    {
+        OPT_WTMP = CHAR_MAX + 1,
+        OPT_BTMP,
+        OPT_LASTLOG,
+        OPT_NOTRUNC,
+        OPT_NOHEAD,
+        OPT_TIME_FMT,
+        OPT_OUTPUT_ALL,
+    };
+
+    static const struct option longopts[]
+        = {{"acc-expiration", no_argument, 0, 'a'},
+           {"colon-separate", no_argument, 0, 'c'},
+           {"export", no_argument, 0, 'e'},
+           {"failed", no_argument, 0, 'f'},
+           {"groups", required_argument, 0, 'g'},
+           {"help", no_argument, 0, 'h'},
+           {"logins", required_argument, 0, 'l'},
+           {"supp-groups", no_argument, 0, 'G'},
+           {"newline", no_argument, 0, 'n'},
+           {"notruncate", no_argument, 0, OPT_NOTRUNC},
+           {"noheadings", no_argument, 0, OPT_NOHEAD},
+           {"output", required_argument, 0, 'o'},
+           {"output-all", no_argument, 0, OPT_OUTPUT_ALL},
+           {
+               "last",
+               no_argument,
+               0,
+               'L',
+           },
+           {"raw", no_argument, 0, 'r'},
+           {"system-accs", no_argument, 0, 's'},
+           {"time-format", required_argument, 0, OPT_TIME_FMT},
+           {"user-accs", no_argument, 0, 'u'},
+           {"version", no_argument, 0, 'V'},
+           {"pwd", no_argument, 0, 'p'},
+           {"print0", no_argument, 0, 'z'},
+           {"wtmp-file", required_argument, 0, OPT_WTMP},
+           {"btmp-file", required_argument, 0, OPT_BTMP},
+           {"lastlog-file", required_argument, 0, OPT_LASTLOG},
 #ifdef HAVE_LIBSELINUX
-		{ "context",        no_argument,	0, 'Z' },
+           {"context", no_argument, 0, 'Z'},
 #endif
-		{ NULL,             0, 			0,  0  }
-	};
-
-	static const ul_excl_t excl[] = {	/* rows and cols in ASCII order */
-		{ 'G', 'o' },
-		{ 'L', 'o' },
-		{ 'Z', 'o' },
-		{ 'a', 'o' },
-		{ 'c','n','r','z' },
-		{ 'o', 'p' },
-		{ 0 }
-	};
-	int excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;
-
-	setlocale(LC_ALL, "");
-	bindtextdomain(PACKAGE, LOCALEDIR);
-	textdomain(PACKAGE);
-	close_stdout_atexit();
-
-	ctl->time_mode = TIME_SHORT;
-
-	/* very basic default */
-	add_column(columns, ncolumns++, COL_UID);
-	add_column(columns, ncolumns++, COL_USER);
-
-	while ((c = getopt_long(argc, argv, "acefGg:hLl:no:prsuVzZ",
-				longopts, NULL)) != -1) {
-
-		err_exclusive_options(c, longopts, excl, excl_st);
-
-		switch (c) {
-		case 'a':
-			add_column(columns, ncolumns++, COL_PWD_WARN);
-			add_column(columns, ncolumns++, COL_PWD_CTIME_MIN);
-			add_column(columns, ncolumns++, COL_PWD_CTIME_MAX);
-			add_column(columns, ncolumns++, COL_PWD_CTIME);
-			add_column(columns, ncolumns++, COL_PWD_EXPIR);
-			break;
-		case 'c':
-			outmode = OUT_COLON;
-			break;
-		case 'e':
-			outmode = OUT_EXPORT;
-			break;
-		case 'f':
-			add_column(columns, ncolumns++, COL_FAILED_LOGIN);
-			add_column(columns, ncolumns++, COL_FAILED_TTY);
-			break;
-		case 'G':
-			add_column(columns, ncolumns++, COL_GID);
-			add_column(columns, ncolumns++, COL_GROUP);
-			add_column(columns, ncolumns++, COL_SGIDS);
-			add_column(columns, ncolumns++, COL_SGROUPS);
-			break;
-		case 'g':
-			groups = optarg;
-			break;
-		case 'h':
-			usage();
-			break;
-		case 'L':
-			add_column(columns, ncolumns++, COL_LAST_TTY);
-			add_column(columns, ncolumns++, COL_LAST_HOSTNAME);
-			add_column(columns, ncolumns++, COL_LAST_LOGIN);
-			break;
-		case 'l':
-			logins = optarg;
-			break;
-		case 'n':
-			outmode = OUT_NEWLINE;
-			break;
-		case 'o':
-			if (*optarg == '=')
-				optarg++;
-			outarg = optarg;
-			break;
-		case OPT_OUTPUT_ALL:
-			for (ncolumns = 0; ncolumns < ARRAY_SIZE(coldescs); ncolumns++)
-				columns[ncolumns] = ncolumns;
-			break;
-		case 'r':
-			outmode = OUT_RAW;
-			break;
-		case 's':
-			ctl->SYS_UID_MIN = getlogindefs_num("SYS_UID_MIN", UL_SYS_UID_MIN);
-			ctl->SYS_UID_MAX = getlogindefs_num("SYS_UID_MAX", UL_SYS_UID_MAX);
-			lslogins_flag |= F_SYSAC;
-			break;
-		case 'u':
-			ctl->UID_MIN = getlogindefs_num("UID_MIN", UL_UID_MIN);
-			ctl->UID_MAX = getlogindefs_num("UID_MAX", UL_UID_MAX);
-			lslogins_flag |= F_USRAC;
-			break;
-		case 'p':
-			add_column(columns, ncolumns++, COL_PWDEMPTY);
-			add_column(columns, ncolumns++, COL_PWDLOCK);
-			add_column(columns, ncolumns++, COL_PWDDENY);
-			add_column(columns, ncolumns++, COL_NOLOGIN);
-			add_column(columns, ncolumns++, COL_HUSH_STATUS);
-			add_column(columns, ncolumns++, COL_PWDMETHOD);
-			break;
-		case 'z':
-			outmode = OUT_NUL;
-			break;
-		case OPT_LASTLOG:
-			path_lastlog = optarg;
-			break;
-		case OPT_WTMP:
-			path_wtmp = optarg;
-			break;
-		case OPT_BTMP:
-			path_btmp = optarg;
-			break;
-		case OPT_NOTRUNC:
-			ctl->notrunc = 1;
-			break;
-		case OPT_NOHEAD:
-			ctl->noheadings = 1;
-			break;
-		case OPT_TIME_FMT:
-			ctl->time_mode = parse_time_mode(optarg);
-			break;
-		case 'V':
-			print_version(EXIT_SUCCESS);
-		case 'Z':
-		{
+           {NULL, 0, 0, 0}};
+
+    static const ul_excl_t excl[]
+        = {/* rows and cols in ASCII order */
+           {'G', 'o'},           {'L', 'o'}, {'Z', 'o'}, {'a', 'o'},
+           {'c', 'n', 'r', 'z'}, {'o', 'p'}, {0}};
+    int excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;
+
+    setlocale(LC_ALL, "");
+    bindtextdomain(PACKAGE, LOCALEDIR);
+    textdomain(PACKAGE);
+    close_stdout_atexit();
+
+    ctl->time_mode = TIME_SHORT;
+
+    /* very basic default */
+    add_column(columns, ncolumns++, COL_UID);
+    add_column(columns, ncolumns++, COL_USER);
+
+    while (
+        (c = getopt_long(argc, argv, "acefGg:hLl:no:prsuVzZ", longopts, NULL))
+        != -1)
+    {
+
+        err_exclusive_options(c, longopts, excl, excl_st);
+
+        switch (c)
+        {
+            case 'a':
+                add_column(columns, ncolumns++, COL_PWD_WARN);
+                add_column(columns, ncolumns++, COL_PWD_CTIME_MIN);
+                add_column(columns, ncolumns++, COL_PWD_CTIME_MAX);
+                add_column(columns, ncolumns++, COL_PWD_CTIME);
+                add_column(columns, ncolumns++, COL_PWD_EXPIR);
+                break;
+            case 'c': outmode = OUT_COLON; break;
+            case 'e': outmode = OUT_EXPORT; break;
+            case 'f':
+                add_column(columns, ncolumns++, COL_FAILED_LOGIN);
+                add_column(columns, ncolumns++, COL_FAILED_TTY);
+                break;
+            case 'G':
+                add_column(columns, ncolumns++, COL_GID);
+                add_column(columns, ncolumns++, COL_GROUP);
+                add_column(columns, ncolumns++, COL_SGIDS);
+                add_column(columns, ncolumns++, COL_SGROUPS);
+                break;
+            case 'g': groups = optarg; break;
+            case 'h': usage(); break;
+            case 'L':
+                add_column(columns, ncolumns++, COL_LAST_TTY);
+                add_column(columns, ncolumns++, COL_LAST_HOSTNAME);
+                add_column(columns, ncolumns++, COL_LAST_LOGIN);
+                break;
+            case 'l': logins = optarg; break;
+            case 'n': outmode = OUT_NEWLINE; break;
+            case 'o':
+                if (*optarg == '=') optarg++;
+                outarg = optarg;
+                break;
+            case OPT_OUTPUT_ALL:
+                for (ncolumns = 0; ncolumns < ARRAY_SIZE(coldescs); ncolumns++)
+                    columns[ncolumns] = ncolumns;
+                break;
+            case 'r': outmode = OUT_RAW; break;
+            case 's':
+                ctl->SYS_UID_MIN
+                    = getlogindefs_num("SYS_UID_MIN", UL_SYS_UID_MIN);
+                ctl->SYS_UID_MAX
+                    = getlogindefs_num("SYS_UID_MAX", UL_SYS_UID_MAX);
+                lslogins_flag |= F_SYSAC;
+                break;
+            case 'u':
+                ctl->UID_MIN = getlogindefs_num("UID_MIN", UL_UID_MIN);
+                ctl->UID_MAX = getlogindefs_num("UID_MAX", UL_UID_MAX);
+                lslogins_flag |= F_USRAC;
+                break;
+            case 'p':
+                add_column(columns, ncolumns++, COL_PWDEMPTY);
+                add_column(columns, ncolumns++, COL_PWDLOCK);
+                add_column(columns, ncolumns++, COL_PWDDENY);
+                add_column(columns, ncolumns++, COL_NOLOGIN);
+                add_column(columns, ncolumns++, COL_HUSH_STATUS);
+                add_column(columns, ncolumns++, COL_PWDMETHOD);
+                break;
+            case 'z': outmode = OUT_NUL; break;
+            case OPT_LASTLOG: path_lastlog = optarg; break;
+            case OPT_WTMP: path_wtmp = optarg; break;
+            case OPT_BTMP: path_btmp = optarg; break;
+            case OPT_NOTRUNC: ctl->notrunc = 1; break;
+            case OPT_NOHEAD: ctl->noheadings = 1; break;
+            case OPT_TIME_FMT: ctl->time_mode = parse_time_mode(optarg); break;
+            case 'V': print_version(EXIT_SUCCESS);
+            case 'Z':
+            {
 #ifdef HAVE_LIBSELINUX
-			int sl = is_selinux_enabled();
-			if (sl < 0)
-				warn(_("failed to request selinux state"));
-			else
-				ctl->selinux_enabled = sl == 1;
+                int sl = is_selinux_enabled();
+                if (sl < 0) warn(_("failed to request selinux state"));
+                else ctl->selinux_enabled = sl == 1;
 #endif
-			add_column(columns, ncolumns++, COL_SELINUX);
-			break;
-		}
-		default:
-			errtryhelp(EXIT_FAILURE);
-		}
-	}
-
-	if (argc - optind == 1) {
-		if (strchr(argv[optind], ','))
-			errx(EXIT_FAILURE, _("Only one user may be specified. Use -l for multiple users."));
-		logins = argv[optind];
-		outmode = OUT_PRETTY;
-		ctl->fail_on_unknown = 1;
-	} else if (argc != optind)
-		errx(EXIT_FAILURE, _("Only one user may be specified. Use -l for multiple users."));
-
-	scols_init_debug(0);
-
-	/* lslogins -u -s == lslogins */
-	if (lslogins_flag & F_USRAC && lslogins_flag & F_SYSAC)
-		lslogins_flag &= ~(F_USRAC | F_SYSAC);
-
-	if (outmode == OUT_PRETTY) {
-		/* all columns for lslogins <username> */
-		for (ncolumns = 0, i = 0; i < ARRAY_SIZE(coldescs); i++)
-			 columns[ncolumns++] = i;
-
-	} else if (ncolumns == 2) {
-		/* default columns */
-		add_column(columns, ncolumns++, COL_NPROCS);
-		add_column(columns, ncolumns++, COL_PWDLOCK);
-		add_column(columns, ncolumns++, COL_PWDDENY);
-		add_column(columns, ncolumns++, COL_LAST_LOGIN);
-		add_column(columns, ncolumns++, COL_GECOS);
-	}
-
-	if (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns),
-					 &ncolumns, column_name_to_id) < 0)
-		return EXIT_FAILURE;
-
-	if (require_wtmp()) {
-		parse_wtmp(ctl, path_wtmp);
-		ctl->lastlogin_fd = open(path_lastlog, O_RDONLY, 0);
-	}
-	if (require_btmp())
-		parse_btmp(ctl, path_btmp);
-
-	if (logins || groups)
-		get_ulist(ctl, logins, groups);
-
-	if (create_usertree(ctl))
-		return EXIT_FAILURE;
-
-	print_user_table(ctl);
-
-	scols_unref_table(tb);
-	tdestroy(ctl->usertree, free_user);
-
-	if (ctl->lastlogin_fd >= 0)
-		close(ctl->lastlogin_fd);
-	free_ctl(ctl);
-
-	return EXIT_SUCCESS;
+                add_column(columns, ncolumns++, COL_SELINUX);
+                break;
+            }
+            default: errtryhelp(EXIT_FAILURE);
+        }
+    }
+
+    if (argc - optind == 1)
+    {
+        if (strchr(argv[optind], ','))
+            errx(EXIT_FAILURE, _("Only one user may be specified. Use -l for "
+                                 "multiple users."));
+        logins               = argv[optind];
+        outmode              = OUT_PRETTY;
+        ctl->fail_on_unknown = 1;
+    }
+    else if (argc != optind)
+        errx(EXIT_FAILURE,
+             _("Only one user may be specified. Use -l for multiple users."));
+
+    scols_init_debug(0);
+
+    /* lslogins -u -s == lslogins */
+    if (lslogins_flag & F_USRAC && lslogins_flag & F_SYSAC)
+        lslogins_flag &= ~(F_USRAC | F_SYSAC);
+
+    if (outmode == OUT_PRETTY)
+    {
+        /* all columns for lslogins <username> */
+        for (ncolumns = 0, i = 0; i < ARRAY_SIZE(coldescs); i++)
+            columns[ncolumns++] = i;
+    }
+    else if (ncolumns == 2)
+    {
+        /* default columns */
+        add_column(columns, ncolumns++, COL_NPROCS);
+        add_column(columns, ncolumns++, COL_PWDLOCK);
+        add_column(columns, ncolumns++, COL_PWDDENY);
+        add_column(columns, ncolumns++, COL_LAST_LOGIN);
+        add_column(columns, ncolumns++, COL_GECOS);
+    }
+
+    if (outarg
+        && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns),
+                                 &ncolumns, column_name_to_id)
+               < 0)
+        return EXIT_FAILURE;
+
+    if (require_wtmp())
+    {
+        parse_wtmp(ctl, path_wtmp);
+        ctl->lastlogin_fd = open(path_lastlog, O_RDONLY, 0);
+    }
+    if (require_btmp()) parse_btmp(ctl, path_btmp);
+
+    if (logins || groups) get_ulist(ctl, logins, groups);
+
+    if (create_usertree(ctl)) return EXIT_FAILURE;
+
+    print_user_table(ctl);
+
+    scols_unref_table(tb);
+    tdestroy(ctl->usertree, free_user);
+
+    if (ctl->lastlogin_fd >= 0) close(ctl->lastlogin_fd);
+    free_ctl(ctl);
+
+    return EXIT_SUCCESS;
 }
diff --git a/misc-utils/lsblk.h b/misc-utils/lsblk.h
index 8722127..3cfc6f4 100644
--- a/misc-utils/lsblk.h
+++ b/misc-utils/lsblk.h
@@ -6,78 +6,83 @@
 #ifndef UTIL_LINUX_LSBLK_H
 #define UTIL_LINUX_LSBLK_H
 
-#include <stdint.h>
 #include <inttypes.h>
+#include <stdint.h>
 #include <sys/stat.h>
 #include <sys/statvfs.h>
 
 #include <libsmartcols.h>
 
+#include <linux/fs.h>
+
 #include "c.h"
-#include "list.h"
 #include "debug.h"
+#include "list.h"
 
-#define LSBLK_DEBUG_INIT	(1 << 1)
-#define LSBLK_DEBUG_FILTER	(1 << 2)
-#define LSBLK_DEBUG_DEV		(1 << 3)
-#define LSBLK_DEBUG_TREE	(1 << 4)
-#define LSBLK_DEBUG_DEP		(1 << 5)
-#define LSBLK_DEBUG_ALL		0xFFFF
+#define LSBLK_DEBUG_INIT   (1 << 1)
+#define LSBLK_DEBUG_FILTER (1 << 2)
+#define LSBLK_DEBUG_DEV    (1 << 3)
+#define LSBLK_DEBUG_TREE   (1 << 4)
+#define LSBLK_DEBUG_DEP    (1 << 5)
+#define LSBLK_DEBUG_ALL    0xFFFF
 
 UL_DEBUG_DECLARE_MASK(lsblk);
-#define DBG(m, x)       __UL_DBG(lsblk, LSBLK_DEBUG_, m, x)
-#define ON_DBG(m, x)    __UL_DBG_CALL(lsblk, LSBLK_DEBUG_, m, x)
+#define DBG(m, x)             __UL_DBG(lsblk, LSBLK_DEBUG_, m, x)
+#define ON_DBG(m, x)          __UL_DBG_CALL(lsblk, LSBLK_DEBUG_, m, x)
 
-#define UL_DEBUG_CURRENT_MASK	UL_DEBUG_MASK(lsblk)
+#define UL_DEBUG_CURRENT_MASK UL_DEBUG_MASK(lsblk)
 #include "debugobj.h"
 
-struct lsblk {
-	struct libscols_table *table;	/* output table */
+struct lsblk
+{
+    struct libscols_table*  table; /* output table */
 
-	struct libscols_column *sort_col;/* sort output by this column */
+    struct libscols_column* sort_col; /* sort output by this column */
 
-	int sort_id;			/* id of the sort column */
-	int tree_id;			/* od of column used for tree */
+    int                     sort_id; /* id of the sort column */
+    int                     tree_id; /* od of column used for tree */
 
-	int dedup_id;
+    int                     dedup_id;
 
-	const char *sysroot;
-	int flags;			/* LSBLK_* */
+    const char*             sysroot;
+    int                     flags; /* LSBLK_* */
 
-	unsigned int all_devices:1;	/* print all devices, including empty */
-	unsigned int bytes:1;		/* print SIZE in bytes */
-	unsigned int inverse:1;		/* print inverse dependencies */
-	unsigned int merge:1;           /* merge sub-trees */
-	unsigned int nodeps:1;		/* don't print slaves/holders */
-	unsigned int scsi:1;		/* print only device with HCTL (SCSI) */
-	unsigned int paths:1;		/* print devnames with "/dev" prefix */
-	unsigned int sort_hidden:1;	/* sort column not between output columns */
-	unsigned int dedup_hidden :1;	/* deduplication column not between output columns */
-	unsigned int force_tree_order:1;/* sort lines by parent->tree relation */
+    unsigned int all_devices : 1; /* print all devices, including empty */
+    unsigned int bytes       : 1; /* print SIZE in bytes */
+    unsigned int inverse     : 1; /* print inverse dependencies */
+    unsigned int merge       : 1; /* merge sub-trees */
+    unsigned int nodeps      : 1; /* don't print slaves/holders */
+    unsigned int scsi        : 1; /* print only device with HCTL (SCSI) */
+    unsigned int paths       : 1; /* print devnames with "/dev" prefix */
+    unsigned int sort_hidden : 1; /* sort column not between output columns */
+    unsigned int
+        dedup_hidden : 1; /* deduplication column not between output columns */
+    unsigned int force_tree_order : 1; /* sort lines by parent->tree relation */
 };
 
-extern struct lsblk *lsblk;     /* global handler */
-
-struct lsblk_devprop {
-	/* udev / blkid based */
-	char *fstype;		/* detected fs, NULL or "?" if cannot detect */
-	char *fsversion;	/* filesystem version */
-	char *uuid;		/* filesystem UUID (or stack uuid) */
-	char *ptuuid;		/* partition table UUID */
-	char *pttype;		/* partition table type */
-	char *label;		/* filesystem label */
-	char *parttype;		/* partition type UUID */
-	char *partuuid;		/* partition UUID */
-	char *partlabel;	/* partition label */
-	char *partflags;	/* partition flags */
-	char *wwn;		/* storage WWN */
-	char *serial;		/* disk serial number */
-	char *model;		/* disk model */
-
-	/* lsblk specific (for --sysroot only)  */
-	char *owner;		/* user name */
-	char *group;		/* group name */
-	char *mode;		/* access mode in ls(1)-like notation */
+extern struct lsblk* lsblk; /* global handler */
+
+struct lsblk_devprop
+{
+    /* udev / blkid based */
+    char* fstype;    /* detected fs, NULL or "?" if cannot detect */
+    char* fsversion; /* filesystem version */
+    char* uuid;      /* filesystem UUID (or stack uuid) */
+    char* ptuuid;    /* partition table UUID */
+    char* pttype;    /* partition table type */
+    char* label;     /* filesystem label */
+    char* parttype;  /* partition type UUID */
+    char* partuuid;  /* partition UUID */
+    char* partlabel; /* partition label */
+    char* partflags; /* partition flags */
+    char* wwn;       /* storage WWN */
+    char* serial;    /* disk serial number */
+    char* model;     /* disk model */
+
+    /* lsblk specific (for --sysroot only)  */
+    char* owner; /* user name */
+    char* group; /* group name */
+    char* mode;  /* access mode in ls(1)-like notation */
 };
 
 /* Device dependence
@@ -85,60 +90,58 @@ struct lsblk_devprop {
  * Note that the same device may be slave/holder for more another devices. It
  * means we need to allocate list member rather than use @child directly.
  */
-struct lsblk_devdep {
-	struct list_head        ls_childs;	/* item in parent->childs */
-	struct list_head	ls_parents;	/* item in child->parents */
+struct lsblk_devdep
+{
+    struct list_head     ls_childs;  /* item in parent->childs */
+    struct list_head     ls_parents; /* item in child->parents */
 
-	struct lsblk_device	*child;
-	struct lsblk_device	*parent;
+    struct lsblk_device* child;
+    struct lsblk_device* parent;
 };
 
-struct lsblk_device {
-	int	refcount;
+struct lsblk_device
+{
+    int                   refcount;
 
-	struct list_head	childs;		/* list with lsblk_devdep */
-	struct list_head	parents;
-	struct list_head	ls_roots;	/* item in devtree->roots list */
-	struct list_head	ls_devices;	/* item in devtree->devices list */
+    struct list_head      childs; /* list with lsblk_devdep */
+    struct list_head      parents;
+    struct list_head      ls_roots;   /* item in devtree->roots list */
+    struct list_head      ls_devices; /* item in devtree->devices list */
 
-	struct lsblk_device	*wholedisk;	/* for partitions */
+    struct lsblk_device*  wholedisk; /* for partitions */
 
-	struct libscols_line	*scols_line;
+    struct libscols_line* scols_line;
 
-	struct lsblk_devprop	*properties;
-	struct stat	st;
+    struct lsblk_devprop* properties;
+    struct stat           st;
 
-	char *name;		/* kernel name in /sys/block */
-	char *dm_name;		/* DM name (dm/block) */
+    char*                 name;    /* kernel name in /sys/block */
+    char*                 dm_name; /* DM name (dm/block) */
 
-	char *filename;		/* path to device node */
-	char *dedupkey;		/* de-duplication key */
+    char*                 filename; /* path to device node */
+    char*                 dedupkey; /* de-duplication key */
 
-	struct path_cxt	*sysfs;
+    struct path_cxt*      sysfs;
 
-	char *mountpoint;	/* device mountpoint */
-	struct statvfs fsstat;	/* statvfs() result */
+    char*                 mountpoint; /* device mountpoint */
+    struct statvfs        fsstat;     /* statvfs() result */
 
-	int npartitions;	/* # of partitions this device has */
-	int nholders;		/* # of devices mapped directly to this device
-				 * /sys/block/.../holders */
-	int nslaves;		/* # of devices this device maps to */
-	int maj, min;		/* devno */
+    int                   npartitions; /* # of partitions this device has */
+    int          nholders; /* # of devices mapped directly to this device
+                            * /sys/block/.../holders */
+    int          nslaves;  /* # of devices this device maps to */
+    int          maj, min; /* devno */
 
-	uint64_t discard_granularity;	/* sunknown:-1, yes:1, not:0 */
+    uint64_t     discard_granularity; /* sunknown:-1, yes:1, not:0 */
 
-	uint64_t size;		/* device size */
-	int removable;		/* unknown:-1, yes:1, not:0 */
+    uint64_t     size;      /* device size */
+    int          removable; /* unknown:-1, yes:1, not:0 */
 
-	unsigned int	is_mounted : 1,
-			is_swap : 1,
-			is_printed : 1,
-			udev_requested : 1,
-			blkid_requested : 1,
-			file_requested : 1;
+    unsigned int is_mounted : 1, is_swap : 1, is_printed : 1,
+        udev_requested : 1, blkid_requested : 1, file_requested : 1;
 };
 
-#define device_is_partition(_x)		((_x)->wholedisk != NULL)
+#define device_is_partition(_x) ((_x)->wholedisk != NULL)
 
 /*
  * Note that lsblk tree uses bottom devices (devices without slaves) as root
@@ -148,90 +151,92 @@ struct lsblk_device {
  * The flag 'is_inverted' turns the tree over (root is device without holders):
  *    md0 -> sda1 -> sda
  */
-struct lsblk_devtree {
-	int	refcount;
+struct lsblk_devtree
+{
+    int              refcount;
 
-	struct list_head	roots;		/* tree root devices */
-	struct list_head	devices;	/* all devices */
+    struct list_head roots;   /* tree root devices */
+    struct list_head devices; /* all devices */
 
-	unsigned int	is_inverse : 1;		/* inverse tree */
+    unsigned int     is_inverse : 1; /* inverse tree */
 };
 
-
 /*
  * Generic iterator
  */
-struct lsblk_iter {
-	struct list_head        *p;		/* current position */
-	struct list_head        *head;		/* start position */
-	int			direction;	/* LSBLK_ITER_{FOR,BACK}WARD */
+struct lsblk_iter
+{
+    struct list_head* p;         /* current position */
+    struct list_head* head;      /* start position */
+    int               direction; /* LSBLK_ITER_{FOR,BACK}WARD */
 };
 
-#define LSBLK_ITER_FORWARD	0
-#define LSBLK_ITER_BACKWARD	1
-
-#define IS_ITER_FORWARD(_i)	((_i)->direction == LSBLK_ITER_FORWARD)
-#define IS_ITER_BACKWARD(_i)	((_i)->direction == LSBLK_ITER_BACKWARD)
+#define LSBLK_ITER_FORWARD   0
+#define LSBLK_ITER_BACKWARD  1
 
-#define LSBLK_ITER_INIT(itr, list) \
-	do { \
-		(itr)->p = IS_ITER_FORWARD(itr) ? \
-				(list)->next : (list)->prev; \
-		(itr)->head = (list); \
-	} while(0)
+#define IS_ITER_FORWARD(_i)  ((_i)->direction == LSBLK_ITER_FORWARD)
+#define IS_ITER_BACKWARD(_i) ((_i)->direction == LSBLK_ITER_BACKWARD)
 
-#define LSBLK_ITER_ITERATE(itr, res, restype, member) \
-	do { \
-		res = list_entry((itr)->p, restype, member); \
-		(itr)->p = IS_ITER_FORWARD(itr) ? \
-				(itr)->p->next : (itr)->p->prev; \
-	} while(0)
+#define LSBLK_ITER_INIT(itr, list)                                             \
+    do {                                                                       \
+        (itr)->p    = IS_ITER_FORWARD(itr) ? (list)->next : (list)->prev;      \
+        (itr)->head = (list);                                                  \
+    } while (0)
 
+#define LSBLK_ITER_ITERATE(itr, res, restype, member)                          \
+    do {                                                                       \
+        res      = list_entry((itr)->p, restype, member);                      \
+        (itr)->p = IS_ITER_FORWARD(itr) ? (itr)->p->next : (itr)->p->prev;     \
+    } while (0)
 
 /* lsblk-mnt.c */
-extern void lsblk_mnt_init(void);
-extern void lsblk_mnt_deinit(void);
+extern void  lsblk_mnt_init(void);
+extern void  lsblk_mnt_deinit(void);
 
-extern char *lsblk_device_get_mountpoint(struct lsblk_device *dev);
+extern char* lsblk_device_get_mountpoint(struct lsblk_device* dev);
 
 /* lsblk-properties.c */
-extern void lsblk_device_free_properties(struct lsblk_devprop *p);
-extern struct lsblk_devprop *lsblk_device_get_properties(struct lsblk_device *dev);
-extern void lsblk_properties_deinit(void);
+extern void  lsblk_device_free_properties(struct lsblk_devprop* p);
+extern struct lsblk_devprop*
+                     lsblk_device_get_properties(struct lsblk_device* dev);
+extern void          lsblk_properties_deinit(void);
 
-extern const char *lsblk_parttype_code_to_string(const char *code, const char *pttype);
+extern const char*   lsblk_parttype_code_to_string(const char* code,
+                                                   const char* pttype);
 
 /* lsblk-devtree.c */
-void lsblk_reset_iter(struct lsblk_iter *itr, int direction);
-struct lsblk_device *lsblk_new_device(void);
-void lsblk_ref_device(struct lsblk_device *dev);
-void lsblk_unref_device(struct lsblk_device *dev);
-int lsblk_device_new_dependence(struct lsblk_device *parent, struct lsblk_device *child);
-int lsblk_device_has_child(struct lsblk_device *dev, struct lsblk_device *child);
-int lsblk_device_next_child(struct lsblk_device *dev,
-                          struct lsblk_iter *itr,
-                          struct lsblk_device **child);
-
-int lsblk_device_is_last_parent(struct lsblk_device *dev, struct lsblk_device *parent);
-int lsblk_device_next_parent(
-                        struct lsblk_device *dev,
-                        struct lsblk_iter *itr,
-                        struct lsblk_device **parent);
-
-struct lsblk_devtree *lsblk_new_devtree(void);
-void lsblk_ref_devtree(struct lsblk_devtree *tr);
-void lsblk_unref_devtree(struct lsblk_devtree *tr);
-int lsblk_devtree_add_root(struct lsblk_devtree *tr, struct lsblk_device *dev);
-int lsblk_devtree_next_root(struct lsblk_devtree *tr,
-                            struct lsblk_iter *itr,
-                            struct lsblk_device **dev);
-int lsblk_devtree_add_device(struct lsblk_devtree *tr, struct lsblk_device *dev);
-int lsblk_devtree_next_device(struct lsblk_devtree *tr,
-                            struct lsblk_iter *itr,
-                            struct lsblk_device **dev);
-int lsblk_devtree_has_device(struct lsblk_devtree *tr, struct lsblk_device *dev);
-struct lsblk_device *lsblk_devtree_get_device(struct lsblk_devtree *tr, const char *name);
-int lsblk_devtree_remove_device(struct lsblk_devtree *tr, struct lsblk_device *dev);
-int lsblk_devtree_deduplicate_devices(struct lsblk_devtree *tr);
+void                 lsblk_reset_iter(struct lsblk_iter* itr, int direction);
+struct lsblk_device* lsblk_new_device(void);
+void                 lsblk_ref_device(struct lsblk_device* dev);
+void                 lsblk_unref_device(struct lsblk_device* dev);
+int                  lsblk_device_new_dependence(struct lsblk_device* parent,
+                                                 struct lsblk_device* child);
+int                  lsblk_device_has_child(struct lsblk_device* dev,
+                                            struct lsblk_device* child);
+int lsblk_device_next_child(struct lsblk_device* dev, struct lsblk_iter* itr,
+                            struct lsblk_device** child);
+
+int lsblk_device_is_last_parent(struct lsblk_device* dev,
+                                struct lsblk_device* parent);
+int lsblk_device_next_parent(struct lsblk_device* dev, struct lsblk_iter* itr,
+                             struct lsblk_device** parent);
+
+struct lsblk_devtree* lsblk_new_devtree(void);
+void                  lsblk_ref_devtree(struct lsblk_devtree* tr);
+void                  lsblk_unref_devtree(struct lsblk_devtree* tr);
+int lsblk_devtree_add_root(struct lsblk_devtree* tr, struct lsblk_device* dev);
+int lsblk_devtree_next_root(struct lsblk_devtree* tr, struct lsblk_iter* itr,
+                            struct lsblk_device** dev);
+int lsblk_devtree_add_device(struct lsblk_devtree* tr,
+                             struct lsblk_device*  dev);
+int lsblk_devtree_next_device(struct lsblk_devtree* tr, struct lsblk_iter* itr,
+                              struct lsblk_device** dev);
+int lsblk_devtree_has_device(struct lsblk_devtree* tr,
+                             struct lsblk_device*  dev);
+struct lsblk_device* lsblk_devtree_get_device(struct lsblk_devtree* tr,
+                                              const char*           name);
+int                  lsblk_devtree_remove_device(struct lsblk_devtree* tr,
+                                                 struct lsblk_device*  dev);
+int lsblk_devtree_deduplicate_devices(struct lsblk_devtree* tr);
 
 #endif /* UTIL_LINUX_LSBLK_H */
diff --git a/term-utils/agetty.c b/term-utils/agetty.c
index 191fa29..f1cfa95 100644
--- a/term-utils/agetty.c
+++ b/term-utils/agetty.c
@@ -11,99 +11,107 @@
  * This program is freely distributable.
  */
 
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <termios.h>
-#include <signal.h>
+#include <arpa/inet.h>
+#include <ctype.h>
 #include <errno.h>
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/wait.h>
 #include <fcntl.h>
-#include <stdarg.h>
-#include <ctype.h>
-#include <utmpx.h>
 #include <getopt.h>
-#include <time.h>
-#include <sys/socket.h>
-#include <langinfo.h>
 #include <grp.h>
-#include <arpa/inet.h>
-#include <netdb.h>
 #include <ifaddrs.h>
+#include <langinfo.h>
 #include <net/if.h>
+#include <netdb.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
 #include <sys/utsname.h>
+#include <sys/wait.h>
+#include <termios.h>
+#include <time.h>
+#include <unistd.h>
+#include <utmpx.h>
 
-#include "strutils.h"
 #include "all-io.h"
-#include "nls.h"
-#include "pathnames.h"
 #include "c.h"
 #include "cctype.h"
-#include "widechar.h"
-#include "ttyutils.h"
 #include "color-names.h"
 #include "env.h"
+#include "nls.h"
+#include "pathnames.h"
+#include "strutils.h"
+#include "ttyutils.h"
+#include "widechar.h"
 
 #ifdef USE_PLYMOUTH_SUPPORT
-# include "plymouth-ctrl.h"
+    #include "plymouth-ctrl.h"
 #endif
 
 #ifdef HAVE_SYS_PARAM_H
-# include <sys/param.h>
+    #include <sys/param.h>
 #endif
 
 #if defined(__FreeBSD_kernel__)
-# include <pty.h>
-# ifdef HAVE_UTMP_H
-#  include <utmp.h>
-# endif
-# ifdef HAVE_LIBUTIL_H
-#  include <libutil.h>
-# endif
+    #include <pty.h>
+    #ifdef HAVE_UTMP_H
+        #include <utmp.h>
+    #endif
+    #ifdef HAVE_LIBUTIL_H
+        #include <libutil.h>
+    #endif
 #endif
 
 #ifdef __linux__
-#  include <sys/kd.h>
-#  define USE_SYSLOG
-#  ifndef DEFAULT_VCTERM
-#    define DEFAULT_VCTERM "linux"
-#  endif
-#  if defined (__s390__) || defined (__s390x__)
-#    define DEFAULT_TTYS0  "dumb"
-#    define DEFAULT_TTY32  "ibm327x"
-#    define DEFAULT_TTYS1  "vt220"
-#  endif
-#  ifndef DEFAULT_STERM
-#    define DEFAULT_STERM  "vt102"
-#  endif
+    #include <sys/kd.h>
+    #define USE_SYSLOG
+    #ifndef DEFAULT_VCTERM
+        #define DEFAULT_VCTERM "linux"
+    #endif
+    #if defined(__s390__) || defined(__s390x__)
+        #define DEFAULT_TTYS0 "dumb"
+        #define DEFAULT_TTY32 "ibm327x"
+        #define DEFAULT_TTYS1 "vt220"
+    #endif
+    #ifndef DEFAULT_STERM
+        #define DEFAULT_STERM "vt102"
+    #endif
 #elif defined(__GNU__)
-#  define USE_SYSLOG
-#  ifndef DEFAULT_VCTERM
-#    define DEFAULT_VCTERM "hurd"
-#  endif
-#  ifndef DEFAULT_STERM
-#    define DEFAULT_STERM  "vt102"
-#  endif
+    #define USE_SYSLOG
+    #ifndef DEFAULT_VCTERM
+        #define DEFAULT_VCTERM "hurd"
+    #endif
+    #ifndef DEFAULT_STERM
+        #define DEFAULT_STERM "vt102"
+    #endif
+#elif defined(__cryptix__)
+    #define USE_SYSLOG
+    #ifndef DEFAULT_VCTERM
+        #define DEFAULT_VCTERM "cryptix"
+    #endif
+    #ifndef DEFAULT_STERM
+        #define DEFAULT_STERM "vt100"
+    #endif
 #else
-#  ifndef DEFAULT_VCTERM
-#    define DEFAULT_VCTERM "vt100"
-#  endif
-#  ifndef DEFAULT_STERM
-#    define DEFAULT_STERM  "vt100"
-#  endif
+    #ifndef DEFAULT_VCTERM
+        #define DEFAULT_VCTERM "vt100"
+    #endif
+    #ifndef DEFAULT_STERM
+        #define DEFAULT_STERM "vt100"
+    #endif
 #endif
 
 #ifdef __FreeBSD_kernel__
-#define USE_SYSLOG
+    #define USE_SYSLOG
 #endif
 
 /* If USE_SYSLOG is undefined all diagnostics go to /dev/console. */
-#ifdef	USE_SYSLOG
-#  include <syslog.h>
+#ifdef USE_SYSLOG
+    #include <syslog.h>
 #endif
 
 /*
@@ -112,7 +120,7 @@
  * utmp.h, which will select System V style getty.
  */
 #ifdef LOGIN_PROCESS
-#  define SYSV_STYLE
+    #define SYSV_STYLE
 #endif
 
 /*
@@ -128,442 +136,464 @@
  */
 
 /* Displayed before the login prompt. */
-#ifdef	SYSV_STYLE
-#  define ISSUE_SUPPORT
-#  if defined(HAVE_SCANDIRAT) && defined(HAVE_OPENAT)
-#    include <dirent.h>
-#    include "fileutils.h"
-#    define ISSUEDIR_SUPPORT
-#    define ISSUEDIR_EXT	".issue"
-#    define ISSUEDIR_EXTSIZ	(sizeof(ISSUEDIR_EXT) - 1)
-#  endif
+#ifdef SYSV_STYLE
+    #define ISSUE_SUPPORT
+    #if defined(HAVE_SCANDIRAT) && defined(HAVE_OPENAT)
+        #include "fileutils.h"
+        #include <dirent.h>
+        #define ISSUEDIR_SUPPORT
+        #define ISSUEDIR_EXT    ".issue"
+        #define ISSUEDIR_EXTSIZ (sizeof(ISSUEDIR_EXT) - 1)
+    #endif
 #endif
 
 /* Login prompt. */
-#define LOGIN		"login: "
-#define LOGIN_ARGV_MAX	16		/* Numbers of args for login */
+#define LOGIN          "login: "
+#define LOGIN_ARGV_MAX 16 /* Numbers of args for login */
 
 /*
  * agetty --reload
  */
 #ifdef AGETTY_RELOAD
-# include <sys/inotify.h>
-# include <linux/netlink.h>
-# include <linux/rtnetlink.h>
-# define AGETTY_RELOAD_FILENAME "/run/agetty.reload"	/* trigger file */
-# define AGETTY_RELOAD_FDNONE	-2			/* uninitialized fd */
-static int inotify_fd = AGETTY_RELOAD_FDNONE;
-static int netlink_fd = AGETTY_RELOAD_FDNONE;
+    #include <linux/netlink.h>
+    #include <linux/rtnetlink.h>
+    #include <sys/inotify.h>
+    #define AGETTY_RELOAD_FILENAME "/run/agetty.reload" /* trigger file */
+    #define AGETTY_RELOAD_FDNONE   -2                   /* uninitialized fd */
+static int      inotify_fd = AGETTY_RELOAD_FDNONE;
+static int      netlink_fd = AGETTY_RELOAD_FDNONE;
 static uint32_t netlink_groups;
 #endif
 
-struct issue {
-	FILE *output;
-	char *mem;
-	size_t mem_sz;
+struct issue
+{
+    FILE*  output;
+    char*  mem;
+    size_t mem_sz;
 
 #ifdef AGETTY_RELOAD
-	char *mem_old;
+    char* mem_old;
 #endif
-	unsigned int do_tcsetattr : 1,
-		     do_tcrestore : 1;
+    unsigned int do_tcsetattr : 1, do_tcrestore : 1;
 };
 
 /*
  * When multiple baud rates are specified on the command line, the first one
  * we will try is the first one specified.
  */
-#define	FIRST_SPEED	0
+#define FIRST_SPEED 0
 
 /* Storage for command-line options. */
-#define	MAX_SPEED	10	/* max. nr. of baud rates */
-
-struct options {
-	int flags;			/* toggle switches, see below */
-	unsigned int timeout;			/* time-out period */
-	char *autolog;			/* login the user automatically */
-	char *chdir;			/* Chdir before the login */
-	char *chroot;			/* Chroot before the login */
-	char *login;			/* login program */
-	char *logopt;			/* options for login program */
-	char *tty;			/* name of tty */
-	char *vcline;			/* line of virtual console */
-	char *term;			/* terminal type */
-	char *initstring;		/* modem init string */
-	char *issue;			/* alternative issue file or directory */
-	char *erasechars;		/* string with erase chars */
-	char *killchars;		/* string with kill chars */
-	char *osrelease;		/* /etc/os-release data */
-	unsigned int delay;			/* Sleep seconds before prompt */
-	int nice;			/* Run login with this priority */
-	int numspeed;			/* number of baud rates to try */
-	int clocal;			/* CLOCAL_MODE_* */
-	int kbmode;			/* Keyboard mode if virtual console */
-	speed_t speeds[MAX_SPEED];	/* baud rates to be tried */
+#define MAX_SPEED   10 /* max. nr. of baud rates */
+
+struct options
+{
+    int          flags;             /* toggle switches, see below */
+    unsigned int timeout;           /* time-out period */
+    char*        autolog;           /* login the user automatically */
+    char*        chdir;             /* Chdir before the login */
+    char*        chroot;            /* Chroot before the login */
+    char*        login;             /* login program */
+    char*        logopt;            /* options for login program */
+    char*        tty;               /* name of tty */
+    char*        vcline;            /* line of virtual console */
+    char*        term;              /* terminal type */
+    char*        initstring;        /* modem init string */
+    char*        issue;             /* alternative issue file or directory */
+    char*        erasechars;        /* string with erase chars */
+    char*        killchars;         /* string with kill chars */
+    char*        osrelease;         /* /etc/os-release data */
+    unsigned int delay;             /* Sleep seconds before prompt */
+    int          nice;              /* Run login with this priority */
+    int          numspeed;          /* number of baud rates to try */
+    int          clocal;            /* CLOCAL_MODE_* */
+    int          kbmode;            /* Keyboard mode if virtual console */
+    speed_t      speeds[MAX_SPEED]; /* baud rates to be tried */
 };
 
-enum {
-	CLOCAL_MODE_AUTO = 0,
-	CLOCAL_MODE_ALWAYS,
-	CLOCAL_MODE_NEVER
+enum
+{
+    CLOCAL_MODE_AUTO = 0,
+    CLOCAL_MODE_ALWAYS,
+    CLOCAL_MODE_NEVER
 };
 
-#define	F_PARSE		(1<<0)	/* process modem status messages */
-#define	F_ISSUE		(1<<1)	/* display /etc/issue or /etc/issue.d */
-#define	F_RTSCTS	(1<<2)	/* enable RTS/CTS flow control */
-
-#define F_INITSTRING    (1<<4)	/* initstring is set */
-#define F_WAITCRLF	(1<<5)	/* wait for CR or LF */
-
-#define F_NOPROMPT	(1<<7)	/* do not ask for login name! */
-#define F_LCUC		(1<<8)	/* support for *LCUC stty modes */
-#define F_KEEPSPEED	(1<<9)	/* follow baud rate from kernel */
-#define F_KEEPCFLAGS	(1<<10)	/* reuse c_cflags setup from kernel */
-#define F_EIGHTBITS	(1<<11)	/* Assume 8bit-clean tty */
-#define F_VCONSOLE	(1<<12)	/* This is a virtual console */
-#define F_HANGUP	(1<<13)	/* Do call vhangup(2) */
-#define F_UTF8		(1<<14)	/* We can do UTF8 */
-#define F_LOGINPAUSE	(1<<15)	/* Wait for any key before dropping login prompt */
-#define F_NOCLEAR	(1<<16) /* Do not clear the screen before prompting */
-#define F_NONL		(1<<17) /* No newline before issue */
-#define F_NOHOSTNAME	(1<<18) /* Do not show the hostname */
-#define F_LONGHNAME	(1<<19) /* Show Full qualified hostname */
-#define F_NOHINTS	(1<<20) /* Don't print hints */
-#define F_REMOTE	(1<<21) /* Add '-h fakehost' to login(1) command line */
-
-#define serial_tty_option(opt, flag)	\
-	(((opt)->flags & (F_VCONSOLE|(flag))) == (flag))
-
-struct Speedtab {
-	long speed;
-	speed_t code;
+#define F_PARSE      (1 << 0) /* process modem status messages */
+#define F_ISSUE      (1 << 1) /* display /etc/issue or /etc/issue.d */
+#define F_RTSCTS     (1 << 2) /* enable RTS/CTS flow control */
+
+#define F_INITSTRING (1 << 4) /* initstring is set */
+#define F_WAITCRLF   (1 << 5) /* wait for CR or LF */
+
+#define F_NOPROMPT   (1 << 7)  /* do not ask for login name! */
+#define F_LCUC       (1 << 8)  /* support for *LCUC stty modes */
+#define F_KEEPSPEED  (1 << 9)  /* follow baud rate from kernel */
+#define F_KEEPCFLAGS (1 << 10) /* reuse c_cflags setup from kernel */
+#define F_EIGHTBITS  (1 << 11) /* Assume 8bit-clean tty */
+#define F_VCONSOLE   (1 << 12) /* This is a virtual console */
+#define F_HANGUP     (1 << 13) /* Do call vhangup(2) */
+#define F_UTF8       (1 << 14) /* We can do UTF8 */
+#define F_LOGINPAUSE                                                           \
+    (1 << 15) /* Wait for any key before dropping login prompt */
+#define F_NOCLEAR    (1 << 16) /* Do not clear the screen before prompting */
+#define F_NONL       (1 << 17) /* No newline before issue */
+#define F_NOHOSTNAME (1 << 18) /* Do not show the hostname */
+#define F_LONGHNAME  (1 << 19) /* Show Full qualified hostname */
+#define F_NOHINTS    (1 << 20) /* Don't print hints */
+#define F_REMOTE     (1 << 21) /* Add '-h fakehost' to login(1) command line */
+
+#define serial_tty_option(opt, flag)                                           \
+    (((opt)->flags & (F_VCONSOLE | (flag))) == (flag))
+
+struct Speedtab
+{
+    long    speed;
+    speed_t code;
 };
 
 static const struct Speedtab speedtab[] = {
-	{50, B50},
-	{75, B75},
-	{110, B110},
-	{134, B134},
-	{150, B150},
-	{200, B200},
-	{300, B300},
-	{600, B600},
-	{1200, B1200},
-	{1800, B1800},
-	{2400, B2400},
-	{4800, B4800},
-	{9600, B9600},
+    {50, B50},
+    {75, B75},
+    {110, B110},
+    {134, B134},
+    {150, B150},
+    {200, B200},
+    {300, B300},
+    {600, B600},
+    {1200, B1200},
+    {1800, B1800},
+    {2400, B2400},
+    {4800, B4800},
+    {9600, B9600},
 #ifdef B19200
-	{19200, B19200},
+    {19200, B19200},
 #elif defined(EXTA)
-	{19200, EXTA},
+    {19200, EXTA},
 #endif
 #ifdef B38400
-	{38400, B38400},
+    {38400, B38400},
 #elif defined(EXTB)
-	{38400, EXTB},
+    {38400, EXTB},
 #endif
 #ifdef B57600
-	{57600, B57600},
+    {57600, B57600},
 #endif
 #ifdef B115200
-	{115200, B115200},
+    {115200, B115200},
 #endif
 #ifdef B230400
-	{230400, B230400},
+    {230400, B230400},
 #endif
 #ifdef B460800
-	{460800, B460800},
+    {460800, B460800},
 #endif
 #ifdef B500000
-	{500000, B500000},
+    {500000, B500000},
 #endif
 #ifdef B576000
-	{576000, B576000},
+    {576000, B576000},
 #endif
 #ifdef B921600
-	{921600, B921600},
+    {921600, B921600},
 #endif
 #ifdef B1000000
-	{1000000, B1000000},
+    {1000000, B1000000},
 #endif
 #ifdef B1152000
-	{1152000, B1152000},
+    {1152000, B1152000},
 #endif
 #ifdef B1500000
-	{1500000, B1500000},
+    {1500000, B1500000},
 #endif
 #ifdef B2000000
-	{2000000, B2000000},
+    {2000000, B2000000},
 #endif
 #ifdef B2500000
-	{2500000, B2500000},
+    {2500000, B2500000},
 #endif
 #ifdef B3000000
-	{3000000, B3000000},
+    {3000000, B3000000},
 #endif
 #ifdef B3500000
-	{3500000, B3500000},
+    {3500000, B3500000},
 #endif
 #ifdef B4000000
-	{4000000, B4000000},
+    {4000000, B4000000},
 #endif
-	{0, 0},
+    {0, 0},
 };
 
-static void init_special_char(char* arg, struct options *op);
-static void parse_args(int argc, char **argv, struct options *op);
-static void parse_speeds(struct options *op, char *arg);
-static void update_utmp(struct options *op);
-static void open_tty(char *tty, struct termios *tp, struct options *op);
-static void termio_init(struct options *op, struct termios *tp);
-static void reset_vc(const struct options *op, struct termios *tp, int canon);
-static void auto_baud(struct termios *tp);
+static void init_special_char(char* arg, struct options* op);
+static void parse_args(int argc, char** argv, struct options* op);
+static void parse_speeds(struct options* op, char* arg);
+static void update_utmp(struct options* op);
+static void open_tty(char* tty, struct termios* tp, struct options* op);
+static void termio_init(struct options* op, struct termios* tp);
+static void reset_vc(const struct options* op, struct termios* tp, int canon);
+static void auto_baud(struct termios* tp);
 static void list_speeds(void);
-static void output_special_char (struct issue *ie, unsigned char c, struct options *op,
-		struct termios *tp, FILE *fp);
-static void do_prompt(struct issue *ie, struct options *op, struct termios *tp);
-static void next_speed(struct options *op, struct termios *tp);
-static char *get_logname(struct issue *ie, struct options *op,
-			 struct termios *tp, struct chardata *cp);
-static void termio_final(struct options *op,
-			 struct termios *tp, struct chardata *cp);
-static int caps_lock(char *s);
-static speed_t bcode(char *s);
-static void usage(void) __attribute__((__noreturn__));
-static void exit_slowly(int code) __attribute__((__noreturn__));
-static void log_err(const char *, ...) __attribute__((__noreturn__))
-			       __attribute__((__format__(printf, 1, 2)));
-static void log_warn (const char *, ...)
-				__attribute__((__format__(printf, 1, 2)));
-static ssize_t append(char *dest, size_t len, const char  *sep, const char *src);
-static void check_username (const char* nm);
-static void login_options_to_argv(char *argv[], int *argc, char *str, char *username);
-static void reload_agettys(void);
-static void print_issue_file(struct issue *ie, struct options *op, struct termios *tp);
-static void eval_issue_file(struct issue *ie, struct options *op, struct termios *tp);
-static void show_issue(struct options *op);
-
+static void output_special_char(struct issue* ie, unsigned char c,
+                                struct options* op, struct termios* tp,
+                                FILE* fp);
+static void do_prompt(struct issue* ie, struct options* op, struct termios* tp);
+static void next_speed(struct options* op, struct termios* tp);
+static char*   get_logname(struct issue* ie, struct options* op,
+                           struct termios* tp, struct chardata* cp);
+static void    termio_final(struct options* op, struct termios* tp,
+                            struct chardata* cp);
+static int     caps_lock(char* s);
+static speed_t bcode(char* s);
+static void    usage(void) __attribute__((__noreturn__));
+static void    exit_slowly(int code) __attribute__((__noreturn__));
+static void    log_err(const char*, ...) __attribute__((__noreturn__))
+__attribute__((__format__(printf, 1, 2)));
+static void log_warn(const char*, ...)
+    __attribute__((__format__(printf, 1, 2)));
+static ssize_t append(char* dest, size_t len, const char* sep, const char* src);
+static void    check_username(const char* nm);
+static void    login_options_to_argv(char* argv[], int* argc, char* str,
+                                     char* username);
+static void    reload_agettys(void);
+static void    print_issue_file(struct issue* ie, struct options* op,
+                                struct termios* tp);
+static void    eval_issue_file(struct issue* ie, struct options* op,
+                               struct termios* tp);
+static void    show_issue(struct options* op);
 
 /* Fake hostname for ut_host specified on command line. */
-static char *fakehost;
+static char*   fakehost;
 
 #ifdef DEBUGGING
-# include "closestream.h"
-# ifndef DEBUG_OUTPUT
-#  define DEBUG_OUTPUT "/dev/tty10"
-# endif
-# define debug(s) do { fprintf(dbf,s); fflush(dbf); } while (0)
-FILE *dbf;
+    #include "closestream.h"
+    #ifndef DEBUG_OUTPUT
+        #define DEBUG_OUTPUT "/dev/tty10"
+    #endif
+    #define debug(s)                                                           \
+        do {                                                                   \
+            fprintf(dbf, s);                                                   \
+            fflush(dbf);                                                       \
+        } while (0)
+FILE* dbf;
 #else
-# define debug(s) do { ; } while (0)
+    #define debug(s)                                                           \
+        do {                                                                   \
+            ;                                                                  \
+        } while (0)
 #endif
 
-int main(int argc, char **argv)
+int main(int argc, char** argv)
 {
-	char *username = NULL;			/* login name, given to /bin/login */
-	struct chardata chardata;		/* will be set by get_logname() */
-	struct termios termios;			/* terminal mode bits */
-	struct options options = {
-		.flags  =  F_ISSUE,		/* show /etc/issue (SYSV_STYLE) */
-		.login  =  _PATH_LOGIN,		/* default login program */
-		.tty    = "tty1"		/* default tty line */
-	};
-	struct issue issue = {
-		.mem = NULL,
-	};
-	char *login_argv[LOGIN_ARGV_MAX + 1];
-	int login_argc = 0;
-	struct sigaction sa, sa_hup, sa_quit, sa_int;
-	sigset_t set;
-
-	setlocale(LC_ALL, "");
-	bindtextdomain(PACKAGE, LOCALEDIR);
-	textdomain(PACKAGE);
-
-	/* In case vhangup(2) has to called */
-	sa.sa_handler = SIG_IGN;
-	sa.sa_flags = SA_RESTART;
-	sigemptyset (&sa.sa_mask);
-	sigaction(SIGHUP, &sa, &sa_hup);
-	sigaction(SIGQUIT, &sa, &sa_quit);
-	sigaction(SIGINT, &sa, &sa_int);
+    char*           username = NULL; /* login name, given to /bin/login */
+    struct chardata chardata;        /* will be set by get_logname() */
+    struct termios  termios;         /* terminal mode bits */
+    struct options  options = {
+         .flags = F_ISSUE,     /* show /etc/issue (SYSV_STYLE) */
+         .login = _PATH_LOGIN, /* default login program */
+         .tty   = "tty1"       /* default tty line */
+    };
+    struct issue issue = {
+        .mem = NULL,
+    };
+    char*            login_argv[LOGIN_ARGV_MAX + 1];
+    int              login_argc = 0;
+    struct sigaction sa, sa_hup, sa_quit, sa_int;
+    sigset_t         set;
+
+    setlocale(LC_ALL, "");
+    bindtextdomain(PACKAGE, LOCALEDIR);
+    textdomain(PACKAGE);
+
+    /* In case vhangup(2) has to called */
+    sa.sa_handler = SIG_IGN;
+    sa.sa_flags   = SA_RESTART;
+    sigemptyset(&sa.sa_mask);
+    sigaction(SIGHUP, &sa, &sa_hup);
+    sigaction(SIGQUIT, &sa, &sa_quit);
+    sigaction(SIGINT, &sa, &sa_int);
 
 #ifdef DEBUGGING
-	dbf = fopen(DEBUG_OUTPUT, "w");
-	for (int i = 1; i < argc; i++) {
-		if (i > 1)
-			debug(" ");
-		debug(argv[i]);
-	}
-	debug("\n");
-#endif				/* DEBUGGING */
-
-	/* Parse command-line arguments. */
-	parse_args(argc, argv, &options);
-
-	login_argv[login_argc++] = options.login;	/* set login program name */
-
-	/* Update the utmp file. */
-#ifdef	SYSV_STYLE
-	update_utmp(&options);
-#endif
-	if (options.delay)
-	    sleep(options.delay);
-
-	debug("calling open_tty\n");
-
-	/* Open the tty as standard { input, output, error }. */
-	open_tty(options.tty, &termios, &options);
-
-	/* Unmask SIGHUP if inherited */
-	sigemptyset(&set);
-	sigaddset(&set, SIGHUP);
-	sigprocmask(SIG_UNBLOCK, &set, NULL);
-	sigaction(SIGHUP, &sa_hup, NULL);
-
-	tcsetpgrp(STDIN_FILENO, getpid());
-
-	/* Default is to follow the current line speed and then default to 9600 */
-	if ((options.flags & F_VCONSOLE) == 0 && options.numspeed == 0) {
-		options.speeds[options.numspeed++] = bcode("9600");
-		options.flags |= F_KEEPSPEED;
-	}
-
-	/* Initialize the termios settings (raw mode, eight-bit, blocking i/o). */
-	debug("calling termio_init\n");
-	termio_init(&options, &termios);
-
-	/* Write the modem init string and DO NOT flush the buffers. */
-	if (serial_tty_option(&options, F_INITSTRING) &&
-	    options.initstring && *options.initstring != '\0') {
-		debug("writing init string\n");
-		write_all(STDOUT_FILENO, options.initstring,
-			   strlen(options.initstring));
-	}
-
-	if (options.flags & F_VCONSOLE || options.clocal != CLOCAL_MODE_ALWAYS)
-		/* Go to blocking mode unless -L is specified, this change
-		 * affects stdout, stdin and stderr as all the file descriptors
-		 * are created by dup().   */
-		fcntl(STDOUT_FILENO, F_SETFL,
-		      fcntl(STDOUT_FILENO, F_GETFL, 0) & ~O_NONBLOCK);
-
-	/* Optionally detect the baud rate from the modem status message. */
-	debug("before autobaud\n");
-	if (serial_tty_option(&options, F_PARSE))
-		auto_baud(&termios);
-
-	/* Set the optional timer. */
-	if (options.timeout)
-		alarm(options.timeout);
-
-	/* Optionally wait for CR or LF before writing /etc/issue */
-	if (serial_tty_option(&options, F_WAITCRLF)) {
-		char ch;
-
-		debug("waiting for cr-lf\n");
-		while (read(STDIN_FILENO, &ch, 1) == 1) {
-			/* Strip "parity bit". */
-			ch &= 0x7f;
+    dbf = fopen(DEBUG_OUTPUT, "w");
+    for (int i = 1; i < argc; i++)
+    {
+        if (i > 1) debug(" ");
+        debug(argv[i]);
+    }
+    debug("\n");
+#endif /* DEBUGGING */
+
+    /* Parse command-line arguments. */
+    parse_args(argc, argv, &options);
+
+    login_argv[login_argc++] = options.login; /* set login program name */
+
+    /* Update the utmp file. */
+#ifdef SYSV_STYLE
+    update_utmp(&options);
+#endif
+    if (options.delay) sleep(options.delay);
+
+    debug("calling open_tty\n");
+
+    /* Open the tty as standard { input, output, error }. */
+    open_tty(options.tty, &termios, &options);
+
+    /* Unmask SIGHUP if inherited */
+    sigemptyset(&set);
+    sigaddset(&set, SIGHUP);
+    sigprocmask(SIG_UNBLOCK, &set, NULL);
+    sigaction(SIGHUP, &sa_hup, NULL);
+
+    tcsetpgrp(STDIN_FILENO, getpid());
+
+    /* Default is to follow the current line speed and then default to 9600 */
+    if ((options.flags & F_VCONSOLE) == 0 && options.numspeed == 0)
+    {
+        options.speeds[options.numspeed++] = bcode("9600");
+        options.flags |= F_KEEPSPEED;
+    }
+
+    /* Initialize the termios settings (raw mode, eight-bit, blocking i/o). */
+    debug("calling termio_init\n");
+    termio_init(&options, &termios);
+
+    /* Write the modem init string and DO NOT flush the buffers. */
+    if (serial_tty_option(&options, F_INITSTRING) && options.initstring
+        && *options.initstring != '\0')
+    {
+        debug("writing init string\n");
+        write_all(STDOUT_FILENO, options.initstring,
+                  strlen(options.initstring));
+    }
+
+    if (options.flags & F_VCONSOLE || options.clocal != CLOCAL_MODE_ALWAYS)
+        /* Go to blocking mode unless -L is specified, this change
+         * affects stdout, stdin and stderr as all the file descriptors
+         * are created by dup().   */
+        fcntl(STDOUT_FILENO, F_SETFL,
+              fcntl(STDOUT_FILENO, F_GETFL, 0) & ~O_NONBLOCK);
+
+    /* Optionally detect the baud rate from the modem status message. */
+    debug("before autobaud\n");
+    if (serial_tty_option(&options, F_PARSE)) auto_baud(&termios);
+
+    /* Set the optional timer. */
+    if (options.timeout) alarm(options.timeout);
+
+    /* Optionally wait for CR or LF before writing /etc/issue */
+    if (serial_tty_option(&options, F_WAITCRLF))
+    {
+        char ch;
+
+        debug("waiting for cr-lf\n");
+        while (read(STDIN_FILENO, &ch, 1) == 1)
+        {
+            /* Strip "parity bit". */
+            ch &= 0x7f;
 #ifdef DEBUGGING
-			fprintf(dbf, "read %c\n", ch);
-#endif
-			if (ch == '\n' || ch == '\r')
-				break;
-		}
-	}
-
-	INIT_CHARDATA(&chardata);
-
-	if (options.autolog) {
-		debug("doing auto login\n");
-		username = options.autolog;
-	}
-
-	if (options.flags & F_NOPROMPT) {	/* --skip-login */
-		eval_issue_file(&issue, &options, &termios);
-		print_issue_file(&issue, &options, &termios);
-	} else {				/* regular (auto)login */
-		if (options.autolog) {
-			/* Autologin prompt */
-			eval_issue_file(&issue, &options, &termios);
-			do_prompt(&issue, &options, &termios);
-			printf(_("%s%s (automatic login)\n"), LOGIN, options.autolog);
-		} else {
-			/* Read the login name. */
-			debug("reading login name\n");
-			while ((username =
-				get_logname(&issue, &options, &termios, &chardata)) == NULL)
-				if ((options.flags & F_VCONSOLE) == 0 && options.numspeed)
-					next_speed(&options, &termios);
-		}
-	}
-
-	/* Disable timer. */
-	if (options.timeout)
-		alarm(0);
-
-	/* Finalize the termios settings. */
-	if ((options.flags & F_VCONSOLE) == 0)
-		termio_final(&options, &termios, &chardata);
-	else
-		reset_vc(&options, &termios, 1);
-
-	/* Now the newline character should be properly written. */
-	write_all(STDOUT_FILENO, "\r\n", 2);
-
-	sigaction(SIGQUIT, &sa_quit, NULL);
-	sigaction(SIGINT, &sa_int, NULL);
-
-	if (username)
-		check_username(username);
-
-	if (options.logopt) {
-		/*
-		 * The --login-options completely overwrites the default
-		 * way how agetty composes login(1) command line.
-		 */
-		login_options_to_argv(login_argv, &login_argc,
-				      options.logopt, username);
-	} else {
-		if (options.flags & F_REMOTE) {
-			if (fakehost) {
-				login_argv[login_argc++] = "-h";
-				login_argv[login_argc++] = fakehost;
-			} else if (options.flags & F_NOHOSTNAME)
-				login_argv[login_argc++] = "-H";
-		}
-		if (username) {
-			if (options.autolog)
-				login_argv[login_argc++] = "-f";
-			else
-				login_argv[login_argc++] = "--";
-			login_argv[login_argc++] = username;
-		}
-	}
-
-	login_argv[login_argc] = NULL;	/* last login argv */
-
-	if (options.chroot && chroot(options.chroot) < 0)
-		log_err(_("%s: can't change root directory %s: %m"),
-			options.tty, options.chroot);
-	if (options.chdir && chdir(options.chdir) < 0)
-		log_err(_("%s: can't change working directory %s: %m"),
-			options.tty, options.chdir);
-	if (options.nice && nice(options.nice) < 0)
-		log_warn(_("%s: can't change process priority: %m"),
-			 options.tty);
-
-	free(options.osrelease);
+            fprintf(dbf, "read %c\n", ch);
+#endif
+            if (ch == '\n' || ch == '\r') break;
+        }
+    }
+
+    INIT_CHARDATA(&chardata);
+
+    if (options.autolog)
+    {
+        debug("doing auto login\n");
+        username = options.autolog;
+    }
+
+    if (options.flags & F_NOPROMPT)
+    { /* --skip-login */
+        eval_issue_file(&issue, &options, &termios);
+        print_issue_file(&issue, &options, &termios);
+    }
+    else
+    { /* regular (auto)login */
+        if (options.autolog)
+        {
+            /* Autologin prompt */
+            eval_issue_file(&issue, &options, &termios);
+            do_prompt(&issue, &options, &termios);
+            printf(_("%s%s (automatic login)\n"), LOGIN, options.autolog);
+        }
+        else
+        {
+            /* Read the login name. */
+            debug("reading login name\n");
+            while (
+                (username = get_logname(&issue, &options, &termios, &chardata))
+                == NULL)
+                if ((options.flags & F_VCONSOLE) == 0 && options.numspeed)
+                    next_speed(&options, &termios);
+        }
+    }
+
+    /* Disable timer. */
+    if (options.timeout) alarm(0);
+
+    /* Finalize the termios settings. */
+    if ((options.flags & F_VCONSOLE) == 0)
+        termio_final(&options, &termios, &chardata);
+    else reset_vc(&options, &termios, 1);
+
+    /* Now the newline character should be properly written. */
+    write_all(STDOUT_FILENO, "\r\n", 2);
+
+    sigaction(SIGQUIT, &sa_quit, NULL);
+    sigaction(SIGINT, &sa_int, NULL);
+
+    if (username) check_username(username);
+
+    if (options.logopt)
+    {
+        /*
+         * The --login-options completely overwrites the default
+         * way how agetty composes login(1) command line.
+         */
+        login_options_to_argv(login_argv, &login_argc, options.logopt,
+                              username);
+    }
+    else
+    {
+        if (options.flags & F_REMOTE)
+        {
+            if (fakehost)
+            {
+                login_argv[login_argc++] = "-h";
+                login_argv[login_argc++] = fakehost;
+            }
+            else if (options.flags & F_NOHOSTNAME)
+                login_argv[login_argc++] = "-H";
+        }
+        if (username)
+        {
+            if (options.autolog) login_argv[login_argc++] = "-f";
+            else login_argv[login_argc++] = "--";
+            login_argv[login_argc++] = username;
+        }
+    }
+
+    login_argv[login_argc] = NULL; /* last login argv */
+
+    if (options.chroot && chroot(options.chroot) < 0)
+        log_err(_("%s: can't change root directory %s: %m"), options.tty,
+                options.chroot);
+    if (options.chdir && chdir(options.chdir) < 0)
+        log_err(_("%s: can't change working directory %s: %m"), options.tty,
+                options.chdir);
+    if (options.nice && nice(options.nice) < 0)
+        log_warn(_("%s: can't change process priority: %m"), options.tty);
+
+    free(options.osrelease);
 #ifdef DEBUGGING
-	if (close_stream(dbf) != 0)
-		log_err("write failed: %s", DEBUG_OUTPUT);
+    if (close_stream(dbf) != 0) log_err("write failed: %s", DEBUG_OUTPUT);
 #endif
 
-	/* Let the login program take care of password validation. */
-	execv(options.login, login_argv);
-	log_err(_("%s: can't exec %s: %m"), options.tty, login_argv[0]);
+    /* Let the login program take care of password validation. */
+    execv(options.login, login_argv);
+    log_err(_("%s: can't exec %s: %m"), options.tty, login_argv[0]);
 }
 
 /*
@@ -571,1831 +601,1780 @@ int main(int argc, char **argv)
  *         : @username if @str equal to "\u"
  *         : newly allocated string if \u mixed with something other
  */
-static char *replace_u(char *str, char *username)
+static char* replace_u(char* str, char* username)
 {
-	char *entry = NULL, *p = str;
-	size_t usz = username ? strlen(username) : 0;
-
-	while (*p) {
-		size_t sz;
-		char *tp, *old = entry;
-
-		if (memcmp(p, "\\u", 2) != 0) {
-			p++;
-			continue;	/* no \u */
-		}
-		sz = strlen(str);
-
-		if (p == str && sz == 2) {
-			/* 'str' contains only '\u' */
-			free(old);
-			return username;
-		}
-
-		tp = entry = malloc(sz + usz);
-		if (!tp)
-			log_err(_("failed to allocate memory: %m"));
-
-		if (p != str) {
-			/* copy chars before \u */
-			memcpy(tp, str, p - str);
-			tp += p - str;
-		}
-		if (usz) {
-			/* copy username */
-			memcpy(tp, username, usz);
-			tp += usz;
-		}
-		if (*(p + 2))
-			/* copy chars after \u + \0 */
-			memcpy(tp, p + 2, sz - (p - str) - 1);
-		else
-			*tp = '\0';
-
-		p = tp;
-		str = entry;
-		free(old);
-	}
-
-	return entry ? entry : str;
+    char * entry = NULL, *p = str;
+    size_t usz = username ? strlen(username) : 0;
+
+    while (*p)
+    {
+        size_t sz;
+        char * tp, *old = entry;
+
+        if (memcmp(p, "\\u", 2) != 0)
+        {
+            p++;
+            continue; /* no \u */
+        }
+        sz = strlen(str);
+
+        if (p == str && sz == 2)
+        {
+            /* 'str' contains only '\u' */
+            free(old);
+            return username;
+        }
+
+        tp = entry = malloc(sz + usz);
+        if (!tp) log_err(_("failed to allocate memory: %m"));
+
+        if (p != str)
+        {
+            /* copy chars before \u */
+            memcpy(tp, str, p - str);
+            tp += p - str;
+        }
+        if (usz)
+        {
+            /* copy username */
+            memcpy(tp, username, usz);
+            tp += usz;
+        }
+        if (*(p + 2)) /* copy chars after \u + \0 */
+            memcpy(tp, p + 2, sz - (p - str) - 1);
+        else *tp = '\0';
+
+        p   = tp;
+        str = entry;
+        free(old);
+    }
+
+    return entry ? entry : str;
 }
 
-static void login_options_to_argv(char *argv[], int *argc,
-				  char *str, char *username)
+static void login_options_to_argv(char* argv[], int* argc, char* str,
+                                  char* username)
 {
-	char *p;
-	int i = *argc;
-
-	while (str && isspace(*str))
-		str++;
-	p = str;
-
-	while (p && *p && i < LOGIN_ARGV_MAX) {
-		if (isspace(*p)) {
-			*p = '\0';
-			while (isspace(*++p))
-				;
-			if (*p) {
-				argv[i++] = replace_u(str, username);
-				str = p;
-			}
-		} else
-			p++;
-	}
-	if (str && *str && i < LOGIN_ARGV_MAX)
-		argv[i++] = replace_u(str, username);
-	*argc = i;
+    char* p;
+    int   i = *argc;
+
+    while (str && isspace(*str)) str++;
+    p = str;
+
+    while (p && *p && i < LOGIN_ARGV_MAX)
+    {
+        if (isspace(*p))
+        {
+            *p = '\0';
+            while (isspace(*++p));
+            if (*p)
+            {
+                argv[i++] = replace_u(str, username);
+                str       = p;
+            }
+        }
+        else p++;
+    }
+    if (str && *str && i < LOGIN_ARGV_MAX) argv[i++] = replace_u(str, username);
+    *argc = i;
 }
 
 static void output_version(void)
 {
-	static const char *features[] = {
+    static const char* features[] = {
 #ifdef DEBUGGING
-		"debug",
+        "debug",
 #endif
 #ifdef CRTSCTS
-		"flow control",
+        "flow control",
 #endif
 #ifdef KDGKBLED
-		"hints",
+        "hints",
 #endif
 #ifdef ISSUE_SUPPORT
-		"issue",
+        "issue",
 #endif
 #ifdef ISSUEDIR_SUPPORT
-		"issue.d",
+        "issue.d",
 #endif
 #ifdef KDGKBMODE
-		"keyboard mode",
+        "keyboard mode",
 #endif
 #ifdef USE_PLYMOUTH_SUPPORT
-		"plymouth",
+        "plymouth",
 #endif
 #ifdef AGETTY_RELOAD
-		"reload",
+        "reload",
 #endif
 #ifdef USE_SYSLOG
-		"syslog",
+        "syslog",
 #endif
 #ifdef HAVE_WIDECHAR
-		"widechar",
-#endif
-		NULL
-	};
-	unsigned int i;
-
-	printf( _("%s from %s"), program_invocation_short_name, PACKAGE_STRING);
-	fputs(" (", stdout);
-	for (i = 0; features[i]; i++) {
-		if (0 < i)
-			fputs(", ", stdout);
-		printf("%s", features[i]);
-	}
-	fputs(")\n", stdout);
+        "widechar",
+#endif
+        NULL};
+    unsigned int i;
+
+    printf(_("%s from %s"), program_invocation_short_name, PACKAGE_STRING);
+    fputs(" (", stdout);
+    for (i = 0; features[i]; i++)
+    {
+        if (0 < i) fputs(", ", stdout);
+        printf("%s", features[i]);
+    }
+    fputs(")\n", stdout);
 }
 
 #define is_speed(str) (strlen((str)) == strspn((str), "0123456789,"))
 
 /* Parse command-line arguments. */
-static void parse_args(int argc, char **argv, struct options *op)
+static void parse_args(int argc, char** argv, struct options* op)
 {
-	int c;
-	int opt_show_issue = 0;
-
-	enum {
-		VERSION_OPTION = CHAR_MAX + 1,
-		NOHINTS_OPTION,
-		NOHOSTNAME_OPTION,
-		LONGHOSTNAME_OPTION,
-		HELP_OPTION,
-		ERASE_CHARS_OPTION,
-		KILL_CHARS_OPTION,
-		RELOAD_OPTION,
-		LIST_SPEEDS_OPTION,
-		ISSUE_SHOW_OPTION,
-	};
-	const struct option longopts[] = {
-		{  "8bits",	     no_argument,	 NULL,  '8'  },
-		{  "autologin",	     required_argument,	 NULL,  'a'  },
-		{  "noreset",	     no_argument,	 NULL,  'c'  },
-		{  "chdir",	     required_argument,	 NULL,  'C'  },
-		{  "delay",	     required_argument,	 NULL,  'd'  },
-		{  "remote",         no_argument,        NULL,  'E'  },
-		{  "issue-file",     required_argument,  NULL,  'f'  },
-		{  "show-issue",     no_argument,        NULL,  ISSUE_SHOW_OPTION },
-		{  "flow-control",   no_argument,	 NULL,  'h'  },
-		{  "host",	     required_argument,  NULL,  'H'  },
-		{  "noissue",	     no_argument,	 NULL,  'i'  },
-		{  "init-string",    required_argument,  NULL,  'I'  },
-		{  "noclear",	     no_argument,	 NULL,  'J'  },
-		{  "login-program",  required_argument,  NULL,  'l'  },
-		{  "local-line",     optional_argument,	 NULL,  'L'  },
-		{  "extract-baud",   no_argument,	 NULL,  'm'  },
-		{  "list-speeds",    no_argument,	 NULL,	LIST_SPEEDS_OPTION },
-		{  "skip-login",     no_argument,	 NULL,  'n'  },
-		{  "nonewline",	     no_argument,	 NULL,  'N'  },
-		{  "login-options",  required_argument,  NULL,  'o'  },
-		{  "login-pause",    no_argument,        NULL,  'p'  },
-		{  "nice",	     required_argument,  NULL,  'P'  },
-		{  "chroot",	     required_argument,	 NULL,  'r'  },
-		{  "hangup",	     no_argument,	 NULL,  'R'  },
-		{  "keep-baud",      no_argument,	 NULL,  's'  },
-		{  "timeout",	     required_argument,  NULL,  't'  },
-		{  "detect-case",    no_argument,	 NULL,  'U'  },
-		{  "wait-cr",	     no_argument,	 NULL,  'w'  },
-		{  "nohints",        no_argument,        NULL,  NOHINTS_OPTION },
-		{  "nohostname",     no_argument,	 NULL,  NOHOSTNAME_OPTION },
-		{  "long-hostname",  no_argument,	 NULL,  LONGHOSTNAME_OPTION },
-		{  "reload",         no_argument,        NULL,  RELOAD_OPTION },
-		{  "version",	     no_argument,	 NULL,  VERSION_OPTION  },
-		{  "help",	     no_argument,	 NULL,  HELP_OPTION     },
-		{  "erase-chars",    required_argument,  NULL,  ERASE_CHARS_OPTION },
-		{  "kill-chars",     required_argument,  NULL,  KILL_CHARS_OPTION },
-		{ NULL, 0, NULL, 0 }
-	};
-
-	while ((c = getopt_long(argc, argv,
-			   "8a:cC:d:Ef:hH:iI:Jl:L::mnNo:pP:r:Rst:Uw", longopts,
-			    NULL)) != -1) {
-		switch (c) {
-		case '8':
-			op->flags |= F_EIGHTBITS;
-			break;
-		case 'a':
-			op->autolog = optarg;
-			break;
-		case 'c':
-			op->flags |= F_KEEPCFLAGS;
-			break;
-		case 'C':
-			op->chdir = optarg;
-			break;
-		case 'd':
-			op->delay = strtou32_or_err(optarg,  _("invalid delay argument"));
-			break;
-		case 'E':
-			op->flags |= F_REMOTE;
-			break;
-		case 'f':
-			op->issue = optarg;
-			break;
-		case 'h':
-			op->flags |= F_RTSCTS;
-			break;
-		case 'H':
-			fakehost = optarg;
-			break;
-		case 'i':
-			op->flags &= ~F_ISSUE;
-			break;
-		case 'I':
-			init_special_char(optarg, op);
-			op->flags |= F_INITSTRING;
-			break;
-		case 'J':
-			op->flags |= F_NOCLEAR;
-			break;
-		case 'l':
-			op->login = optarg;
-			break;
-		case 'L':
-			/* -L and -L=always have the same meaning */
-			op->clocal = CLOCAL_MODE_ALWAYS;
-			if (optarg) {
-				if (strcmp(optarg, "=always") == 0)
-					op->clocal = CLOCAL_MODE_ALWAYS;
-				else if (strcmp(optarg, "=never") == 0)
-					op->clocal = CLOCAL_MODE_NEVER;
-				else if (strcmp(optarg, "=auto") == 0)
-					op->clocal = CLOCAL_MODE_AUTO;
-				else
-					log_err(_("invalid argument of --local-line"));
-			}
-			break;
-		case 'm':
-			op->flags |= F_PARSE;
-			break;
-		case 'n':
-			op->flags |= F_NOPROMPT;
-			break;
-		case 'N':
-			op->flags |= F_NONL;
-			break;
-		case 'o':
-			op->logopt = optarg;
-			break;
-		case 'p':
-			op->flags |= F_LOGINPAUSE;
-			break;
-		case 'P':
-			op->nice = strtos32_or_err(optarg,  _("invalid nice argument"));
-			break;
-		case 'r':
-			op->chroot = optarg;
-			break;
-		case 'R':
-			op->flags |= F_HANGUP;
-			break;
-		case 's':
-			op->flags |= F_KEEPSPEED;
-			break;
-		case 't':
-			op->timeout = strtou32_or_err(optarg,  _("invalid timeout argument"));
-			break;
-		case 'U':
-			op->flags |= F_LCUC;
-			break;
-		case 'w':
-			op->flags |= F_WAITCRLF;
-			break;
-		case NOHINTS_OPTION:
-			op->flags |= F_NOHINTS;
-			break;
-		case NOHOSTNAME_OPTION:
-			op->flags |= F_NOHOSTNAME;
-			break;
-		case LONGHOSTNAME_OPTION:
-			op->flags |= F_LONGHNAME;
-			break;
-		case ERASE_CHARS_OPTION:
-			op->erasechars = optarg;
-			break;
-		case KILL_CHARS_OPTION:
-			op->killchars = optarg;
-			break;
-		case RELOAD_OPTION:
-			reload_agettys();
-			exit(EXIT_SUCCESS);
-		case LIST_SPEEDS_OPTION:
-			list_speeds();
-			exit(EXIT_SUCCESS);
-		case ISSUE_SHOW_OPTION:
-			opt_show_issue = 1;
-			break;
-		case VERSION_OPTION:
-			output_version();
-			exit(EXIT_SUCCESS);
-		case HELP_OPTION:
-			usage();
-		default:
-			errtryhelp(EXIT_FAILURE);
-		}
-	}
-
-	if (opt_show_issue) {
-		show_issue(op);
-		exit(EXIT_SUCCESS);
-	}
-
-	debug("after getopt loop\n");
-
-	if (argc < optind + 1) {
-		log_warn(_("not enough arguments"));
-		errx(EXIT_FAILURE, _("not enough arguments"));
-	}
-
-	/* Accept "tty", "baudrate tty", and "tty baudrate". */
-	if (is_speed(argv[optind])) {
-		/* Assume BSD style speed. */
-		parse_speeds(op, argv[optind++]);
-		if (argc < optind + 1) {
-			log_warn(_("not enough arguments"));
-			errx(EXIT_FAILURE, _("not enough arguments"));
-		}
-		op->tty = argv[optind++];
-	} else {
-		op->tty = argv[optind++];
-		if (argc > optind) {
-			char *v = argv[optind];
-			if (is_speed(v)) {
-				parse_speeds(op, v);
-				optind++;
-			}
-		}
-	}
-
-	/* On virtual console remember the line which is used for */
-	if (strncmp(op->tty, "tty", 3) == 0 &&
-	    strspn(op->tty + 3, "0123456789") == strlen(op->tty+3))
-		op->vcline = op->tty+3;
-
-	if (argc > optind && argv[optind])
-		op->term = argv[optind];
-
-	debug("exiting parseargs\n");
+    int c;
+    int opt_show_issue = 0;
+
+    enum
+    {
+        VERSION_OPTION = CHAR_MAX + 1,
+        NOHINTS_OPTION,
+        NOHOSTNAME_OPTION,
+        LONGHOSTNAME_OPTION,
+        HELP_OPTION,
+        ERASE_CHARS_OPTION,
+        KILL_CHARS_OPTION,
+        RELOAD_OPTION,
+        LIST_SPEEDS_OPTION,
+        ISSUE_SHOW_OPTION,
+    };
+    const struct option longopts[]
+        = {{"8bits", no_argument, NULL, '8'},
+           {"autologin", required_argument, NULL, 'a'},
+           {"noreset", no_argument, NULL, 'c'},
+           {"chdir", required_argument, NULL, 'C'},
+           {"delay", required_argument, NULL, 'd'},
+           {"remote", no_argument, NULL, 'E'},
+           {"issue-file", required_argument, NULL, 'f'},
+           {"show-issue", no_argument, NULL, ISSUE_SHOW_OPTION},
+           {"flow-control", no_argument, NULL, 'h'},
+           {"host", required_argument, NULL, 'H'},
+           {"noissue", no_argument, NULL, 'i'},
+           {"init-string", required_argument, NULL, 'I'},
+           {"noclear", no_argument, NULL, 'J'},
+           {"login-program", required_argument, NULL, 'l'},
+           {"local-line", optional_argument, NULL, 'L'},
+           {"extract-baud", no_argument, NULL, 'm'},
+           {"list-speeds", no_argument, NULL, LIST_SPEEDS_OPTION},
+           {"skip-login", no_argument, NULL, 'n'},
+           {"nonewline", no_argument, NULL, 'N'},
+           {"login-options", required_argument, NULL, 'o'},
+           {"login-pause", no_argument, NULL, 'p'},
+           {"nice", required_argument, NULL, 'P'},
+           {"chroot", required_argument, NULL, 'r'},
+           {"hangup", no_argument, NULL, 'R'},
+           {"keep-baud", no_argument, NULL, 's'},
+           {"timeout", required_argument, NULL, 't'},
+           {"detect-case", no_argument, NULL, 'U'},
+           {"wait-cr", no_argument, NULL, 'w'},
+           {"nohints", no_argument, NULL, NOHINTS_OPTION},
+           {"nohostname", no_argument, NULL, NOHOSTNAME_OPTION},
+           {"long-hostname", no_argument, NULL, LONGHOSTNAME_OPTION},
+           {"reload", no_argument, NULL, RELOAD_OPTION},
+           {"version", no_argument, NULL, VERSION_OPTION},
+           {"help", no_argument, NULL, HELP_OPTION},
+           {"erase-chars", required_argument, NULL, ERASE_CHARS_OPTION},
+           {"kill-chars", required_argument, NULL, KILL_CHARS_OPTION},
+           {NULL, 0, NULL, 0}};
+
+    while (
+        (c = getopt_long(argc, argv, "8a:cC:d:Ef:hH:iI:Jl:L::mnNo:pP:r:Rst:Uw",
+                         longopts, NULL))
+        != -1)
+    {
+        switch (c)
+        {
+            case '8': op->flags |= F_EIGHTBITS; break;
+            case 'a': op->autolog = optarg; break;
+            case 'c': op->flags |= F_KEEPCFLAGS; break;
+            case 'C': op->chdir = optarg; break;
+            case 'd':
+                op->delay
+                    = strtou32_or_err(optarg, _("invalid delay argument"));
+                break;
+            case 'E': op->flags |= F_REMOTE; break;
+            case 'f': op->issue = optarg; break;
+            case 'h': op->flags |= F_RTSCTS; break;
+            case 'H': fakehost = optarg; break;
+            case 'i': op->flags &= ~F_ISSUE; break;
+            case 'I':
+                init_special_char(optarg, op);
+                op->flags |= F_INITSTRING;
+                break;
+            case 'J': op->flags |= F_NOCLEAR; break;
+            case 'l': op->login = optarg; break;
+            case 'L':
+                /* -L and -L=always have the same meaning */
+                op->clocal = CLOCAL_MODE_ALWAYS;
+                if (optarg)
+                {
+                    if (strcmp(optarg, "=always") == 0)
+                        op->clocal = CLOCAL_MODE_ALWAYS;
+                    else if (strcmp(optarg, "=never") == 0)
+                        op->clocal = CLOCAL_MODE_NEVER;
+                    else if (strcmp(optarg, "=auto") == 0)
+                        op->clocal = CLOCAL_MODE_AUTO;
+                    else log_err(_("invalid argument of --local-line"));
+                }
+                break;
+            case 'm': op->flags |= F_PARSE; break;
+            case 'n': op->flags |= F_NOPROMPT; break;
+            case 'N': op->flags |= F_NONL; break;
+            case 'o': op->logopt = optarg; break;
+            case 'p': op->flags |= F_LOGINPAUSE; break;
+            case 'P':
+                op->nice = strtos32_or_err(optarg, _("invalid nice argument"));
+                break;
+            case 'r': op->chroot = optarg; break;
+            case 'R': op->flags |= F_HANGUP; break;
+            case 's': op->flags |= F_KEEPSPEED; break;
+            case 't':
+                op->timeout
+                    = strtou32_or_err(optarg, _("invalid timeout argument"));
+                break;
+            case 'U': op->flags |= F_LCUC; break;
+            case 'w': op->flags |= F_WAITCRLF; break;
+            case NOHINTS_OPTION: op->flags |= F_NOHINTS; break;
+            case NOHOSTNAME_OPTION: op->flags |= F_NOHOSTNAME; break;
+            case LONGHOSTNAME_OPTION: op->flags |= F_LONGHNAME; break;
+            case ERASE_CHARS_OPTION: op->erasechars = optarg; break;
+            case KILL_CHARS_OPTION: op->killchars = optarg; break;
+            case RELOAD_OPTION: reload_agettys(); exit(EXIT_SUCCESS);
+            case LIST_SPEEDS_OPTION: list_speeds(); exit(EXIT_SUCCESS);
+            case ISSUE_SHOW_OPTION: opt_show_issue = 1; break;
+            case VERSION_OPTION: output_version(); exit(EXIT_SUCCESS);
+            case HELP_OPTION: usage();
+            default: errtryhelp(EXIT_FAILURE);
+        }
+    }
+
+    if (opt_show_issue)
+    {
+        show_issue(op);
+        exit(EXIT_SUCCESS);
+    }
+
+    debug("after getopt loop\n");
+
+    if (argc < optind + 1)
+    {
+        log_warn(_("not enough arguments"));
+        errx(EXIT_FAILURE, _("not enough arguments"));
+    }
+
+    /* Accept "tty", "baudrate tty", and "tty baudrate". */
+    if (is_speed(argv[optind]))
+    {
+        /* Assume BSD style speed. */
+        parse_speeds(op, argv[optind++]);
+        if (argc < optind + 1)
+        {
+            log_warn(_("not enough arguments"));
+            errx(EXIT_FAILURE, _("not enough arguments"));
+        }
+        op->tty = argv[optind++];
+    }
+    else
+    {
+        op->tty = argv[optind++];
+        if (argc > optind)
+        {
+            char* v = argv[optind];
+            if (is_speed(v))
+            {
+                parse_speeds(op, v);
+                optind++;
+            }
+        }
+    }
+
+    /* On virtual console remember the line which is used for */
+    if (strncmp(op->tty, "tty", 3) == 0
+        && strspn(op->tty + 3, "0123456789") == strlen(op->tty + 3))
+        op->vcline = op->tty + 3;
+
+    if (argc > optind && argv[optind]) op->term = argv[optind];
+
+    debug("exiting parseargs\n");
 }
 
 /* Parse alternate baud rates. */
-static void parse_speeds(struct options *op, char *arg)
+static void parse_speeds(struct options* op, char* arg)
 {
-	char *cp;
-	char *str = strdup(arg);
-
-	if (!str)
-		log_err(_("failed to allocate memory: %m"));
-
-	debug("entered parse_speeds:\n");
-	for (cp = strtok(str, ","); cp != NULL; cp = strtok((char *)0, ",")) {
-		if ((op->speeds[op->numspeed++] = bcode(cp)) <= 0)
-			log_err(_("bad speed: %s"), cp);
-		if (op->numspeed >= MAX_SPEED)
-			log_err(_("too many alternate speeds"));
-	}
-	debug("exiting parsespeeds\n");
-	free(str);
+    char* cp;
+    char* str = strdup(arg);
+
+    if (!str) log_err(_("failed to allocate memory: %m"));
+
+    debug("entered parse_speeds:\n");
+    for (cp = strtok(str, ","); cp != NULL; cp = strtok((char*)0, ","))
+    {
+        if ((op->speeds[op->numspeed++] = bcode(cp)) <= 0)
+            log_err(_("bad speed: %s"), cp);
+        if (op->numspeed >= MAX_SPEED) log_err(_("too many alternate speeds"));
+    }
+    debug("exiting parsespeeds\n");
+    free(str);
 }
 
-#ifdef	SYSV_STYLE
+#ifdef SYSV_STYLE
 
 /* Update our utmp entry. */
-static void update_utmp(struct options *op)
+static void update_utmp(struct options* op)
 {
-	struct utmpx ut;
-	time_t t;
-	pid_t pid = getpid();
-	pid_t sid = getsid(0);
-	char *vcline = op->vcline;
-	char *line   = op->tty;
-	struct utmpx *utp;
-
-	/*
-	 * The utmp file holds miscellaneous information about things started by
-	 * /sbin/init and other system-related events. Our purpose is to update
-	 * the utmp entry for the current process, in particular the process type
-	 * and the tty line we are listening to. Return successfully only if the
-	 * utmp file can be opened for update, and if we are able to find our
-	 * entry in the utmp file.
-	 */
-	utmpxname(_PATH_UTMP);
-	setutxent();
-
-	/*
-	 * Find my pid in utmp.
-	 *
-	 * FIXME: Earlier (when was that?) code here tested only utp->ut_type !=
-	 * INIT_PROCESS, so maybe the >= here should be >.
-	 *
-	 * FIXME: The present code is taken from login.c, so if this is changed,
-	 * maybe login has to be changed as well (is this true?).
-	 */
-	while ((utp = getutxent()))
-		if (utp->ut_pid == pid
-				&& utp->ut_type >= INIT_PROCESS
-				&& utp->ut_type <= DEAD_PROCESS)
-			break;
-
-	if (utp) {
-		memcpy(&ut, utp, sizeof(ut));
-	} else {
-		/* Some inits do not initialize utmp. */
-		memset(&ut, 0, sizeof(ut));
-		if (vcline && *vcline)
-			/* Standard virtual console devices */
-			str2memcpy(ut.ut_id, vcline, sizeof(ut.ut_id));
-		else {
-			size_t len = strlen(line);
-			char * ptr;
-			if (len >= sizeof(ut.ut_id))
-				ptr = line + len - sizeof(ut.ut_id);
-			else
-				ptr = line;
-			str2memcpy(ut.ut_id, ptr, sizeof(ut.ut_id));
-		}
-	}
-
-	str2memcpy(ut.ut_user, "LOGIN", sizeof(ut.ut_user));
-	str2memcpy(ut.ut_line, line, sizeof(ut.ut_line));
-	if (fakehost)
-		str2memcpy(ut.ut_host, fakehost, sizeof(ut.ut_host));
-	time(&t);
-	ut.ut_tv.tv_sec = t;
-	ut.ut_type = LOGIN_PROCESS;
-	ut.ut_pid = pid;
-	ut.ut_session = sid;
-
-	pututxline(&ut);
-	endutxent();
-
-	updwtmpx(_PATH_WTMP, &ut);
+    struct utmpx  ut;
+    time_t        t;
+    pid_t         pid    = getpid();
+    pid_t         sid    = getsid(0);
+    char*         vcline = op->vcline;
+    char*         line   = op->tty;
+    struct utmpx* utp;
+
+    /*
+     * The utmp file holds miscellaneous information about things started by
+     * /sbin/init and other system-related events. Our purpose is to update
+     * the utmp entry for the current process, in particular the process type
+     * and the tty line we are listening to. Return successfully only if the
+     * utmp file can be opened for update, and if we are able to find our
+     * entry in the utmp file.
+     */
+    utmpxname(_PATH_UTMP);
+    setutxent();
+
+    /*
+     * Find my pid in utmp.
+     *
+     * FIXME: Earlier (when was that?) code here tested only utp->ut_type !=
+     * INIT_PROCESS, so maybe the >= here should be >.
+     *
+     * FIXME: The present code is taken from login.c, so if this is changed,
+     * maybe login has to be changed as well (is this true?).
+     */
+    while ((utp = getutxent()))
+        if (utp->ut_pid == pid && utp->ut_type >= INIT_PROCESS
+            && utp->ut_type <= DEAD_PROCESS)
+            break;
+
+    if (utp) { memcpy(&ut, utp, sizeof(ut)); }
+    else
+    {
+        /* Some inits do not initialize utmp. */
+        memset(&ut, 0, sizeof(ut));
+        if (vcline && *vcline) /* Standard virtual console devices */
+            str2memcpy(ut.ut_id, vcline, sizeof(ut.ut_id));
+        else
+        {
+            size_t len = strlen(line);
+            char*  ptr;
+            if (len >= sizeof(ut.ut_id)) ptr = line + len - sizeof(ut.ut_id);
+            else ptr = line;
+            str2memcpy(ut.ut_id, ptr, sizeof(ut.ut_id));
+        }
+    }
+
+    str2memcpy(ut.ut_user, "LOGIN", sizeof(ut.ut_user));
+    str2memcpy(ut.ut_line, line, sizeof(ut.ut_line));
+    if (fakehost) str2memcpy(ut.ut_host, fakehost, sizeof(ut.ut_host));
+    time(&t);
+    ut.ut_tv.tv_sec = t;
+    ut.ut_type      = LOGIN_PROCESS;
+    ut.ut_pid       = pid;
+    ut.ut_session   = sid;
+
+    pututxline(&ut);
+    endutxent();
+
+    updwtmpx(_PATH_WTMP, &ut);
 }
 
-#endif				/* SYSV_STYLE */
+#endif /* SYSV_STYLE */
 
 /* Set up tty as stdin, stdout & stderr. */
-static void open_tty(char *tty, struct termios *tp, struct options *op)
+static void open_tty(char* tty, struct termios* tp, struct options* op)
 {
-	const pid_t pid = getpid();
-	int closed = 0;
+    const pid_t pid    = getpid();
+    int         closed = 0;
 #ifndef KDGKBMODE
-	int serial;
-#endif
-
-	/* Set up new standard input, unless we are given an already opened port. */
-
-	if (strcmp(tty, "-") != 0) {
-		char buf[PATH_MAX+1];
-		struct group *gr = NULL;
-		struct stat st;
-		int fd, len;
-		pid_t tid;
-		gid_t gid = 0;
-
-		/* Use tty group if available */
-		if ((gr = getgrnam("tty")))
-			gid = gr->gr_gid;
-
-		len = snprintf(buf, sizeof(buf), "/dev/%s", tty);
-		if (len < 0 || (size_t)len >= sizeof(buf))
-			log_err(_("/dev/%s: cannot open as standard input: %m"), tty);
-
-		/* Open the tty as standard input. */
-		if ((fd = open(buf, O_RDWR|O_NOCTTY|O_NONBLOCK, 0)) < 0)
-			log_err(_("/dev/%s: cannot open as standard input: %m"), tty);
-
-		/*
-		 * There is always a race between this reset and the call to
-		 * vhangup() that s.o. can use to get access to your tty.
-		 * Linux login(1) will change tty permissions. Use root owner and group
-		 * with permission -rw------- for the period between getty and login.
-		 */
-		if (fchown(fd, 0, gid) || fchmod(fd, (gid ? 0620 : 0600))) {
-			if (errno == EROFS)
-				log_warn("%s: %m", buf);
-			else
-				log_err("%s: %m", buf);
-		}
-
-		/* Sanity checks... */
-		if (fstat(fd, &st) < 0)
-			log_err("%s: %m", buf);
-		if ((st.st_mode & S_IFMT) != S_IFCHR)
-			log_err(_("/dev/%s: not a character device"), tty);
-		if (!isatty(fd))
-			log_err(_("/dev/%s: not a tty"), tty);
-
-		if (((tid = tcgetsid(fd)) < 0) || (pid != tid)) {
-			if (ioctl(fd, TIOCSCTTY, 1) == -1)
-				log_warn(_("/dev/%s: cannot get controlling tty: %m"), tty);
-		}
-
-		close(STDIN_FILENO);
-		errno = 0;
-
-		if (op->flags & F_HANGUP) {
-
-			if (ioctl(fd, TIOCNOTTY))
-				debug("TIOCNOTTY ioctl failed\n");
-
-			/*
-			 * Let's close all file descriptors before vhangup
-			 * https://lkml.org/lkml/2012/6/5/145
-			 */
-			close(fd);
-			close(STDOUT_FILENO);
-			close(STDERR_FILENO);
-			errno = 0;
-			closed = 1;
-
-			if (vhangup())
-				log_err(_("/dev/%s: vhangup() failed: %m"), tty);
-		} else
-			close(fd);
-
-		debug("open(2)\n");
-		if (open(buf, O_RDWR|O_NOCTTY|O_NONBLOCK, 0) != 0)
-			log_err(_("/dev/%s: cannot open as standard input: %m"), tty);
-
-		if (((tid = tcgetsid(STDIN_FILENO)) < 0) || (pid != tid)) {
-			if (ioctl(STDIN_FILENO, TIOCSCTTY, 1) == -1)
-				log_warn(_("/dev/%s: cannot get controlling tty: %m"), tty);
-		}
-
-	} else {
-
-		/*
-		 * Standard input should already be connected to an open port. Make
-		 * sure it is open for read/write.
-		 */
-
-		if ((fcntl(STDIN_FILENO, F_GETFL, 0) & O_RDWR) != O_RDWR)
-			log_err(_("%s: not open for read/write"), tty);
-
-	}
-
-	if (tcsetpgrp(STDIN_FILENO, pid))
-		log_warn(_("/dev/%s: cannot set process group: %m"), tty);
-
-	/* Get rid of the present outputs. */
-	if (!closed) {
-		close(STDOUT_FILENO);
-		close(STDERR_FILENO);
-		errno = 0;
-	}
-
-	/* Set up standard output and standard error file descriptors. */
-	debug("duping\n");
-
-	/* set up stdout and stderr */
-	if (dup(STDIN_FILENO) != 1 || dup(STDIN_FILENO) != 2)
-		log_err(_("%s: dup problem: %m"), tty);
-
-	/* make stdio unbuffered for slow modem lines */
-	setvbuf(stdout, NULL, _IONBF, 0);
-
-	/*
-	 * The following ioctl will fail if stdin is not a tty, but also when
-	 * there is noise on the modem control lines. In the latter case, the
-	 * common course of action is (1) fix your cables (2) give the modem
-	 * more time to properly reset after hanging up.
-	 *
-	 * SunOS users can achieve (2) by patching the SunOS kernel variable
-	 * "zsadtrlow" to a larger value; 5 seconds seems to be a good value.
-	 * http://www.sunmanagers.org/archives/1993/0574.html
-	 */
-	memset(tp, 0, sizeof(struct termios));
-	if (tcgetattr(STDIN_FILENO, tp) < 0)
-		log_err(_("%s: failed to get terminal attributes: %m"), tty);
-
-#if defined (__s390__) || defined (__s390x__)
-	if (!op->term) {
-	        /*
-		 * Special terminal on first serial line on a S/390(x) which
-		 * is due legacy reasons a block terminal of type 3270 or
-		 * higher.  Whereas the second serial line on a S/390(x) is
-		 * a real character terminal which is compatible with VT220.
-		 */
-		if (strcmp(op->tty, "ttyS0") == 0)		/* linux/drivers/s390/char/con3215.c */
-			op->term = DEFAULT_TTYS0;
-		else if (strncmp(op->tty, "3270/tty", 8) == 0)	/* linux/drivers/s390/char/con3270.c */
-			op->term = DEFAULT_TTY32;
-		else if (strcmp(op->tty, "ttyS1") == 0)		/* linux/drivers/s390/char/sclp_vt220.c */
-			op->term = DEFAULT_TTYS1;
-	}
+    int serial;
+#endif
+
+    /* Set up new standard input, unless we are given an already opened port. */
+
+    if (strcmp(tty, "-") != 0)
+    {
+        char          buf[PATH_MAX + 1];
+        struct group* gr = NULL;
+        struct stat   st;
+        int           fd, len;
+        pid_t         tid;
+        gid_t         gid = 0;
+
+        /* Use tty group if available */
+        if ((gr = getgrnam("tty"))) gid = gr->gr_gid;
+
+        len = snprintf(buf, sizeof(buf), "/dev/%s", tty);
+        if (len < 0 || (size_t)len >= sizeof(buf))
+            log_err(_("/dev/%s: cannot open as standard input: %m"), tty);
+
+        /* Open the tty as standard input. */
+        if ((fd = open(buf, O_RDWR | O_NOCTTY | O_NONBLOCK, 0)) < 0)
+            log_err(_("/dev/%s: cannot open as standard input: %m"), tty);
+
+        /*
+         * There is always a race between this reset and the call to
+         * vhangup() that s.o. can use to get access to your tty.
+         * Linux login(1) will change tty permissions. Use root owner and group
+         * with permission -rw------- for the period between getty and login.
+         */
+        if (fchown(fd, 0, gid) || fchmod(fd, (gid ? 0620 : 0600)))
+        {
+            if (errno == EROFS) log_warn("%s: %m", buf);
+            else log_err("%s: %m", buf);
+        }
+
+        /* Sanity checks... */
+        if (fstat(fd, &st) < 0) log_err("%s: %m", buf);
+        if ((st.st_mode & S_IFMT) != S_IFCHR)
+            log_err(_("/dev/%s: not a character device"), tty);
+        if (!isatty(fd)) log_err(_("/dev/%s: not a tty"), tty);
+
+        if (((tid = tcgetsid(fd)) < 0) || (pid != tid))
+        {
+            if (ioctl(fd, TIOCSCTTY, 1) == -1)
+                log_warn(_("/dev/%s: cannot get controlling tty: %m"), tty);
+        }
+
+        close(STDIN_FILENO);
+        errno = 0;
+
+        if (op->flags & F_HANGUP)
+        {
+
+            if (ioctl(fd, TIOCNOTTY)) debug("TIOCNOTTY ioctl failed\n");
+
+            /*
+             * Let's close all file descriptors before vhangup
+             * https://lkml.org/lkml/2012/6/5/145
+             */
+            close(fd);
+            close(STDOUT_FILENO);
+            close(STDERR_FILENO);
+            errno  = 0;
+            closed = 1;
+
+            if (vhangup()) log_err(_("/dev/%s: vhangup() failed: %m"), tty);
+        }
+        else close(fd);
+
+        debug("open(2)\n");
+        if (open(buf, O_RDWR | O_NOCTTY | O_NONBLOCK, 0) != 0)
+            log_err(_("/dev/%s: cannot open as standard input: %m"), tty);
+
+        if (((tid = tcgetsid(STDIN_FILENO)) < 0) || (pid != tid))
+        {
+            if (ioctl(STDIN_FILENO, TIOCSCTTY, 1) == -1)
+                log_warn(_("/dev/%s: cannot get controlling tty: %m"), tty);
+        }
+    }
+    else
+    {
+
+        /*
+         * Standard input should already be connected to an open port. Make
+         * sure it is open for read/write.
+         */
+
+        if ((fcntl(STDIN_FILENO, F_GETFL, 0) & O_RDWR) != O_RDWR)
+            log_err(_("%s: not open for read/write"), tty);
+    }
+
+    if (tcsetpgrp(STDIN_FILENO, pid))
+        log_warn(_("/dev/%s: cannot set process group: %m"), tty);
+
+    /* Get rid of the present outputs. */
+    if (!closed)
+    {
+        close(STDOUT_FILENO);
+        close(STDERR_FILENO);
+        errno = 0;
+    }
+
+    /* Set up standard output and standard error file descriptors. */
+    debug("duping\n");
+
+    /* set up stdout and stderr */
+    if (dup(STDIN_FILENO) != 1 || dup(STDIN_FILENO) != 2)
+        log_err(_("%s: dup problem: %m"), tty);
+
+    /* make stdio unbuffered for slow modem lines */
+    setvbuf(stdout, NULL, _IONBF, 0);
+
+    /*
+     * The following ioctl will fail if stdin is not a tty, but also when
+     * there is noise on the modem control lines. In the latter case, the
+     * common course of action is (1) fix your cables (2) give the modem
+     * more time to properly reset after hanging up.
+     *
+     * SunOS users can achieve (2) by patching the SunOS kernel variable
+     * "zsadtrlow" to a larger value; 5 seconds seems to be a good value.
+     * http://www.sunmanagers.org/archives/1993/0574.html
+     */
+    memset(tp, 0, sizeof(struct termios));
+    if (tcgetattr(STDIN_FILENO, tp) < 0)
+        log_err(_("%s: failed to get terminal attributes: %m"), tty);
+
+#if defined(__s390__) || defined(__s390x__)
+    if (!op->term)
+    {
+        /*
+         * Special terminal on first serial line on a S/390(x) which
+         * is due legacy reasons a block terminal of type 3270 or
+         * higher.  Whereas the second serial line on a S/390(x) is
+         * a real character terminal which is compatible with VT220.
+         */
+        if (strcmp(op->tty, "ttyS0")
+            == 0) /* linux/drivers/s390/char/con3215.c */
+            op->term = DEFAULT_TTYS0;
+        else if (strncmp(op->tty, "3270/tty", 8)
+                 == 0) /* linux/drivers/s390/char/con3270.c */
+            op->term = DEFAULT_TTY32;
+        else if (strcmp(op->tty, "ttyS1")
+                 == 0) /* linux/drivers/s390/char/sclp_vt220.c */
+            op->term = DEFAULT_TTYS1;
+    }
 #endif
 
 #if defined(__FreeBSD_kernel__)
-	login_tty (0);
+    login_tty(0);
 #endif
 
-	/*
-	 * Detect if this is a virtual console or serial/modem line.
-	 * In case of a virtual console the ioctl KDGKBMODE succeeds
-	 * whereas on other lines it will fails.
-	 */
+    /*
+     * Detect if this is a virtual console or serial/modem line.
+     * In case of a virtual console the ioctl KDGKBMODE succeeds
+     * whereas on other lines it will fails.
+     */
 #ifdef KDGKBMODE
-	if (ioctl(STDIN_FILENO, KDGKBMODE, &op->kbmode) == 0)
+    if (ioctl(STDIN_FILENO, KDGKBMODE, &op->kbmode) == 0)
 #else
-	if (ioctl(STDIN_FILENO, TIOCMGET, &serial) < 0 && (errno == EINVAL))
-#endif
-	{
-		op->flags |= F_VCONSOLE;
-		if (!op->term)
-			op->term = DEFAULT_VCTERM;
-	} else {
+    if (ioctl(STDIN_FILENO, TIOCMGET, &serial) < 0 && (errno == EINVAL))
+#endif
+    {
+        op->flags |= F_VCONSOLE;
+        if (!op->term) op->term = DEFAULT_VCTERM;
+    }
+    else
+    {
 #ifdef K_RAW
-		op->kbmode = K_RAW;
+        op->kbmode = K_RAW;
 #endif
-		if (!op->term)
-			op->term = DEFAULT_STERM;
-	}
+        if (!op->term) op->term = DEFAULT_STERM;
+    }
 
-	if (setenv("TERM", op->term, 1) != 0)
-		log_err(_("failed to set the %s environment variable"), "TERM");
+    if (setenv("TERM", op->term, 1) != 0)
+        log_err(_("failed to set the %s environment variable"), "TERM");
 }
 
 /* Initialize termios settings. */
 static void termio_clear(int fd)
 {
-	/*
-	 * Do not write a full reset (ESC c) because this destroys
-	 * the unicode mode again if the terminal was in unicode
-	 * mode.  Also it clears the CONSOLE_MAGIC features which
-	 * are required for some languages/console-fonts.
-	 * Just put the cursor to the home position (ESC [ H),
-	 * erase everything below the cursor (ESC [ J), and set the
-	 * scrolling region to the full window (ESC [ r)
-	 */
-	write_all(fd, "\033[r\033[H\033[J", 9);
+    /*
+     * Do not write a full reset (ESC c) because this destroys
+     * the unicode mode again if the terminal was in unicode
+     * mode.  Also it clears the CONSOLE_MAGIC features which
+     * are required for some languages/console-fonts.
+     * Just put the cursor to the home position (ESC [ H),
+     * erase everything below the cursor (ESC [ J), and set the
+     * scrolling region to the full window (ESC [ r)
+     */
+    write_all(fd, "\033[r\033[H\033[J", 9);
 }
 
 /* Initialize termios settings. */
-static void termio_init(struct options *op, struct termios *tp)
+static void termio_init(struct options* op, struct termios* tp)
 {
-	speed_t ispeed, ospeed;
-	struct winsize ws;
+    speed_t        ispeed, ospeed;
+    struct winsize ws;
 #ifdef USE_PLYMOUTH_SUPPORT
-	struct termios lock;
-	int i =  (plymouth_command(MAGIC_PING) == 0) ? PLYMOUTH_TERMIOS_FLAGS_DELAY : 0;
-	if (i)
-		plymouth_command(MAGIC_QUIT);
-	while (i-- > 0) {
-		/*
-		 * Even with TTYReset=no it seems with systemd or plymouth
-		 * the termios flags become changed from under the first
-		 * agetty on a serial system console as the flags are locked.
-		 */
-		memset(&lock, 0, sizeof(struct termios));
-		if (ioctl(STDIN_FILENO, TIOCGLCKTRMIOS, &lock) < 0)
-			break;
-		if (!lock.c_iflag && !lock.c_oflag && !lock.c_cflag && !lock.c_lflag)
-			break;
-		debug("termios locked\n");
-		sleep(1);
-	}
-	memset(&lock, 0, sizeof(struct termios));
-	ioctl(STDIN_FILENO, TIOCSLCKTRMIOS, &lock);
-#endif
-
-	if (op->flags & F_VCONSOLE) {
+    struct termios lock;
+    int i = (plymouth_command(MAGIC_PING) == 0) ? PLYMOUTH_TERMIOS_FLAGS_DELAY
+                                                : 0;
+    if (i) plymouth_command(MAGIC_QUIT);
+    while (i-- > 0)
+    {
+        /*
+         * Even with TTYReset=no it seems with systemd or plymouth
+         * the termios flags become changed from under the first
+         * agetty on a serial system console as the flags are locked.
+         */
+        memset(&lock, 0, sizeof(struct termios));
+        if (ioctl(STDIN_FILENO, TIOCGLCKTRMIOS, &lock) < 0) break;
+        if (!lock.c_iflag && !lock.c_oflag && !lock.c_cflag && !lock.c_lflag)
+            break;
+        debug("termios locked\n");
+        sleep(1);
+    }
+    memset(&lock, 0, sizeof(struct termios));
+    ioctl(STDIN_FILENO, TIOCSLCKTRMIOS, &lock);
+#endif
+
+    if (op->flags & F_VCONSOLE)
+    {
 #if defined(IUTF8) && defined(KDGKBMODE)
-		switch(op->kbmode) {
-		case K_UNICODE:
-			setlocale(LC_CTYPE, "C.UTF-8");
-			op->flags |= F_UTF8;
-			break;
-		case K_RAW:
-		case K_MEDIUMRAW:
-		case K_XLATE:
-		default:
-			setlocale(LC_CTYPE, "POSIX");
-			op->flags &= ~F_UTF8;
-			break;
-		}
+        switch (op->kbmode)
+        {
+            case K_UNICODE:
+                setlocale(LC_CTYPE, "C.UTF-8");
+                op->flags |= F_UTF8;
+                break;
+            case K_RAW:
+            case K_MEDIUMRAW:
+            case K_XLATE:
+            default:
+                setlocale(LC_CTYPE, "POSIX");
+                op->flags &= ~F_UTF8;
+                break;
+        }
 #else
-		setlocale(LC_CTYPE, "POSIX");
-		op->flags &= ~F_UTF8;
-#endif
-		reset_vc(op, tp, 0);
-
-		if ((tp->c_cflag & (CS8|PARODD|PARENB)) == CS8)
-			op->flags |= F_EIGHTBITS;
-
-		if ((op->flags & F_NOCLEAR) == 0)
-			termio_clear(STDOUT_FILENO);
-		return;
-	}
-
-	/*
-	 * Serial line
-	 */
-
-	if (op->flags & F_KEEPSPEED || !op->numspeed) {
-		/* Save the original setting. */
-		ispeed = cfgetispeed(tp);
-		ospeed = cfgetospeed(tp);
-
-		/* Save also the original speed to array of the speeds to make
-		 * it possible to return the original after unexpected BREAKs.
-		 */
-		if (op->numspeed)
-			op->speeds[op->numspeed++] = ispeed ? ispeed :
-						     ospeed ? ospeed :
-						     TTYDEF_SPEED;
-		if (!ispeed)
-			ispeed = TTYDEF_SPEED;
-		if (!ospeed)
-			ospeed = TTYDEF_SPEED;
-	} else {
-		ospeed = ispeed = op->speeds[FIRST_SPEED];
-	}
-
-	/*
-	 * Initial termios settings: 8-bit characters, raw-mode, blocking i/o.
-	 * Special characters are set after we have read the login name; all
-	 * reads will be done in raw mode anyway. Errors will be dealt with
-	 * later on.
-	 */
-
-	/* The default is set c_iflag in termio_final() according to chardata.
-	 * Unfortunately, the chardata are not set according to the serial line
-	 * if --autolog is enabled. In this case we do not read from the line
-	 * at all. The best what we can do in this case is to keep c_iflag
-	 * unmodified for --autolog.
-	 */
-	if (!op->autolog) {
+        setlocale(LC_CTYPE, "POSIX");
+        op->flags &= ~F_UTF8;
+#endif
+        reset_vc(op, tp, 0);
+
+        if ((tp->c_cflag & (CS8 | PARODD | PARENB)) == CS8)
+            op->flags |= F_EIGHTBITS;
+
+        if ((op->flags & F_NOCLEAR) == 0) termio_clear(STDOUT_FILENO);
+        return;
+    }
+
+    /*
+     * Serial line
+     */
+
+    if (op->flags & F_KEEPSPEED || !op->numspeed)
+    {
+        /* Save the original setting. */
+        ispeed = cfgetispeed(tp);
+        ospeed = cfgetospeed(tp);
+
+        /* Save also the original speed to array of the speeds to make
+         * it possible to return the original after unexpected BREAKs.
+         */
+        if (op->numspeed)
+            op->speeds[op->numspeed++] = ispeed ? ispeed
+                                       : ospeed ? ospeed
+                                                : TTYDEF_SPEED;
+        if (!ispeed) ispeed = TTYDEF_SPEED;
+        if (!ospeed) ospeed = TTYDEF_SPEED;
+    }
+    else { ospeed = ispeed = op->speeds[FIRST_SPEED]; }
+
+    /*
+     * Initial termios settings: 8-bit characters, raw-mode, blocking i/o.
+     * Special characters are set after we have read the login name; all
+     * reads will be done in raw mode anyway. Errors will be dealt with
+     * later on.
+     */
+
+    /* The default is set c_iflag in termio_final() according to chardata.
+     * Unfortunately, the chardata are not set according to the serial line
+     * if --autolog is enabled. In this case we do not read from the line
+     * at all. The best what we can do in this case is to keep c_iflag
+     * unmodified for --autolog.
+     */
+    if (!op->autolog)
+    {
 #ifdef IUTF8
-		tp->c_iflag = tp->c_iflag & IUTF8;
-		if (tp->c_iflag & IUTF8)
-			op->flags |= F_UTF8;
+        tp->c_iflag = tp->c_iflag & IUTF8;
+        if (tp->c_iflag & IUTF8) op->flags |= F_UTF8;
 #else
-		tp->c_iflag = 0;
-#endif
-	}
-
-	tp->c_lflag = 0;
-	tp->c_oflag &= OPOST | ONLCR;
-
-	if ((op->flags & F_KEEPCFLAGS) == 0)
-		tp->c_cflag = CS8 | HUPCL | CREAD | (tp->c_cflag & CLOCAL);
-
-	/*
-	 * Note that the speed is stored in the c_cflag termios field, so we have
-	 * set the speed always when the cflag is reset.
-	 */
-	cfsetispeed(tp, ispeed);
-	cfsetospeed(tp, ospeed);
-
-	/* The default is to follow setting from kernel, but it's possible
-	 * to explicitly remove/add CLOCAL flag by -L[=<mode>]*/
-	switch (op->clocal) {
-	case CLOCAL_MODE_ALWAYS:
-		tp->c_cflag |= CLOCAL;		/* -L or -L=always */
-		break;
-	case CLOCAL_MODE_NEVER:
-		tp->c_cflag &= ~CLOCAL;		/* -L=never */
-		break;
-	case CLOCAL_MODE_AUTO:			/* -L=auto */
-		break;
-	}
+        tp->c_iflag = 0;
+#endif
+    }
+
+    tp->c_lflag = 0;
+    tp->c_oflag &= OPOST | ONLCR;
+
+    if ((op->flags & F_KEEPCFLAGS) == 0)
+        tp->c_cflag = CS8 | HUPCL | CREAD | (tp->c_cflag & CLOCAL);
+
+    /*
+     * Note that the speed is stored in the c_cflag termios field, so we have
+     * set the speed always when the cflag is reset.
+     */
+    cfsetispeed(tp, ispeed);
+    cfsetospeed(tp, ospeed);
+
+    /* The default is to follow setting from kernel, but it's possible
+     * to explicitly remove/add CLOCAL flag by -L[=<mode>]*/
+    switch (op->clocal)
+    {
+        case CLOCAL_MODE_ALWAYS:
+            tp->c_cflag |= CLOCAL; /* -L or -L=always */
+            break;
+        case CLOCAL_MODE_NEVER:
+            tp->c_cflag &= ~CLOCAL; /* -L=never */
+            break;
+        case CLOCAL_MODE_AUTO: /* -L=auto */ break;
+    }
 
 #ifdef HAVE_STRUCT_TERMIOS_C_LINE
-	tp->c_line = 0;
+    tp->c_line = 0;
 #endif
-	tp->c_cc[VMIN] = 1;
-	tp->c_cc[VTIME] = 0;
+    tp->c_cc[VMIN]  = 1;
+    tp->c_cc[VTIME] = 0;
 
-	/* Check for terminal size and if not found set default */
-	if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == 0) {
-		if (ws.ws_row == 0)
-			ws.ws_row = 24;
-		if (ws.ws_col == 0)
-			ws.ws_col = 80;
-		if (ioctl(STDIN_FILENO, TIOCSWINSZ, &ws))
-			debug("TIOCSWINSZ ioctl failed\n");
-	}
+    /* Check for terminal size and if not found set default */
+    if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == 0)
+    {
+        if (ws.ws_row == 0) ws.ws_row = 24;
+        if (ws.ws_col == 0) ws.ws_col = 80;
+        if (ioctl(STDIN_FILENO, TIOCSWINSZ, &ws))
+            debug("TIOCSWINSZ ioctl failed\n");
+    }
 
-	/* Optionally enable hardware flow control. */
-#ifdef	CRTSCTS
-	if (op->flags & F_RTSCTS)
-		tp->c_cflag |= CRTSCTS;
+    /* Optionally enable hardware flow control. */
+#ifdef CRTSCTS
+    if (op->flags & F_RTSCTS) tp->c_cflag |= CRTSCTS;
 #endif
-	 /* Flush input and output queues, important for modems! */
-	tcflush(STDIN_FILENO, TCIOFLUSH);
+    /* Flush input and output queues, important for modems! */
+    tcflush(STDIN_FILENO, TCIOFLUSH);
 
-	if (tcsetattr(STDIN_FILENO, TCSANOW, tp))
-		log_warn(_("setting terminal attributes failed: %m"));
+    if (tcsetattr(STDIN_FILENO, TCSANOW, tp))
+        log_warn(_("setting terminal attributes failed: %m"));
 
-	/* Go to blocking input even in local mode. */
-	fcntl(STDIN_FILENO, F_SETFL,
-	      fcntl(STDIN_FILENO, F_GETFL, 0) & ~O_NONBLOCK);
+    /* Go to blocking input even in local mode. */
+    fcntl(STDIN_FILENO, F_SETFL, fcntl(STDIN_FILENO, F_GETFL, 0) & ~O_NONBLOCK);
 
-	debug("term_io 2\n");
+    debug("term_io 2\n");
 }
 
 /* Reset virtual console on stdin to its defaults */
-static void reset_vc(const struct options *op, struct termios *tp, int canon)
+static void reset_vc(const struct options* op, struct termios* tp, int canon)
 {
-	int fl = 0;
+    int fl = 0;
 
-	fl |= (op->flags & F_KEEPCFLAGS) == 0 ? 0 : UL_TTY_KEEPCFLAGS;
-	fl |= (op->flags & F_UTF8)       == 0 ? 0 : UL_TTY_UTF8;
+    fl |= (op->flags & F_KEEPCFLAGS) == 0 ? 0 : UL_TTY_KEEPCFLAGS;
+    fl |= (op->flags & F_UTF8) == 0 ? 0 : UL_TTY_UTF8;
 
-	reset_virtual_console(tp, fl);
+    reset_virtual_console(tp, fl);
 
 #ifdef AGETTY_RELOAD
-	/*
-	 * Discard all the flags that makes the line go canonical with echoing.
-	 * We need to know when the user starts typing.
-	 */
-	if (canon == 0)
-		tp->c_lflag = 0;
+    /*
+     * Discard all the flags that makes the line go canonical with echoing.
+     * We need to know when the user starts typing.
+     */
+    if (canon == 0) tp->c_lflag = 0;
 #endif
 
-	if (tcsetattr(STDIN_FILENO, TCSADRAIN, tp))
-		log_warn(_("setting terminal attributes failed: %m"));
+    if (tcsetattr(STDIN_FILENO, TCSADRAIN, tp))
+        log_warn(_("setting terminal attributes failed: %m"));
 
-	/* Go to blocking input even in local mode. */
-	fcntl(STDIN_FILENO, F_SETFL,
-	      fcntl(STDIN_FILENO, F_GETFL, 0) & ~O_NONBLOCK);
+    /* Go to blocking input even in local mode. */
+    fcntl(STDIN_FILENO, F_SETFL, fcntl(STDIN_FILENO, F_GETFL, 0) & ~O_NONBLOCK);
 }
 
 /* Extract baud rate from modem status message. */
-static void auto_baud(struct termios *tp)
+static void auto_baud(struct termios* tp)
 {
-	speed_t speed;
-	int vmin;
-	unsigned iflag;
-	char buf[BUFSIZ];
-	char *bp;
-	int nread;
-
-	/*
-	 * This works only if the modem produces its status code AFTER raising
-	 * the DCD line, and if the computer is fast enough to set the proper
-	 * baud rate before the message has gone by. We expect a message of the
-	 * following format:
-	 *
-	 * <junk><number><junk>
-	 *
-	 * The number is interpreted as the baud rate of the incoming call. If the
-	 * modem does not tell us the baud rate within one second, we will keep
-	 * using the current baud rate. It is advisable to enable BREAK
-	 * processing (comma-separated list of baud rates) if the processing of
-	 * modem status messages is enabled.
-	 */
-
-	/*
-	 * Use 7-bit characters, don't block if input queue is empty. Errors will
-	 * be dealt with later on.
-	 */
-	iflag = tp->c_iflag;
-	/* Enable 8th-bit stripping. */
-	tp->c_iflag |= ISTRIP;
-	vmin = tp->c_cc[VMIN];
-	/* Do not block when queue is empty. */
-	tp->c_cc[VMIN] = 0;
-	tcsetattr(STDIN_FILENO, TCSANOW, tp);
-
-	/*
-	 * Wait for a while, then read everything the modem has said so far and
-	 * try to extract the speed of the dial-in call.
-	 */
-	sleep(1);
-	if ((nread = read(STDIN_FILENO, buf, sizeof(buf) - 1)) > 0) {
-		buf[nread] = '\0';
-		for (bp = buf; bp < buf + nread; bp++)
-			if (c_isascii(*bp) && isdigit(*bp)) {
-				if ((speed = bcode(bp))) {
-					cfsetispeed(tp, speed);
-					cfsetospeed(tp, speed);
-				}
-				break;
-			}
-	}
-
-	/* Restore terminal settings. Errors will be dealt with later on. */
-	tp->c_iflag = iflag;
-	tp->c_cc[VMIN] = vmin;
-	tcsetattr(STDIN_FILENO, TCSANOW, tp);
+    speed_t  speed;
+    int      vmin;
+    unsigned iflag;
+    char     buf[BUFSIZ];
+    char*    bp;
+    int      nread;
+
+    /*
+     * This works only if the modem produces its status code AFTER raising
+     * the DCD line, and if the computer is fast enough to set the proper
+     * baud rate before the message has gone by. We expect a message of the
+     * following format:
+     *
+     * <junk><number><junk>
+     *
+     * The number is interpreted as the baud rate of the incoming call. If the
+     * modem does not tell us the baud rate within one second, we will keep
+     * using the current baud rate. It is advisable to enable BREAK
+     * processing (comma-separated list of baud rates) if the processing of
+     * modem status messages is enabled.
+     */
+
+    /*
+     * Use 7-bit characters, don't block if input queue is empty. Errors will
+     * be dealt with later on.
+     */
+    iflag = tp->c_iflag;
+    /* Enable 8th-bit stripping. */
+    tp->c_iflag |= ISTRIP;
+    vmin           = tp->c_cc[VMIN];
+    /* Do not block when queue is empty. */
+    tp->c_cc[VMIN] = 0;
+    tcsetattr(STDIN_FILENO, TCSANOW, tp);
+
+    /*
+     * Wait for a while, then read everything the modem has said so far and
+     * try to extract the speed of the dial-in call.
+     */
+    sleep(1);
+    if ((nread = read(STDIN_FILENO, buf, sizeof(buf) - 1)) > 0)
+    {
+        buf[nread] = '\0';
+        for (bp = buf; bp < buf + nread; bp++)
+            if (c_isascii(*bp) && isdigit(*bp))
+            {
+                if ((speed = bcode(bp)))
+                {
+                    cfsetispeed(tp, speed);
+                    cfsetospeed(tp, speed);
+                }
+                break;
+            }
+    }
+
+    /* Restore terminal settings. Errors will be dealt with later on. */
+    tp->c_iflag    = iflag;
+    tp->c_cc[VMIN] = vmin;
+    tcsetattr(STDIN_FILENO, TCSANOW, tp);
 }
 
-static char *xgethostname(void)
+static char* xgethostname(void)
 {
-	char *name;
-	size_t sz = get_hostname_max() + 1;
-
-	name = malloc(sizeof(char) * sz);
-	if (!name)
-		log_err(_("failed to allocate memory: %m"));
-
-	if (gethostname(name, sz) != 0) {
-		free(name);
-		return NULL;
-	}
-	name[sz - 1] = '\0';
-	return name;
+    char*  name;
+    size_t sz = get_hostname_max() + 1;
+
+    name      = malloc(sizeof(char) * sz);
+    if (!name) log_err(_("failed to allocate memory: %m"));
+
+    if (gethostname(name, sz) != 0)
+    {
+        free(name);
+        return NULL;
+    }
+    name[sz - 1] = '\0';
+    return name;
 }
 
-static char *xgetdomainname(void)
+static char* xgetdomainname(void)
 {
 #ifdef HAVE_GETDOMAINNAME
-	char *name;
-	const size_t sz = get_hostname_max() + 1;
-
-	name = malloc(sizeof(char) * sz);
-	if (!name)
-		log_err(_("failed to allocate memory: %m"));
-
-	if (getdomainname(name, sz) != 0) {
-		free(name);
-		return NULL;
-	}
-	name[sz - 1] = '\0';
-	return name;
+    char*        name;
+    const size_t sz = get_hostname_max() + 1;
+
+    name            = malloc(sizeof(char) * sz);
+    if (!name) log_err(_("failed to allocate memory: %m"));
+
+    if (getdomainname(name, sz) != 0)
+    {
+        free(name);
+        return NULL;
+    }
+    name[sz - 1] = '\0';
+    return name;
 #else
-	return NULL;
+    return NULL;
 #endif
 }
 
-
-static char *read_os_release(struct options *op, const char *varname)
+static char* read_os_release(struct options* op, const char* varname)
 {
-	int fd = -1;
-	struct stat st;
-	size_t varsz = strlen(varname);
-	char *p, *buf = NULL, *ret = NULL;
-
-	/* read the file only once */
-	if (!op->osrelease) {
-		fd = open(_PATH_OS_RELEASE_ETC, O_RDONLY);
-		if (fd == -1) {
-			fd = open(_PATH_OS_RELEASE_USR, O_RDONLY);
-			if (fd == -1) {
-				log_warn(_("cannot open os-release file"));
-				return NULL;
-			}
-		}
-
-		if (fstat(fd, &st) < 0 || st.st_size > 4 * 1024 * 1024)
-			goto done;
-
-		op->osrelease = malloc(st.st_size + 1);
-		if (!op->osrelease)
-			log_err(_("failed to allocate memory: %m"));
-		if (read_all(fd, op->osrelease, st.st_size) != (ssize_t) st.st_size) {
-			free(op->osrelease);
-			op->osrelease = NULL;
-			goto done;
-		}
-		op->osrelease[st.st_size] = 0;
-	}
-	buf = strdup(op->osrelease);
-	if (!buf)
-		log_err(_("failed to allocate memory: %m"));
-	p = buf;
-
-	for (;;) {
-		char *eol, *eon;
-
-		p += strspn(p, "\n\r");
-		p += strspn(p, " \t\n\r");
-		if (!*p)
-			break;
-		if (strspn(p, "#;\n") != 0) {
-			p += strcspn(p, "\n\r");
-			continue;
-		}
-		if (strncmp(p, varname, varsz) != 0) {
-			p += strcspn(p, "\n\r");
-			continue;
-		}
-		p += varsz;
-		p += strspn(p, " \t\n\r");
-
-		if (*p != '=')
-			continue;
-
-		p += strspn(p, " \t\n\r=\"");
-		eol = p + strcspn(p, "\n\r");
-		*eol = '\0';
-		eon = eol-1;
-		while (eon > p) {
-			if (*eon == '\t' || *eon == ' ') {
-				eon--;
-				continue;
-			}
-			if (*eon == '"') {
-				*eon = '\0';
-				break;
-			}
-			break;
-		}
-		free(ret);
-		ret = strdup(p);
-		if (!ret)
-			log_err(_("failed to allocate memory: %m"));
-		p = eol + 1;
-	}
+    int         fd = -1;
+    struct stat st;
+    size_t      varsz = strlen(varname);
+    char *      p, *buf = NULL, *ret = NULL;
+
+    /* read the file only once */
+    if (!op->osrelease)
+    {
+        fd = open(_PATH_OS_RELEASE_ETC, O_RDONLY);
+        if (fd == -1)
+        {
+            fd = open(_PATH_OS_RELEASE_USR, O_RDONLY);
+            if (fd == -1)
+            {
+                log_warn(_("cannot open os-release file"));
+                return NULL;
+            }
+        }
+
+        if (fstat(fd, &st) < 0 || st.st_size > 4 * 1024 * 1024) goto done;
+
+        op->osrelease = malloc(st.st_size + 1);
+        if (!op->osrelease) log_err(_("failed to allocate memory: %m"));
+        if (read_all(fd, op->osrelease, st.st_size) != (ssize_t)st.st_size)
+        {
+            free(op->osrelease);
+            op->osrelease = NULL;
+            goto done;
+        }
+        op->osrelease[st.st_size] = 0;
+    }
+    buf = strdup(op->osrelease);
+    if (!buf) log_err(_("failed to allocate memory: %m"));
+    p = buf;
+
+    for (;;)
+    {
+        char *eol, *eon;
+
+        p += strspn(p, "\n\r");
+        p += strspn(p, " \t\n\r");
+        if (!*p) break;
+        if (strspn(p, "#;\n") != 0)
+        {
+            p += strcspn(p, "\n\r");
+            continue;
+        }
+        if (strncmp(p, varname, varsz) != 0)
+        {
+            p += strcspn(p, "\n\r");
+            continue;
+        }
+        p += varsz;
+        p += strspn(p, " \t\n\r");
+
+        if (*p != '=') continue;
+
+        p += strspn(p, " \t\n\r=\"");
+        eol  = p + strcspn(p, "\n\r");
+        *eol = '\0';
+        eon  = eol - 1;
+        while (eon > p)
+        {
+            if (*eon == '\t' || *eon == ' ')
+            {
+                eon--;
+                continue;
+            }
+            if (*eon == '"')
+            {
+                *eon = '\0';
+                break;
+            }
+            break;
+        }
+        free(ret);
+        ret = strdup(p);
+        if (!ret) log_err(_("failed to allocate memory: %m"));
+        p = eol + 1;
+    }
 done:
-	free(buf);
-	if (fd >= 0)
-		close(fd);
-	return ret;
+    free(buf);
+    if (fd >= 0) close(fd);
+    return ret;
 }
 
 #ifdef AGETTY_RELOAD
 static void open_netlink(void)
 {
-	struct sockaddr_nl addr = { 0, };
-	int sock;
-
-	if (netlink_fd != AGETTY_RELOAD_FDNONE)
-		return;
-
-	sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
-	if (sock >= 0) {
-		addr.nl_family = AF_NETLINK;
-		addr.nl_pid = getpid();
-		addr.nl_groups = netlink_groups;
-		if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0)
-			close(sock);
-		else
-			netlink_fd = sock;
-	}
+    struct sockaddr_nl addr = {
+        0,
+    };
+    int sock;
+
+    if (netlink_fd != AGETTY_RELOAD_FDNONE) return;
+
+    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+    if (sock >= 0)
+    {
+        addr.nl_family = AF_NETLINK;
+        addr.nl_pid    = getpid();
+        addr.nl_groups = netlink_groups;
+        if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) close(sock);
+        else netlink_fd = sock;
+    }
 }
 
-static int process_netlink_msg(int *triggered)
+static int process_netlink_msg(int* triggered)
 {
-	char buf[4096];
-	struct sockaddr_nl snl;
-	struct nlmsghdr *h;
-	int rc;
-
-	struct iovec iov = {
-		.iov_base = buf,
-		.iov_len = sizeof(buf)
-	};
-	struct msghdr msg = {
-		.msg_name = &snl,
-		.msg_namelen = sizeof(snl),
-		.msg_iov = &iov,
-		.msg_iovlen = 1,
-		.msg_control = NULL,
-		.msg_controllen = 0,
-		.msg_flags = 0
-	};
-
-	rc = recvmsg(netlink_fd, &msg, MSG_DONTWAIT);
-	if (rc < 0) {
-		if (errno == EWOULDBLOCK || errno == EAGAIN)
-			return 0;
-
-		/* Failure, just stop listening for changes */
-		close(netlink_fd);
-		netlink_fd = AGETTY_RELOAD_FDNONE;
-		return 0;
-	}
-
-	for (h = (struct nlmsghdr *)buf; NLMSG_OK(h, (unsigned int)rc); h = NLMSG_NEXT(h, rc)) {
-		if (h->nlmsg_type == NLMSG_DONE ||
-		    h->nlmsg_type == NLMSG_ERROR) {
-			close(netlink_fd);
-			netlink_fd = AGETTY_RELOAD_FDNONE;
-			return 0;
-		}
-
-		*triggered = 1;
-		break;
-	}
-
-	return 1;
+    char               buf[4096];
+    struct sockaddr_nl snl;
+    struct nlmsghdr*   h;
+    int                rc;
+
+    struct iovec       iov = {.iov_base = buf, .iov_len = sizeof(buf)};
+    struct msghdr      msg = {.msg_name       = &snl,
+                              .msg_namelen    = sizeof(snl),
+                              .msg_iov        = &iov,
+                              .msg_iovlen     = 1,
+                              .msg_control    = NULL,
+                              .msg_controllen = 0,
+                              .msg_flags      = 0};
+
+    rc                     = recvmsg(netlink_fd, &msg, MSG_DONTWAIT);
+    if (rc < 0)
+    {
+        if (errno == EWOULDBLOCK || errno == EAGAIN) return 0;
+
+        /* Failure, just stop listening for changes */
+        close(netlink_fd);
+        netlink_fd = AGETTY_RELOAD_FDNONE;
+        return 0;
+    }
+
+    for (h = (struct nlmsghdr*)buf; NLMSG_OK(h, (unsigned int)rc);
+         h = NLMSG_NEXT(h, rc))
+    {
+        if (h->nlmsg_type == NLMSG_DONE || h->nlmsg_type == NLMSG_ERROR)
+        {
+            close(netlink_fd);
+            netlink_fd = AGETTY_RELOAD_FDNONE;
+            return 0;
+        }
+
+        *triggered = 1;
+        break;
+    }
+
+    return 1;
 }
 
 static int process_netlink(void)
 {
-	int triggered = 0;
-	while (process_netlink_msg(&triggered));
-	return triggered;
+    int triggered = 0;
+    while (process_netlink_msg(&triggered));
+    return triggered;
 }
 
 static int wait_for_term_input(int fd)
 {
-	char buffer[sizeof(struct inotify_event) + NAME_MAX + 1];
-	fd_set rfds;
-
-	if (inotify_fd == AGETTY_RELOAD_FDNONE) {
-		/* make sure the reload trigger file exists */
-		int reload_fd = open(AGETTY_RELOAD_FILENAME,
-					O_CREAT|O_CLOEXEC|O_RDONLY,
-					S_IRUSR|S_IWUSR);
-
-		/* initialize reload trigger inotify stuff */
-		if (reload_fd >= 0) {
-			inotify_fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
-			if (inotify_fd > 0)
-				inotify_add_watch(inotify_fd, AGETTY_RELOAD_FILENAME,
-					  IN_ATTRIB | IN_MODIFY);
-
-			close(reload_fd);
-		} else
-			log_warn(_("failed to create reload file: %s: %m"),
-					AGETTY_RELOAD_FILENAME);
-	}
-
-	while (1) {
-		int nfds = fd;
-
-		FD_ZERO(&rfds);
-		FD_SET(fd, &rfds);
-
-		if (inotify_fd >= 0) {
-			FD_SET(inotify_fd, &rfds);
-			nfds = max(nfds, inotify_fd);
-		}
-		if (netlink_fd >= 0) {
-			FD_SET(netlink_fd, &rfds);
-			nfds = max(nfds, netlink_fd);
-		}
-
-		/* If waiting fails, just fall through, presumably reading input will fail */
-		if (select(nfds + 1, &rfds, NULL, NULL, NULL) < 0)
-			return 1;
-
-		if (FD_ISSET(fd, &rfds)) {
-			return 1;
-
-		}
-
-		if (netlink_fd >= 0 && FD_ISSET(netlink_fd, &rfds)) {
-			if (!process_netlink())
-				continue;
-
-		/* Just drain the inotify buffer */
-		} else if (inotify_fd >= 0 && FD_ISSET(inotify_fd, &rfds)) {
-			while (read(inotify_fd, buffer, sizeof (buffer)) > 0);
-		}
-
-		return 0;
-	}
+    char   buffer[sizeof(struct inotify_event) + NAME_MAX + 1];
+    fd_set rfds;
+
+    if (inotify_fd == AGETTY_RELOAD_FDNONE)
+    {
+        /* make sure the reload trigger file exists */
+        int reload_fd = open(AGETTY_RELOAD_FILENAME,
+                             O_CREAT | O_CLOEXEC | O_RDONLY, S_IRUSR | S_IWUSR);
+
+        /* initialize reload trigger inotify stuff */
+        if (reload_fd >= 0)
+        {
+            inotify_fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
+            if (inotify_fd > 0)
+                inotify_add_watch(inotify_fd, AGETTY_RELOAD_FILENAME,
+                                  IN_ATTRIB | IN_MODIFY);
+
+            close(reload_fd);
+        }
+        else
+            log_warn(_("failed to create reload file: %s: %m"),
+                     AGETTY_RELOAD_FILENAME);
+    }
+
+    while (1)
+    {
+        int nfds = fd;
+
+        FD_ZERO(&rfds);
+        FD_SET(fd, &rfds);
+
+        if (inotify_fd >= 0)
+        {
+            FD_SET(inotify_fd, &rfds);
+            nfds = max(nfds, inotify_fd);
+        }
+        if (netlink_fd >= 0)
+        {
+            FD_SET(netlink_fd, &rfds);
+            nfds = max(nfds, netlink_fd);
+        }
+
+        /* If waiting fails, just fall through, presumably reading input will
+         * fail */
+        if (select(nfds + 1, &rfds, NULL, NULL, NULL) < 0) return 1;
+
+        if (FD_ISSET(fd, &rfds)) { return 1; }
+
+        if (netlink_fd >= 0 && FD_ISSET(netlink_fd, &rfds))
+        {
+            if (!process_netlink()) continue;
+
+            /* Just drain the inotify buffer */
+        }
+        else if (inotify_fd >= 0 && FD_ISSET(inotify_fd, &rfds))
+        {
+            while (read(inotify_fd, buffer, sizeof(buffer)) > 0);
+        }
+
+        return 0;
+    }
 }
-#endif  /* AGETTY_RELOAD */
+#endif /* AGETTY_RELOAD */
 
 #ifdef ISSUEDIR_SUPPORT
-static int issuedir_filter(const struct dirent *d)
+static int issuedir_filter(const struct dirent* d)
 {
-	size_t namesz;
+    size_t namesz;
 
-#ifdef _DIRENT_HAVE_D_TYPE
-	if (d->d_type != DT_UNKNOWN && d->d_type != DT_REG &&
-	    d->d_type != DT_LNK)
-		return 0;
-#endif
-	if (*d->d_name == '.')
-		return 0;
+    #ifdef _DIRENT_HAVE_D_TYPE
+    if (d->d_type != DT_UNKNOWN && d->d_type != DT_REG && d->d_type != DT_LNK)
+        return 0;
+    #endif
+    if (*d->d_name == '.') return 0;
 
-	namesz = strlen(d->d_name);
-	if (!namesz || namesz < ISSUEDIR_EXTSIZ + 1 ||
-	    strcmp(d->d_name + (namesz - ISSUEDIR_EXTSIZ), ISSUEDIR_EXT) != 0)
-		return 0;
+    namesz = strlen(d->d_name);
+    if (!namesz || namesz < ISSUEDIR_EXTSIZ + 1
+        || strcmp(d->d_name + (namesz - ISSUEDIR_EXTSIZ), ISSUEDIR_EXT) != 0)
+        return 0;
 
-	/* Accept this */
-	return 1;
+    /* Accept this */
+    return 1;
 }
 
-
-static int issuefile_read_stream(struct issue *ie, FILE *f, struct options *op, struct termios *tp);
+static int issuefile_read_stream(struct issue* ie, FILE* f, struct options* op,
+                                 struct termios* tp);
 
 /* returns: 0 on success, 1 cannot open, <0 on error
  */
-static int issuedir_read(struct issue *ie, const char *dirname,
-			 struct options *op, struct termios *tp)
+static int issuedir_read(struct issue* ie, const char* dirname,
+                         struct options* op, struct termios* tp)
 {
-        int dd, nfiles, i;
-        struct dirent **namelist = NULL;
+    int             dd, nfiles, i;
+    struct dirent** namelist = NULL;
 
-	dd = open(dirname, O_RDONLY|O_CLOEXEC|O_DIRECTORY);
-	if (dd < 0)
-		return 1;
+    dd = open(dirname, O_RDONLY | O_CLOEXEC | O_DIRECTORY);
+    if (dd < 0) return 1;
 
-	nfiles = scandirat(dd, ".", &namelist, issuedir_filter, versionsort);
-	if (nfiles <= 0)
-		goto done;
+    nfiles = scandirat(dd, ".", &namelist, issuedir_filter, versionsort);
+    if (nfiles <= 0) goto done;
 
-	ie->do_tcsetattr = 1;
+    ie->do_tcsetattr = 1;
 
-	for (i = 0; i < nfiles; i++) {
-		struct dirent *d = namelist[i];
-		FILE *f;
+    for (i = 0; i < nfiles; i++)
+    {
+        struct dirent* d = namelist[i];
+        FILE*          f;
 
-		f = fopen_at(dd, d->d_name, O_RDONLY|O_CLOEXEC, "r" UL_CLOEXECSTR);
-		if (f) {
-			issuefile_read_stream(ie, f, op, tp);
-			fclose(f);
-		}
-	}
+        f = fopen_at(dd, d->d_name, O_RDONLY | O_CLOEXEC, "r" UL_CLOEXECSTR);
+        if (f)
+        {
+            issuefile_read_stream(ie, f, op, tp);
+            fclose(f);
+        }
+    }
 
-	for (i = 0; i < nfiles; i++)
-		free(namelist[i]);
-	free(namelist);
+    for (i = 0; i < nfiles; i++) free(namelist[i]);
+    free(namelist);
 done:
-	close(dd);
-	return 0;
+    close(dd);
+    return 0;
 }
 
-#else /* !ISSUEDIR_SUPPORT */
-static int issuedir_read(struct issue *ie __attribute__((__unused__)),
-			const char *dirname __attribute__((__unused__)),
-			struct options *op __attribute__((__unused__)),
-			struct termios *tp __attribute__((__unused__)))
+#else  /* !ISSUEDIR_SUPPORT */
+static int issuedir_read(struct issue*   ie __attribute__((__unused__)),
+                         const char*     dirname __attribute__((__unused__)),
+                         struct options* op __attribute__((__unused__)),
+                         struct termios* tp __attribute__((__unused__)))
 {
-	return 1;
+    return 1;
 }
 #endif /* ISSUEDIR_SUPPORT */
 
 #ifndef ISSUE_SUPPORT
-static void print_issue_file(struct issue *ie __attribute__((__unused__)),
-			     struct options *op,
-			     struct termios *tp __attribute__((__unused__)))
+static void print_issue_file(struct issue*   ie __attribute__((__unused__)),
+                             struct options* op,
+                             struct termios* tp __attribute__((__unused__)))
 {
-	if ((op->flags & F_NONL) == 0) {
-		/* Issue not in use, start with a new line. */
-		write_all(STDOUT_FILENO, "\r\n", 2);
-	}
+    if ((op->flags & F_NONL) == 0)
+    {
+        /* Issue not in use, start with a new line. */
+        write_all(STDOUT_FILENO, "\r\n", 2);
+    }
 }
 
-static void eval_issue_file(struct issue *ie __attribute__((__unused__)),
-			    struct options *op __attribute__((__unused__)),
-			    struct termios *tp __attribute__((__unused__)))
+static void eval_issue_file(struct issue*   ie __attribute__((__unused__)),
+                            struct options* op __attribute__((__unused__)),
+                            struct termios* tp __attribute__((__unused__)))
 {
 }
 
-static void show_issue(struct options *op __attribute__((__unused__)))
-{
-}
+static void show_issue(struct options* op __attribute__((__unused__))) {}
 
 #else /* ISSUE_SUPPORT */
 
-static int issuefile_read_stream(
-		struct issue *ie, FILE *f,
-		struct options *op, struct termios *tp)
+static int issuefile_read_stream(struct issue* ie, FILE* f, struct options* op,
+                                 struct termios* tp)
 {
-	struct stat st;
-	int c;
-
-	if (fstat(fileno(f), &st) || !S_ISREG(st.st_mode))
-		return 1;
-
-	if (!ie->output) {
-		free(ie->mem);
-		ie->mem_sz = 0;
-		ie->mem = NULL;
-		ie->output = open_memstream(&ie->mem, &ie->mem_sz);
-	}
-
-	while ((c = getc(f)) != EOF) {
-		if (c == '\\')
-			output_special_char(ie, getc(f), op, tp, f);
-		else
-			putc(c, ie->output);
-	}
-
-	return 0;
+    struct stat st;
+    int         c;
+
+    if (fstat(fileno(f), &st) || !S_ISREG(st.st_mode)) return 1;
+
+    if (!ie->output)
+    {
+        free(ie->mem);
+        ie->mem_sz = 0;
+        ie->mem    = NULL;
+        ie->output = open_memstream(&ie->mem, &ie->mem_sz);
+    }
+
+    while ((c = getc(f)) != EOF)
+    {
+        if (c == '\\') output_special_char(ie, getc(f), op, tp, f);
+        else putc(c, ie->output);
+    }
+
+    return 0;
 }
 
-static int issuefile_read(
-		struct issue *ie, const char *filename,
-		struct options *op, struct termios *tp)
+static int issuefile_read(struct issue* ie, const char* filename,
+                          struct options* op, struct termios* tp)
 {
-	FILE *f = fopen(filename, "r" UL_CLOEXECSTR);
-	int rc = 1;
-
-	if (f) {
-		rc = issuefile_read_stream(ie, f, op, tp);
-		fclose(f);
-	}
-	return rc;
+    FILE* f  = fopen(filename, "r" UL_CLOEXECSTR);
+    int   rc = 1;
+
+    if (f)
+    {
+        rc = issuefile_read_stream(ie, f, op, tp);
+        fclose(f);
+    }
+    return rc;
 }
 
-
-#ifdef AGETTY_RELOAD
-static int issue_is_changed(struct issue *ie)
+    #ifdef AGETTY_RELOAD
+static int issue_is_changed(struct issue* ie)
 {
-	if (ie->mem_old && ie->mem
-	    && strcmp(ie->mem_old, ie->mem) == 0) {
-		free(ie->mem_old);
-		ie->mem_old = ie->mem;
-		ie->mem = NULL;
-		return 0;
-	}
-
-	return 1;
+    if (ie->mem_old && ie->mem && strcmp(ie->mem_old, ie->mem) == 0)
+    {
+        free(ie->mem_old);
+        ie->mem_old = ie->mem;
+        ie->mem     = NULL;
+        return 0;
+    }
+
+    return 1;
 }
-#endif
+    #endif
 
-static void print_issue_file(struct issue *ie,
-			     struct options *op,
-			     struct termios *tp)
+static void print_issue_file(struct issue* ie, struct options* op,
+                             struct termios* tp)
 {
-	int oflag = tp->c_oflag;	    /* Save current setting. */
-
-	if ((op->flags & F_NONL) == 0) {
-		/* Issue not in use, start with a new line. */
-		write_all(STDOUT_FILENO, "\r\n", 2);
-	}
-
-	if (ie->do_tcsetattr) {
-		if ((op->flags & F_VCONSOLE) == 0) {
-			/* Map new line in output to carriage return & new line. */
-			tp->c_oflag |= (ONLCR | OPOST);
-			tcsetattr(STDIN_FILENO, TCSADRAIN, tp);
-		}
-	}
-
-	if (ie->mem_sz)
-		write_all(STDOUT_FILENO, ie->mem, ie->mem_sz);
-
-	if (ie->do_tcrestore) {
-		/* Restore settings. */
-		tp->c_oflag = oflag;
-		/* Wait till output is gone. */
-		tcsetattr(STDIN_FILENO, TCSADRAIN, tp);
-	}
-
-#ifdef AGETTY_RELOAD
-	free(ie->mem_old);
-	ie->mem_old = ie->mem;
-	ie->mem = NULL;
-	ie->mem_sz = 0;
-#else
-	free(ie->mem);
-	ie->mem = NULL;
-	ie->mem_sz = 0;
-#endif
+    int oflag = tp->c_oflag; /* Save current setting. */
+
+    if ((op->flags & F_NONL) == 0)
+    {
+        /* Issue not in use, start with a new line. */
+        write_all(STDOUT_FILENO, "\r\n", 2);
+    }
+
+    if (ie->do_tcsetattr)
+    {
+        if ((op->flags & F_VCONSOLE) == 0)
+        {
+            /* Map new line in output to carriage return & new line. */
+            tp->c_oflag |= (ONLCR | OPOST);
+            tcsetattr(STDIN_FILENO, TCSADRAIN, tp);
+        }
+    }
+
+    if (ie->mem_sz) write_all(STDOUT_FILENO, ie->mem, ie->mem_sz);
+
+    if (ie->do_tcrestore)
+    {
+        /* Restore settings. */
+        tp->c_oflag = oflag;
+        /* Wait till output is gone. */
+        tcsetattr(STDIN_FILENO, TCSADRAIN, tp);
+    }
+
+    #ifdef AGETTY_RELOAD
+    free(ie->mem_old);
+    ie->mem_old = ie->mem;
+    ie->mem     = NULL;
+    ie->mem_sz  = 0;
+    #else
+    free(ie->mem);
+    ie->mem    = NULL;
+    ie->mem_sz = 0;
+    #endif
 }
 
-static void eval_issue_file(struct issue *ie,
-			    struct options *op,
-			    struct termios *tp)
+static void eval_issue_file(struct issue* ie, struct options* op,
+                            struct termios* tp)
 {
-	int has_file = 0;
-
-#ifdef AGETTY_RELOAD
-	netlink_groups = 0;
-#endif
-	if (!(op->flags & F_ISSUE))
-		goto done;
-	/*
-	 * The custom issue file or directory list specified by:
-	 *   agetty --isue-file <path[:path]...>
-	 * Note that nothing is printed if the file/dir does not exist.
-	 */
-	if (op->issue) {
-		char *list = strdup(op->issue);
-		char *file;
-
-		if (!list)
-			log_err(_("failed to allocate memory: %m"));
-
-		for (file = strtok(list, ":"); file; file = strtok(NULL, ":")) {
-			struct stat st;
-
-			if (stat(file, &st) < 0)
-				continue;
-			if (S_ISDIR(st.st_mode))
-				issuedir_read(ie, file, op, tp);
-			else
-				issuefile_read(ie, file, op, tp);
-		}
-		free(list);
-		goto done;
-	}
-
-	/* The default /etc/issue and optional /etc/issue.d directory as
-	 * extension to the file. The /etc/issue.d directory is ignored if
-	 * there is no /etc/issue file. The file may be empty or symlink.
-	 */
-	if (access(_PATH_ISSUE, F_OK|R_OK) == 0) {
-		issuefile_read(ie, _PATH_ISSUE, op, tp);
-		issuedir_read(ie, _PATH_ISSUEDIR, op, tp);
-		goto done;
-	}
-
-	/* Fallback @runstatedir (usually /run) -- the file is not required to
-	 * read the dir.
-	 */
-	if (issuefile_read(ie, _PATH_RUNSTATEDIR "/" _PATH_ISSUE_FILENAME, op, tp) == 0)
-		has_file++;
-	if (issuedir_read(ie, _PATH_RUNSTATEDIR "/" _PATH_ISSUE_DIRNAME, op, tp) == 0)
-		has_file++;
-	if (has_file)
-		goto done;
-
-	/* Fallback @sysconfstaticdir (usually /usr/lib) -- the file is not
-	 * required to read the dir
-	 */
-	issuefile_read(ie, _PATH_SYSCONFSTATICDIR "/" _PATH_ISSUE_FILENAME, op, tp); 
-	issuedir_read(ie, _PATH_SYSCONFSTATICDIR "/" _PATH_ISSUE_DIRNAME, op, tp);
+    int has_file = 0;
+
+    #ifdef AGETTY_RELOAD
+    netlink_groups = 0;
+    #endif
+    if (!(op->flags & F_ISSUE)) goto done;
+    /*
+     * The custom issue file or directory list specified by:
+     *   agetty --isue-file <path[:path]...>
+     * Note that nothing is printed if the file/dir does not exist.
+     */
+    if (op->issue)
+    {
+        char* list = strdup(op->issue);
+        char* file;
+
+        if (!list) log_err(_("failed to allocate memory: %m"));
+
+        for (file = strtok(list, ":"); file; file = strtok(NULL, ":"))
+        {
+            struct stat st;
+
+            if (stat(file, &st) < 0) continue;
+            if (S_ISDIR(st.st_mode)) issuedir_read(ie, file, op, tp);
+            else issuefile_read(ie, file, op, tp);
+        }
+        free(list);
+        goto done;
+    }
+
+    /* The default /etc/issue and optional /etc/issue.d directory as
+     * extension to the file. The /etc/issue.d directory is ignored if
+     * there is no /etc/issue file. The file may be empty or symlink.
+     */
+    if (access(_PATH_ISSUE, F_OK | R_OK) == 0)
+    {
+        issuefile_read(ie, _PATH_ISSUE, op, tp);
+        issuedir_read(ie, _PATH_ISSUEDIR, op, tp);
+        goto done;
+    }
+
+    /* Fallback @runstatedir (usually /run) -- the file is not required to
+     * read the dir.
+     */
+    if (issuefile_read(ie, _PATH_RUNSTATEDIR "/" _PATH_ISSUE_FILENAME, op, tp)
+        == 0)
+        has_file++;
+    if (issuedir_read(ie, _PATH_RUNSTATEDIR "/" _PATH_ISSUE_DIRNAME, op, tp)
+        == 0)
+        has_file++;
+    if (has_file) goto done;
+
+    /* Fallback @sysconfstaticdir (usually /usr/lib) -- the file is not
+     * required to read the dir
+     */
+    issuefile_read(ie, _PATH_SYSCONFSTATICDIR "/" _PATH_ISSUE_FILENAME, op, tp);
+    issuedir_read(ie, _PATH_SYSCONFSTATICDIR "/" _PATH_ISSUE_DIRNAME, op, tp);
 
 done:
 
-#ifdef AGETTY_RELOAD
-	if (netlink_groups != 0)
-		open_netlink();
-#endif
-	if (ie->output) {
-		fclose(ie->output);
-		ie->output = NULL;
-	}
+    #ifdef AGETTY_RELOAD
+    if (netlink_groups != 0) open_netlink();
+    #endif
+    if (ie->output)
+    {
+        fclose(ie->output);
+        ie->output = NULL;
+    }
 }
 
 /* This is --show-issue backend, executed by normal user on the current
  * terminal.
  */
-static void show_issue(struct options *op)
+static void show_issue(struct options* op)
 {
-	struct issue ie = { .output = NULL };
-	struct termios tp;
+    struct issue   ie = {.output = NULL};
+    struct termios tp;
 
-	memset(&tp, 0, sizeof(struct termios));
-	if (tcgetattr(STDIN_FILENO, &tp) < 0)
-		err(EXIT_FAILURE, _("failed to get terminal attributes: %m"));
+    memset(&tp, 0, sizeof(struct termios));
+    if (tcgetattr(STDIN_FILENO, &tp) < 0)
+        err(EXIT_FAILURE, _("failed to get terminal attributes: %m"));
 
-	eval_issue_file(&ie, op, &tp);
+    eval_issue_file(&ie, op, &tp);
 
-	if (ie.mem_sz)
-		write_all(STDOUT_FILENO, ie.mem, ie.mem_sz);
-	if (ie.output)
-		fclose(ie.output);
-	free(ie.mem);
+    if (ie.mem_sz) write_all(STDOUT_FILENO, ie.mem, ie.mem_sz);
+    if (ie.output) fclose(ie.output);
+    free(ie.mem);
 }
 
 #endif /* ISSUE_SUPPORT */
 
 /* Show login prompt, optionally preceded by /etc/issue contents. */
-static void do_prompt(struct issue *ie, struct options *op, struct termios *tp)
+static void do_prompt(struct issue* ie, struct options* op, struct termios* tp)
 {
 #ifdef AGETTY_RELOAD
 again:
 #endif
-	print_issue_file(ie, op, tp);
+    print_issue_file(ie, op, tp);
 
-	if (op->flags & F_LOGINPAUSE) {
-		puts(_("[press ENTER to login]"));
+    if (op->flags & F_LOGINPAUSE)
+    {
+        puts(_("[press ENTER to login]"));
 #ifdef AGETTY_RELOAD
-		/* reload issue */
-		if (!wait_for_term_input(STDIN_FILENO)) {
-			eval_issue_file(ie, op, tp);
-			if (issue_is_changed(ie)) {
-				if (op->flags & F_VCONSOLE)
-					termio_clear(STDOUT_FILENO);
-				goto again;
-			}
-		}
-#endif
-		getc(stdin);
-	}
+        /* reload issue */
+        if (!wait_for_term_input(STDIN_FILENO))
+        {
+            eval_issue_file(ie, op, tp);
+            if (issue_is_changed(ie))
+            {
+                if (op->flags & F_VCONSOLE) termio_clear(STDOUT_FILENO);
+                goto again;
+            }
+        }
+#endif
+        getc(stdin);
+    }
 #ifdef KDGKBLED
-	if (!(op->flags & F_NOHINTS) && !op->autolog &&
-	    (op->flags & F_VCONSOLE)) {
-		int kb = 0;
+    if (!(op->flags & F_NOHINTS) && !op->autolog && (op->flags & F_VCONSOLE))
+    {
+        int kb = 0;
 
-		if (ioctl(STDIN_FILENO, KDGKBLED, &kb) == 0) {
-			char hint[256] = { '\0' };
-			int nl = 0;
+        if (ioctl(STDIN_FILENO, KDGKBLED, &kb) == 0)
+        {
+            char hint[256] = {'\0'};
+            int  nl        = 0;
 
-			if (access(_PATH_NUMLOCK_ON, F_OK) == 0)
-				nl = 1;
+            if (access(_PATH_NUMLOCK_ON, F_OK) == 0) nl = 1;
 
-			if (nl && (kb & 0x02) == 0)
-				append(hint, sizeof(hint), NULL, _("Num Lock off"));
+            if (nl && (kb & 0x02) == 0)
+                append(hint, sizeof(hint), NULL, _("Num Lock off"));
 
-			else if (nl == 0 && (kb & 2) && (kb & 0x20) == 0)
-				append(hint, sizeof(hint), NULL, _("Num Lock on"));
+            else if (nl == 0 && (kb & 2) && (kb & 0x20) == 0)
+                append(hint, sizeof(hint), NULL, _("Num Lock on"));
 
-			if ((kb & 0x04) && (kb & 0x40) == 0)
-				append(hint, sizeof(hint), ", ", _("Caps Lock on"));
+            if ((kb & 0x04) && (kb & 0x40) == 0)
+                append(hint, sizeof(hint), ", ", _("Caps Lock on"));
 
-			if ((kb & 0x01) && (kb & 0x10) == 0)
-				append(hint, sizeof(hint), ", ",  _("Scroll Lock on"));
+            if ((kb & 0x01) && (kb & 0x10) == 0)
+                append(hint, sizeof(hint), ", ", _("Scroll Lock on"));
 
-			if (*hint)
-				printf(_("Hint: %s\n\n"), hint);
-		}
-	}
+            if (*hint) printf(_("Hint: %s\n\n"), hint);
+        }
+    }
 #endif /* KDGKBLED */
-	if ((op->flags & F_NOHOSTNAME) == 0) {
-		char *hn = xgethostname();
-
-		if (hn) {
-			char *dot = strchr(hn, '.');
-			char *cn = hn;
-			struct addrinfo *res = NULL;
-
-			if ((op->flags & F_LONGHNAME) == 0) {
-				if (dot)
-					*dot = '\0';
-
-			} else if (dot == NULL) {
-				struct addrinfo hints;
-
-				memset(&hints, 0, sizeof(hints));
-				hints.ai_flags = AI_CANONNAME;
-
-				if (!getaddrinfo(hn, NULL, &hints, &res)
-				    && res && res->ai_canonname)
-					cn = res->ai_canonname;
-			}
-
-			write_all(STDOUT_FILENO, cn, strlen(cn));
-			write_all(STDOUT_FILENO, " ", 1);
-
-			if (res)
-				freeaddrinfo(res);
-			free(hn);
-		}
-	}
-	if (!op->autolog) {
-		/* Always show login prompt. */
-		write_all(STDOUT_FILENO, LOGIN, sizeof(LOGIN) - 1);
-	}
+    if ((op->flags & F_NOHOSTNAME) == 0)
+    {
+        char* hn = xgethostname();
+
+        if (hn)
+        {
+            char*            dot = strchr(hn, '.');
+            char*            cn  = hn;
+            struct addrinfo* res = NULL;
+
+            if ((op->flags & F_LONGHNAME) == 0)
+            {
+                if (dot) *dot = '\0';
+            }
+            else if (dot == NULL)
+            {
+                struct addrinfo hints;
+
+                memset(&hints, 0, sizeof(hints));
+                hints.ai_flags = AI_CANONNAME;
+
+                if (!getaddrinfo(hn, NULL, &hints, &res) && res
+                    && res->ai_canonname)
+                    cn = res->ai_canonname;
+            }
+
+            write_all(STDOUT_FILENO, cn, strlen(cn));
+            write_all(STDOUT_FILENO, " ", 1);
+
+            if (res) freeaddrinfo(res);
+            free(hn);
+        }
+    }
+    if (!op->autolog)
+    {
+        /* Always show login prompt. */
+        write_all(STDOUT_FILENO, LOGIN, sizeof(LOGIN) - 1);
+    }
 }
 
 /* Select next baud rate. */
-static void next_speed(struct options *op, struct termios *tp)
+static void next_speed(struct options* op, struct termios* tp)
 {
-	static int baud_index = -1;
-
-	if (baud_index == -1)
-		/*
-		 * If the F_KEEPSPEED flags is set then the FIRST_SPEED is not
-		 * tested yet (see termio_init()).
-		 */
-		baud_index =
-		    (op->flags & F_KEEPSPEED) ? FIRST_SPEED : 1 % op->numspeed;
-	else
-		baud_index = (baud_index + 1) % op->numspeed;
-
-	cfsetispeed(tp, op->speeds[baud_index]);
-	cfsetospeed(tp, op->speeds[baud_index]);
-	tcsetattr(STDIN_FILENO, TCSANOW, tp);
+    static int baud_index = -1;
+
+    if (baud_index == -1)
+        /*
+         * If the F_KEEPSPEED flags is set then the FIRST_SPEED is not
+         * tested yet (see termio_init()).
+         */
+        baud_index = (op->flags & F_KEEPSPEED) ? FIRST_SPEED : 1 % op->numspeed;
+    else baud_index = (baud_index + 1) % op->numspeed;
+
+    cfsetispeed(tp, op->speeds[baud_index]);
+    cfsetospeed(tp, op->speeds[baud_index]);
+    tcsetattr(STDIN_FILENO, TCSANOW, tp);
 }
 
 /* Get user name, establish parity, speed, erase, kill & eol. */
-static char *get_logname(struct issue *ie, struct options *op, struct termios *tp, struct chardata *cp)
+static char* get_logname(struct issue* ie, struct options* op,
+                         struct termios* tp, struct chardata* cp)
 {
-	static char logname[BUFSIZ];
-	char *bp;
-	char c;			/* input character, full eight bits */
-	char ascval;		/* low 7 bits of input character */
-	int eightbit;
-	static char *erase[] = {	/* backspace-space-backspace */
-		"\010\040\010",		/* space parity */
-		"\010\040\010",		/* odd parity */
-		"\210\240\210",		/* even parity */
-		"\210\240\210",		/* no parity */
-	};
-
-	/* Initialize kill, erase, parity etc. (also after switching speeds). */
-	INIT_CHARDATA(cp);
-
-	/*
-	 * Flush pending input (especially important after parsing or switching
-	 * the baud rate).
-	 */
-	if ((op->flags & F_VCONSOLE) == 0)
-		sleep(1);
-	tcflush(STDIN_FILENO, TCIFLUSH);
-
-	eightbit = (op->flags & (F_EIGHTBITS|F_UTF8));
-	bp = logname;
-	*bp = '\0';
-
-	eval_issue_file(ie, op, tp);
-	while (*logname == '\0') {
-		/* Write issue file and prompt */
-		do_prompt(ie, op, tp);
-
-	no_reload:
+    static char  logname[BUFSIZ];
+    char*        bp;
+    char         c;      /* input character, full eight bits */
+    char         ascval; /* low 7 bits of input character */
+    int          eightbit;
+    static char* erase[] = {
+        /* backspace-space-backspace */
+        "\010\040\010", /* space parity */
+        "\010\040\010", /* odd parity */
+        "\210\240\210", /* even parity */
+        "\210\240\210", /* no parity */
+    };
+
+    /* Initialize kill, erase, parity etc. (also after switching speeds). */
+    INIT_CHARDATA(cp);
+
+    /*
+     * Flush pending input (especially important after parsing or switching
+     * the baud rate).
+     */
+    if ((op->flags & F_VCONSOLE) == 0) sleep(1);
+    tcflush(STDIN_FILENO, TCIFLUSH);
+
+    eightbit = (op->flags & (F_EIGHTBITS | F_UTF8));
+    bp       = logname;
+    *bp      = '\0';
+
+    eval_issue_file(ie, op, tp);
+    while (*logname == '\0')
+    {
+        /* Write issue file and prompt */
+        do_prompt(ie, op, tp);
+
+    no_reload:
 #ifdef AGETTY_RELOAD
-		if (!wait_for_term_input(STDIN_FILENO)) {
-			/* refresh prompt -- discard input data, clear terminal
-			 * and call do_prompt() again
-			 */
-			if ((op->flags & F_VCONSOLE) == 0)
-				sleep(1);
-			eval_issue_file(ie, op, tp);
-			if (!issue_is_changed(ie))
-				goto no_reload;
-			tcflush(STDIN_FILENO, TCIFLUSH);
-			if (op->flags & F_VCONSOLE)
-				termio_clear(STDOUT_FILENO);
-			bp = logname;
-			*bp = '\0';
-			continue;
-		}
-#endif
-		cp->eol = '\0';
-
-		/* Read name, watch for break and end-of-line. */
-		while (cp->eol == '\0') {
-
-			char key;
-			ssize_t readres;
-
-			debug("read from FD\n");
-			readres = read(STDIN_FILENO, &c, 1);
-			if (readres < 0) {
-				debug("read failed\n");
-
-				/* The terminal could be open with O_NONBLOCK when
-				 * -L (force CLOCAL) is specified...  */
-				if (errno == EINTR || errno == EAGAIN) {
-					xusleep(250000);
-					continue;
-				}
-				switch (errno) {
-				case 0:
-				case EIO:
-				case ESRCH:
-				case EINVAL:
-				case ENOENT:
-					exit_slowly(EXIT_SUCCESS);
-				default:
-					log_err(_("%s: read: %m"), op->tty);
-				}
-			}
-
-			if (readres == 0)
-				c = 0;
-
-			/* Do parity bit handling. */
-			if (eightbit)
-				ascval = c;
-			else if (c != (ascval = (c & 0177))) {
-				uint32_t bits;			/* # of "1" bits per character */
-				uint32_t mask;			/* mask with 1 bit up */
-				for (bits = 1, mask = 1; mask & 0177; mask <<= 1) {
-					if (mask & ascval)
-						bits++;
-				}
-				cp->parity |= ((bits & 1) ? 1 : 2);
-			}
-
-			if (op->killchars && strchr(op->killchars, ascval))
-				key = CTL('U');
-			else if (op->erasechars && strchr(op->erasechars, ascval))
-				key = DEL;
-			else
-				key = ascval;
-
-			/* Do erase, kill and end-of-line processing. */
-			switch (key) {
-			case 0:
-				*bp = 0;
-				if (op->numspeed > 1 && !(op->flags & F_VCONSOLE))
-					return NULL;
-				if (readres == 0)
-					exit_slowly(EXIT_SUCCESS);
-				break;
-			case CR:
-			case NL:
-				*bp = 0;			/* terminate logname */
-				cp->eol = ascval;		/* set end-of-line char */
-				break;
-			case BS:
-			case DEL:
-				cp->erase = ascval; /* set erase character */
-				if (bp > logname) {
-					if ((tp->c_lflag & ECHO) == 0)
-						write_all(1, erase[cp->parity], 3);
-					bp--;
-				}
-				break;
-			case CTL('U'):
-				cp->kill = ascval;		/* set kill character */
-				while (bp > logname) {
-					if ((tp->c_lflag & ECHO) == 0)
-						write_all(1, erase[cp->parity], 3);
-					bp--;
-				}
-				break;
-			case CTL('D'):
-				exit(EXIT_SUCCESS);
-			case CTL('C'):
-				/* Ignore */
-				break;
-			default:
-				if ((size_t)(bp - logname) >= sizeof(logname) - 1)
-					log_err(_("%s: input overrun"), op->tty);
-				if ((tp->c_lflag & ECHO) == 0)
-					write_all(1, &c, 1);	/* echo the character */
-				*bp++ = ascval;			/* and store it */
-				break;
-			}
-			/* Everything was erased. */
-			if (bp == logname && cp->eol == '\0')
-				goto no_reload;
-		}
-	}
+        if (!wait_for_term_input(STDIN_FILENO))
+        {
+            /* refresh prompt -- discard input data, clear terminal
+             * and call do_prompt() again
+             */
+            if ((op->flags & F_VCONSOLE) == 0) sleep(1);
+            eval_issue_file(ie, op, tp);
+            if (!issue_is_changed(ie)) goto no_reload;
+            tcflush(STDIN_FILENO, TCIFLUSH);
+            if (op->flags & F_VCONSOLE) termio_clear(STDOUT_FILENO);
+            bp  = logname;
+            *bp = '\0';
+            continue;
+        }
+#endif
+        cp->eol = '\0';
+
+        /* Read name, watch for break and end-of-line. */
+        while (cp->eol == '\0')
+        {
+
+            char    key;
+            ssize_t readres;
+
+            debug("read from FD\n");
+            readres = read(STDIN_FILENO, &c, 1);
+            if (readres < 0)
+            {
+                debug("read failed\n");
+
+                /* The terminal could be open with O_NONBLOCK when
+                 * -L (force CLOCAL) is specified...  */
+                if (errno == EINTR || errno == EAGAIN)
+                {
+                    xusleep(250000);
+                    continue;
+                }
+                switch (errno)
+                {
+                    case 0:
+                    case EIO:
+                    case ESRCH:
+                    case EINVAL:
+                    case ENOENT: exit_slowly(EXIT_SUCCESS);
+                    default: log_err(_("%s: read: %m"), op->tty);
+                }
+            }
+
+            if (readres == 0) c = 0;
+
+            /* Do parity bit handling. */
+            if (eightbit) ascval = c;
+            else if (c != (ascval = (c & 0177)))
+            {
+                uint32_t bits; /* # of "1" bits per character */
+                uint32_t mask; /* mask with 1 bit up */
+                for (bits = 1, mask = 1; mask & 0177; mask <<= 1)
+                {
+                    if (mask & ascval) bits++;
+                }
+                cp->parity |= ((bits & 1) ? 1 : 2);
+            }
+
+            if (op->killchars && strchr(op->killchars, ascval)) key = CTL('U');
+            else if (op->erasechars && strchr(op->erasechars, ascval))
+                key = DEL;
+            else key = ascval;
+
+            /* Do erase, kill and end-of-line processing. */
+            switch (key)
+            {
+                case 0:
+                    *bp = 0;
+                    if (op->numspeed > 1 && !(op->flags & F_VCONSOLE))
+                        return NULL;
+                    if (readres == 0) exit_slowly(EXIT_SUCCESS);
+                    break;
+                case CR:
+                case NL:
+                    *bp     = 0;      /* terminate logname */
+                    cp->eol = ascval; /* set end-of-line char */
+                    break;
+                case BS:
+                case DEL:
+                    cp->erase = ascval; /* set erase character */
+                    if (bp > logname)
+                    {
+                        if ((tp->c_lflag & ECHO) == 0)
+                            write_all(1, erase[cp->parity], 3);
+                        bp--;
+                    }
+                    break;
+                case CTL('U'):
+                    cp->kill = ascval; /* set kill character */
+                    while (bp > logname)
+                    {
+                        if ((tp->c_lflag & ECHO) == 0)
+                            write_all(1, erase[cp->parity], 3);
+                        bp--;
+                    }
+                    break;
+                case CTL('D'): exit(EXIT_SUCCESS);
+                case CTL('C'):
+                    /* Ignore */
+                    break;
+                default:
+                    if ((size_t)(bp - logname) >= sizeof(logname) - 1)
+                        log_err(_("%s: input overrun"), op->tty);
+                    if ((tp->c_lflag & ECHO) == 0)
+                        write_all(1, &c, 1); /* echo the character */
+                    *bp++ = ascval;          /* and store it */
+                    break;
+            }
+            /* Everything was erased. */
+            if (bp == logname && cp->eol == '\0') goto no_reload;
+        }
+    }
 
 #ifdef HAVE_WIDECHAR
-	if ((op->flags & (F_EIGHTBITS|F_UTF8)) == (F_EIGHTBITS|F_UTF8)) {
-		/* Check out UTF-8 multibyte characters */
-		ssize_t len;
-		wchar_t *wcs, *wcp;
-
-		len = mbstowcs((wchar_t *)0, logname, 0);
-		if (len < 0)
-			log_err(_("%s: invalid character conversion for login name"), op->tty);
-
-		wcs = malloc((len + 1) * sizeof(wchar_t));
-		if (!wcs)
-			log_err(_("failed to allocate memory: %m"));
-
-		len = mbstowcs(wcs, logname, len + 1);
-		if (len < 0)
-			log_err(_("%s: invalid character conversion for login name"), op->tty);
-
-		wcp = wcs;
-		while (*wcp) {
-			const wint_t wc = *wcp++;
-			if (!iswprint(wc))
-				log_err(_("%s: invalid character 0x%x in login name"), op->tty, wc);
-		}
-		free(wcs);
-	} else
-#endif
-	if ((op->flags & F_LCUC) && (cp->capslock = caps_lock(logname))) {
-
-		/* Handle names with upper case and no lower case. */
-		for (bp = logname; *bp; bp++)
-			if (isupper(*bp))
-				*bp = tolower(*bp);		/* map name to lower case */
-	}
-
-	return logname;
+    if ((op->flags & (F_EIGHTBITS | F_UTF8)) == (F_EIGHTBITS | F_UTF8))
+    {
+        /* Check out UTF-8 multibyte characters */
+        ssize_t  len;
+        wchar_t *wcs, *wcp;
+
+        len = mbstowcs((wchar_t*)0, logname, 0);
+        if (len < 0)
+            log_err(_("%s: invalid character conversion for login name"),
+                    op->tty);
+
+        wcs = malloc((len + 1) * sizeof(wchar_t));
+        if (!wcs) log_err(_("failed to allocate memory: %m"));
+
+        len = mbstowcs(wcs, logname, len + 1);
+        if (len < 0)
+            log_err(_("%s: invalid character conversion for login name"),
+                    op->tty);
+
+        wcp = wcs;
+        while (*wcp)
+        {
+            const wint_t wc = *wcp++;
+            if (!iswprint(wc))
+                log_err(_("%s: invalid character 0x%x in login name"), op->tty,
+                        wc);
+        }
+        free(wcs);
+    }
+    else
+#endif
+        if ((op->flags & F_LCUC) && (cp->capslock = caps_lock(logname)))
+    {
+
+        /* Handle names with upper case and no lower case. */
+        for (bp = logname; *bp; bp++)
+            if (isupper(*bp)) *bp = tolower(*bp); /* map name to lower case */
+    }
+
+    return logname;
 }
 
 /* Set the final tty mode bits. */
-static void termio_final(struct options *op, struct termios *tp, struct chardata *cp)
+static void termio_final(struct options* op, struct termios* tp,
+                         struct chardata* cp)
 {
-	/* General terminal-independent stuff. */
-
-	/* 2-way flow control */
-	tp->c_iflag |= IXON | IXOFF;
-	tp->c_lflag |= ICANON | ISIG | ECHO | ECHOE | ECHOK | ECHOKE;
-	/* no longer| ECHOCTL | ECHOPRT */
-	tp->c_oflag |= OPOST;
-	/* tp->c_cflag = 0; */
-	tp->c_cc[VINTR] = DEF_INTR;
-	tp->c_cc[VQUIT] = DEF_QUIT;
-	tp->c_cc[VEOF] = DEF_EOF;
-	tp->c_cc[VEOL] = DEF_EOL;
+    /* General terminal-independent stuff. */
+
+    /* 2-way flow control */
+    tp->c_iflag |= IXON | IXOFF;
+    tp->c_lflag |= ICANON | ISIG | ECHO | ECHOE | ECHOK | ECHOKE;
+    /* no longer| ECHOCTL | ECHOPRT */
+    tp->c_oflag |= OPOST;
+    /* tp->c_cflag = 0; */
+    tp->c_cc[VINTR] = DEF_INTR;
+    tp->c_cc[VQUIT] = DEF_QUIT;
+    tp->c_cc[VEOF]  = DEF_EOF;
+    tp->c_cc[VEOL]  = DEF_EOL;
 #ifdef __linux__
-	tp->c_cc[VSWTC] = DEF_SWITCH;
+    tp->c_cc[VSWTC] = DEF_SWITCH;
 #elif defined(VSWTCH)
-	tp->c_cc[VSWTCH] = DEF_SWITCH;
-#endif				/* __linux__ */
-
-	/* Account for special characters seen in input. */
-	if (cp->eol == CR) {
-		tp->c_iflag |= ICRNL;
-		tp->c_oflag |= ONLCR;
-	}
-	tp->c_cc[VERASE] = cp->erase;
-	tp->c_cc[VKILL] = cp->kill;
-
-	/* Account for the presence or absence of parity bits in input. */
-	switch (cp->parity) {
-	case 0:
-		/* space (always 0) parity */
-		break;
-	case 1:
-		/* odd parity */
-		tp->c_cflag |= PARODD;
-		/* fallthrough */
-	case 2:
-		/* even parity */
-		tp->c_cflag |= PARENB;
-		tp->c_iflag |= INPCK | ISTRIP;
-		/* fallthrough */
-	case (1 | 2):
-		/* no parity bit */
-		tp->c_cflag &= ~CSIZE;
-		tp->c_cflag |= CS7;
-		break;
-	}
-	/* Account for upper case without lower case. */
-	if (cp->capslock) {
+    tp->c_cc[VSWTCH] = DEF_SWITCH;
+#endif /* __linux__ */
+
+    /* Account for special characters seen in input. */
+    if (cp->eol == CR)
+    {
+        tp->c_iflag |= ICRNL;
+        tp->c_oflag |= ONLCR;
+    }
+    tp->c_cc[VERASE] = cp->erase;
+    tp->c_cc[VKILL]  = cp->kill;
+
+    /* Account for the presence or absence of parity bits in input. */
+    switch (cp->parity)
+    {
+        case 0:
+            /* space (always 0) parity */
+            break;
+        case 1:
+            /* odd parity */
+            tp->c_cflag |= PARODD;
+            /* fallthrough */
+        case 2:
+            /* even parity */
+            tp->c_cflag |= PARENB;
+            tp->c_iflag |= INPCK | ISTRIP;
+            /* fallthrough */
+        case (1 | 2):
+            /* no parity bit */
+            tp->c_cflag &= ~CSIZE;
+            tp->c_cflag |= CS7;
+            break;
+    }
+    /* Account for upper case without lower case. */
+    if (cp->capslock)
+    {
 #ifdef IUCLC
-		tp->c_iflag |= IUCLC;
+        tp->c_iflag |= IUCLC;
 #endif
 #ifdef XCASE
-		tp->c_lflag |= XCASE;
+        tp->c_lflag |= XCASE;
 #endif
 #ifdef OLCUC
-		tp->c_oflag |= OLCUC;
+        tp->c_oflag |= OLCUC;
 #endif
-	}
-	/* Optionally enable hardware flow control. */
-#ifdef	CRTSCTS
-	if (op->flags & F_RTSCTS)
-		tp->c_cflag |= CRTSCTS;
+    }
+    /* Optionally enable hardware flow control. */
+#ifdef CRTSCTS
+    if (op->flags & F_RTSCTS) tp->c_cflag |= CRTSCTS;
 #endif
 
-	/* Finally, make the new settings effective. */
-	if (tcsetattr(STDIN_FILENO, TCSANOW, tp) < 0)
-		log_err(_("%s: failed to set terminal attributes: %m"), op->tty);
+    /* Finally, make the new settings effective. */
+    if (tcsetattr(STDIN_FILENO, TCSANOW, tp) < 0)
+        log_err(_("%s: failed to set terminal attributes: %m"), op->tty);
 }
 
 /*
@@ -2403,90 +2382,105 @@ static void termio_final(struct options *op, struct termios *tp, struct chardata
  * http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=52940
  * http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=156242
  */
-static int caps_lock(char *s)
+static int caps_lock(char* s)
 {
-	int capslock;
-
-	for (capslock = 0; *s; s++) {
-		if (islower(*s))
-			return EXIT_SUCCESS;
-		if (capslock == 0)
-			capslock = isupper(*s);
-	}
-	return capslock;
+    int capslock;
+
+    for (capslock = 0; *s; s++)
+    {
+        if (islower(*s)) return EXIT_SUCCESS;
+        if (capslock == 0) capslock = isupper(*s);
+    }
+    return capslock;
 }
 
 /* Convert speed string to speed code; return 0 on failure. */
-static speed_t bcode(char *s)
+static speed_t bcode(char* s)
 {
-	const struct Speedtab *sp;
-	long speed = atol(s);
+    const struct Speedtab* sp;
+    long                   speed = atol(s);
 
-	for (sp = speedtab; sp->speed; sp++)
-		if (sp->speed == speed)
-			return sp->code;
-	return 0;
+    for (sp = speedtab; sp->speed; sp++)
+        if (sp->speed == speed) return sp->code;
+    return 0;
 }
 
 static void __attribute__((__noreturn__)) usage(void)
 {
-	FILE *out = stdout;
-
-	fputs(USAGE_HEADER, out);
-	fprintf(out, _(" %1$s [options] <line> [<baud_rate>,...] [<termtype>]\n"
-		       " %1$s [options] <baud_rate>,... <line> [<termtype>]\n"), program_invocation_short_name);
-
-	fputs(USAGE_SEPARATOR, out);
-	fputs(_("Open a terminal and set its mode.\n"), out);
-
-	fputs(USAGE_OPTIONS, out);
-	fputs(_(" -8, --8bits                assume 8-bit tty\n"), out);
-	fputs(_(" -a, --autologin <user>     login the specified user automatically\n"), out);
-	fputs(_(" -c, --noreset              do not reset control mode\n"), out);
-	fputs(_(" -E, --remote               use -r <hostname> for login(1)\n"), out);
-	fputs(_(" -f, --issue-file <list>    display issue files or directories\n"), out);
-	fputs(_("     --show-issue           display issue file and exit\n"), out);
-	fputs(_(" -h, --flow-control         enable hardware flow control\n"), out);
-	fputs(_(" -H, --host <hostname>      specify login host\n"), out);
-	fputs(_(" -i, --noissue              do not display issue file\n"), out);
-	fputs(_(" -I, --init-string <string> set init string\n"), out);
-	fputs(_(" -J  --noclear              do not clear the screen before prompt\n"), out);
-	fputs(_(" -l, --login-program <file> specify login program\n"), out);
-	fputs(_(" -L, --local-line[=<mode>]  control the local line flag\n"), out);
-	fputs(_(" -m, --extract-baud         extract baud rate during connect\n"), out);
-	fputs(_(" -n, --skip-login           do not prompt for login\n"), out);
-	fputs(_(" -N  --nonewline            do not print a newline before issue\n"), out);
-	fputs(_(" -o, --login-options <opts> options that are passed to login\n"), out);
-	fputs(_(" -p, --login-pause          wait for any key before the login\n"), out);
-	fputs(_(" -r, --chroot <dir>         change root to the directory\n"), out);
-	fputs(_(" -R, --hangup               do virtually hangup on the tty\n"), out);
-	fputs(_(" -s, --keep-baud            try to keep baud rate after break\n"), out);
-	fputs(_(" -t, --timeout <number>     login process timeout\n"), out);
-	fputs(_(" -U, --detect-case          detect uppercase terminal\n"), out);
-	fputs(_(" -w, --wait-cr              wait carriage-return\n"), out);
-	fputs(_("     --nohints              do not print hints\n"), out);
-	fputs(_("     --nohostname           no hostname at all will be shown\n"), out);
-	fputs(_("     --long-hostname        show full qualified hostname\n"), out);
-	fputs(_("     --erase-chars <string> additional backspace chars\n"), out);
-	fputs(_("     --kill-chars <string>  additional kill chars\n"), out);
-	fputs(_("     --chdir <directory>    chdir before the login\n"), out);
-	fputs(_("     --delay <number>       sleep seconds before prompt\n"), out);
-	fputs(_("     --nice <number>        run login with this priority\n"), out);
-	fputs(_("     --reload               reload prompts on running agetty instances\n"), out);
-	fputs(_("     --list-speeds          display supported baud rates\n"), out);
-	printf( "     --help                 %s\n", USAGE_OPTSTR_HELP);
-	printf( "     --version              %s\n", USAGE_OPTSTR_VERSION);
-	printf(USAGE_MAN_TAIL("agetty(8)"));
-
-	exit(EXIT_SUCCESS);
+    FILE* out = stdout;
+
+    fputs(USAGE_HEADER, out);
+    fprintf(out,
+            _(" %1$s [options] <line> [<baud_rate>,...] [<termtype>]\n"
+              " %1$s [options] <baud_rate>,... <line> [<termtype>]\n"),
+            program_invocation_short_name);
+
+    fputs(USAGE_SEPARATOR, out);
+    fputs(_("Open a terminal and set its mode.\n"), out);
+
+    fputs(USAGE_OPTIONS, out);
+    fputs(_(" -8, --8bits                assume 8-bit tty\n"), out);
+    fputs(_(" -a, --autologin <user>     login the specified user "
+            "automatically\n"),
+          out);
+    fputs(_(" -c, --noreset              do not reset control mode\n"), out);
+    fputs(_(" -E, --remote               use -r <hostname> for login(1)\n"),
+          out);
+    fputs(_(" -f, --issue-file <list>    display issue files or directories\n"),
+          out);
+    fputs(_("     --show-issue           display issue file and exit\n"), out);
+    fputs(_(" -h, --flow-control         enable hardware flow control\n"), out);
+    fputs(_(" -H, --host <hostname>      specify login host\n"), out);
+    fputs(_(" -i, --noissue              do not display issue file\n"), out);
+    fputs(_(" -I, --init-string <string> set init string\n"), out);
+    fputs(_(" -J  --noclear              do not clear the screen before "
+            "prompt\n"),
+          out);
+    fputs(_(" -l, --login-program <file> specify login program\n"), out);
+    fputs(_(" -L, --local-line[=<mode>]  control the local line flag\n"), out);
+    fputs(_(" -m, --extract-baud         extract baud rate during connect\n"),
+          out);
+    fputs(_(" -n, --skip-login           do not prompt for login\n"), out);
+    fputs(
+        _(" -N  --nonewline            do not print a newline before issue\n"),
+        out);
+    fputs(_(" -o, --login-options <opts> options that are passed to login\n"),
+          out);
+    fputs(_(" -p, --login-pause          wait for any key before the login\n"),
+          out);
+    fputs(_(" -r, --chroot <dir>         change root to the directory\n"), out);
+    fputs(_(" -R, --hangup               do virtually hangup on the tty\n"),
+          out);
+    fputs(_(" -s, --keep-baud            try to keep baud rate after break\n"),
+          out);
+    fputs(_(" -t, --timeout <number>     login process timeout\n"), out);
+    fputs(_(" -U, --detect-case          detect uppercase terminal\n"), out);
+    fputs(_(" -w, --wait-cr              wait carriage-return\n"), out);
+    fputs(_("     --nohints              do not print hints\n"), out);
+    fputs(_("     --nohostname           no hostname at all will be shown\n"),
+          out);
+    fputs(_("     --long-hostname        show full qualified hostname\n"), out);
+    fputs(_("     --erase-chars <string> additional backspace chars\n"), out);
+    fputs(_("     --kill-chars <string>  additional kill chars\n"), out);
+    fputs(_("     --chdir <directory>    chdir before the login\n"), out);
+    fputs(_("     --delay <number>       sleep seconds before prompt\n"), out);
+    fputs(_("     --nice <number>        run login with this priority\n"), out);
+    fputs(_("     --reload               reload prompts on running agetty "
+            "instances\n"),
+          out);
+    fputs(_("     --list-speeds          display supported baud rates\n"), out);
+    printf("     --help                 %s\n", USAGE_OPTSTR_HELP);
+    printf("     --version              %s\n", USAGE_OPTSTR_VERSION);
+    printf(USAGE_MAN_TAIL("agetty(8)"));
+
+    exit(EXIT_SUCCESS);
 }
 
 static void list_speeds(void)
 {
-	const struct Speedtab *sp;
+    const struct Speedtab* sp;
 
-	for (sp = speedtab; sp->speed; sp++)
-		printf("%10ld\n", sp->speed);
+    for (sp = speedtab; sp->speed; sp++) printf("%10ld\n", sp->speed);
 }
 
 /*
@@ -2496,73 +2490,75 @@ static void list_speeds(void)
  */
 static void dolog(int priority
 #ifndef USE_SYSLOG
-		  __attribute__((__unused__))
+                  __attribute__((__unused__))
 #endif
-		  , const char *fmt, va_list ap)
+                  ,
+                  const char* fmt, va_list ap)
 {
 #ifdef USE_SYSLOG
-	/*
-	 * If the diagnostic is reported via syslog(3), the process name is
-	 * automatically prepended to the message. If we write directly to
-	 * /dev/console, we must prepend the process name ourselves.
-	 */
-	openlog(program_invocation_short_name, LOG_PID, LOG_AUTHPRIV);
-	vsyslog(priority, fmt, ap);
-	closelog();
+    /*
+     * If the diagnostic is reported via syslog(3), the process name is
+     * automatically prepended to the message. If we write directly to
+     * /dev/console, we must prepend the process name ourselves.
+     */
+    openlog(program_invocation_short_name, LOG_PID, LOG_AUTHPRIV);
+    vsyslog(priority, fmt, ap);
+    closelog();
 #else
-	/*
-	 * Write the diagnostic directly to /dev/console if we do not use
-	 * the syslog(3) facility.
-	 */
-	char buf[BUFSIZ];
-	char new_fmt[BUFSIZ];
-	int fd;
-
-	snprintf(new_fmt, sizeof(new_fmt), "%s: %s\r\n",
-		 program_invocation_short_name, fmt);
-	/* Terminate with CR-LF since the console mode is unknown. */
-	vsnprintf(buf, sizeof(buf), new_fmt, ap);
-
-	if ((fd = open("/dev/console", 1)) >= 0) {
-		write_all(fd, buf, strlen(buf));
-		close(fd);
-	}
-#endif	/* USE_SYSLOG */
+    /*
+     * Write the diagnostic directly to /dev/console if we do not use
+     * the syslog(3) facility.
+     */
+    char buf[BUFSIZ];
+    char new_fmt[BUFSIZ];
+    int  fd;
+
+    snprintf(new_fmt, sizeof(new_fmt), "%s: %s\r\n",
+             program_invocation_short_name, fmt);
+    /* Terminate with CR-LF since the console mode is unknown. */
+    vsnprintf(buf, sizeof(buf), new_fmt, ap);
+
+    if ((fd = open("/dev/console", 1)) >= 0)
+    {
+        write_all(fd, buf, strlen(buf));
+        close(fd);
+    }
+#endif /* USE_SYSLOG */
 }
 
 static void exit_slowly(int code)
 {
-	/* Be kind to init(8). */
-	sleep(10);
-	exit(code);
+    /* Be kind to init(8). */
+    sleep(10);
+    exit(code);
 }
 
-static void log_err(const char *fmt, ...)
+static void log_err(const char* fmt, ...)
 {
-	va_list ap;
+    va_list ap;
 
-	va_start(ap, fmt);
-	dolog(LOG_ERR, fmt, ap);
-	va_end(ap);
+    va_start(ap, fmt);
+    dolog(LOG_ERR, fmt, ap);
+    va_end(ap);
 
-	exit_slowly(EXIT_FAILURE);
+    exit_slowly(EXIT_FAILURE);
 }
 
-static void log_warn(const char *fmt, ...)
+static void log_warn(const char* fmt, ...)
 {
-	va_list ap;
+    va_list ap;
 
-	va_start(ap, fmt);
-	dolog(LOG_WARNING, fmt, ap);
-	va_end(ap);
+    va_start(ap, fmt);
+    dolog(LOG_WARNING, fmt, ap);
+    va_end(ap);
 }
 
-static void print_addr(struct issue *ie, sa_family_t family, void *addr)
+static void print_addr(struct issue* ie, sa_family_t family, void* addr)
 {
-	char buff[INET6_ADDRSTRLEN + 1];
+    char buff[INET6_ADDRSTRLEN + 1];
 
-	inet_ntop(family, addr, buff, sizeof(buff));
-	fprintf(ie->output, "%s", buff);
+    inet_ntop(family, addr, buff, sizeof(buff));
+    fprintf(ie->output, "%s", buff);
 }
 
 /*
@@ -2570,330 +2566,328 @@ static void print_addr(struct issue *ie, sa_family_t family, void *addr)
  * specified then prints the "best" one (UP, RUNNING, non-LOOPBACK). If not
  * found the "best" interface then prints at least host IP.
  */
-static void output_iface_ip(struct issue *ie,
-			    struct ifaddrs *addrs,
-			    const char *iface,
-			    sa_family_t family)
+static void output_iface_ip(struct issue* ie, struct ifaddrs* addrs,
+                            const char* iface, sa_family_t family)
 {
-	struct ifaddrs *p;
-	struct addrinfo hints, *info = NULL;
-	char *host = NULL;
-	void *addr = NULL;
-
-	if (!addrs)
-		return;
-
-	for (p = addrs; p; p = p->ifa_next) {
-
-		if (!p->ifa_name ||
-		    !p->ifa_addr ||
-		    p->ifa_addr->sa_family != family)
-			continue;
-
-		if (iface) {
-			/* Filter out by interface name */
-		       if (strcmp(p->ifa_name, iface) != 0)
-				continue;
-		} else {
-			/* Select the "best" interface */
-			if ((p->ifa_flags & IFF_LOOPBACK) ||
-			    !(p->ifa_flags & IFF_UP) ||
-			    !(p->ifa_flags & IFF_RUNNING))
-				continue;
-		}
-
-		addr = NULL;
-		switch (p->ifa_addr->sa_family) {
-		case AF_INET:
-			addr = &((struct sockaddr_in *)	p->ifa_addr)->sin_addr;
-			break;
-		case AF_INET6:
-			addr = &((struct sockaddr_in6 *) p->ifa_addr)->sin6_addr;
-			break;
-		}
-
-		if (addr) {
-			print_addr(ie, family, addr);
-			return;
-		}
-	}
-
-	if (iface)
-		return;
-
-	/* Hmm.. not found the best interface, print host IP at least */
-	memset(&hints, 0, sizeof(hints));
-	hints.ai_family = family;
-	if (family == AF_INET6)
-		hints.ai_flags = AI_V4MAPPED;
-
-	host = xgethostname();
-	if (host && getaddrinfo(host, NULL, &hints, &info) == 0 && info) {
-		switch (info->ai_family) {
-		case AF_INET:
-			addr = &((struct sockaddr_in *) info->ai_addr)->sin_addr;
-			break;
-		case AF_INET6:
-			addr = &((struct sockaddr_in6 *) info->ai_addr)->sin6_addr;
-			break;
-		}
-		if (addr)
-			print_addr(ie, family, addr);
-
-		freeaddrinfo(info);
-	}
-	free(host);
+    struct ifaddrs* p;
+    struct addrinfo hints, *info = NULL;
+    char*           host = NULL;
+    void*           addr = NULL;
+
+    if (!addrs) return;
+
+    for (p = addrs; p; p = p->ifa_next)
+    {
+
+        if (!p->ifa_name || !p->ifa_addr || p->ifa_addr->sa_family != family)
+            continue;
+
+        if (iface)
+        {
+            /* Filter out by interface name */
+            if (strcmp(p->ifa_name, iface) != 0) continue;
+        }
+        else
+        {
+            /* Select the "best" interface */
+            if ((p->ifa_flags & IFF_LOOPBACK) || !(p->ifa_flags & IFF_UP)
+                || !(p->ifa_flags & IFF_RUNNING))
+                continue;
+        }
+
+        addr = NULL;
+        switch (p->ifa_addr->sa_family)
+        {
+            case AF_INET:
+                addr = &((struct sockaddr_in*)p->ifa_addr)->sin_addr;
+                break;
+            case AF_INET6:
+                addr = &((struct sockaddr_in6*)p->ifa_addr)->sin6_addr;
+                break;
+        }
+
+        if (addr)
+        {
+            print_addr(ie, family, addr);
+            return;
+        }
+    }
+
+    if (iface) return;
+
+    /* Hmm.. not found the best interface, print host IP at least */
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_family = family;
+    if (family == AF_INET6) hints.ai_flags = AI_V4MAPPED;
+
+    host = xgethostname();
+    if (host && getaddrinfo(host, NULL, &hints, &info) == 0 && info)
+    {
+        switch (info->ai_family)
+        {
+            case AF_INET:
+                addr = &((struct sockaddr_in*)info->ai_addr)->sin_addr;
+                break;
+            case AF_INET6:
+                addr = &((struct sockaddr_in6*)info->ai_addr)->sin6_addr;
+                break;
+        }
+        if (addr) print_addr(ie, family, addr);
+
+        freeaddrinfo(info);
+    }
+    free(host);
 }
 
 /*
  * parses \x{argument}, if not argument specified then returns NULL, the @fd
  * has to point to one char after the sequence (it means '{').
  */
-static char *get_escape_argument(FILE *fd, char *buf, size_t bufsz)
+static char* get_escape_argument(FILE* fd, char* buf, size_t bufsz)
 {
-	size_t i = 0;
-	int c = fgetc(fd);
+    size_t i = 0;
+    int    c = fgetc(fd);
 
-	if (c == EOF || (unsigned char) c != '{') {
-		ungetc(c, fd);
-		return NULL;
-	}
+    if (c == EOF || (unsigned char)c != '{')
+    {
+        ungetc(c, fd);
+        return NULL;
+    }
 
-	do {
-		c = fgetc(fd);
-		if (c == EOF)
-			return NULL;
-		if ((unsigned char) c != '}' && i < bufsz - 1)
-			buf[i++] = (unsigned char) c;
+    do {
+        c = fgetc(fd);
+        if (c == EOF) return NULL;
+        if ((unsigned char)c != '}' && i < bufsz - 1)
+            buf[i++] = (unsigned char)c;
 
-	} while ((unsigned char) c != '}');
+    } while ((unsigned char)c != '}');
 
-	buf[i] = '\0';
-	return buf;
+    buf[i] = '\0';
+    return buf;
 }
 
-static void output_special_char(struct issue *ie,
-				unsigned char c,
-				struct options *op,
-				struct termios *tp,
-				FILE *fp)
+static void output_special_char(struct issue* ie, unsigned char c,
+                                struct options* op, struct termios* tp,
+                                FILE* fp)
 {
-	struct utsname uts;
-
-	switch (c) {
-	case 'e':
-	{
-		char escname[UL_COLORNAME_MAXSZ];
-
-		if (get_escape_argument(fp, escname, sizeof(escname))) {
-			const char *esc = color_sequence_from_colorname(escname);
-			if (esc)
-				fputs(esc, ie->output);
-		} else
-			fputs("\033", ie->output);
-		break;
-	}
-	case 's':
-		uname(&uts);
-		fprintf(ie->output, "%s", uts.sysname);
-		break;
-	case 'n':
-		uname(&uts);
-		fprintf(ie->output, "%s", uts.nodename);
-		break;
-	case 'r':
-		uname(&uts);
-		fprintf(ie->output, "%s", uts.release);
-		break;
-	case 'v':
-		uname(&uts);
-		fprintf(ie->output, "%s", uts.version);
-		break;
-	case 'm':
-		uname(&uts);
-		fprintf(ie->output, "%s", uts.machine);
-		break;
-	case 'o':
-	{
-		char *dom = xgetdomainname();
-
-		fputs(dom ? dom : "unknown_domain", ie->output);
-		free(dom);
-		break;
-	}
-	case 'O':
-	{
-		char *dom = NULL;
-		char *host = xgethostname();
-		struct addrinfo hints, *info = NULL;
-
-		memset(&hints, 0, sizeof(hints));
-		hints.ai_flags = AI_CANONNAME;
-
-		if (host && getaddrinfo(host, NULL, &hints, &info) == 0 && info) {
-			char *canon;
-
-			if (info->ai_canonname &&
-			    (canon = strchr(info->ai_canonname, '.')))
-				dom = canon + 1;
-		}
-		fputs(dom ? dom : "unknown_domain", ie->output);
-		if (info)
-			freeaddrinfo(info);
-		free(host);
-		break;
-	}
-	case 'd':
-	case 't':
-	{
-		time_t now;
-		struct tm tm;
-
-		time(&now);
-		localtime_r(&now, &tm);
-
-		if (c == 'd') /* ISO 8601 */
-			fprintf(ie->output, "%s %s %d  %d",
-				      nl_langinfo(ABDAY_1 + tm.tm_wday),
-				      nl_langinfo(ABMON_1 + tm.tm_mon),
-				      tm.tm_mday,
-				      tm.tm_year < 70 ? tm.tm_year + 2000 :
-				      tm.tm_year + 1900);
-		else
-			fprintf(ie->output, "%02d:%02d:%02d",
-				      tm.tm_hour, tm.tm_min, tm.tm_sec);
-		break;
-	}
-	case 'l':
-		fprintf (ie->output, "%s", op->tty);
-		break;
-	case 'b':
-	{
-		const speed_t speed = cfgetispeed(tp);
-		int i;
-
-		for (i = 0; speedtab[i].speed; i++) {
-			if (speedtab[i].code == speed) {
-				fprintf(ie->output, "%ld", speedtab[i].speed);
-				break;
-			}
-		}
-		break;
-	}
-	case 'S':
-	{
-		char *var = NULL, varname[64];
-
-		/* \S{varname} */
-		if (get_escape_argument(fp, varname, sizeof(varname))) {
-			var = read_os_release(op, varname);
-			if (var) {
-				if (strcmp(varname, "ANSI_COLOR") == 0)
-					fprintf(ie->output, "\033[%sm", var);
-				else
-					fputs(var, ie->output);
-			}
-		/* \S */
-		} else if ((var = read_os_release(op, "PRETTY_NAME"))) {
-			fputs(var, ie->output);
-
-		/* \S and PRETTY_NAME not found */
-		} else {
-			uname(&uts);
-			fputs(uts.sysname, ie->output);
-		}
-
-		free(var);
-
-		break;
-	}
-	case 'u':
-	case 'U':
-	{
-		int users = 0;
-		struct utmpx *ut;
-		setutxent();
-		while ((ut = getutxent()))
-			if (ut->ut_type == USER_PROCESS)
-				users++;
-		endutxent();
-		if (c == 'U')
-			fprintf(ie->output, P_("%d user", "%d users", users), users);
-		else
-			fprintf (ie->output, "%d ", users);
-		break;
-	}
+    struct utsname uts;
+
+    switch (c)
+    {
+        case 'e':
+        {
+            char escname[UL_COLORNAME_MAXSZ];
+
+            if (get_escape_argument(fp, escname, sizeof(escname)))
+            {
+                const char* esc = color_sequence_from_colorname(escname);
+                if (esc) fputs(esc, ie->output);
+            }
+            else fputs("\033", ie->output);
+            break;
+        }
+        case 's':
+            uname(&uts);
+            fprintf(ie->output, "%s", uts.sysname);
+            break;
+        case 'n':
+            uname(&uts);
+            fprintf(ie->output, "%s", uts.nodename);
+            break;
+        case 'r':
+            uname(&uts);
+            fprintf(ie->output, "%s", uts.release);
+            break;
+        case 'v':
+            uname(&uts);
+            fprintf(ie->output, "%s", uts.version);
+            break;
+        case 'm':
+            uname(&uts);
+            fprintf(ie->output, "%s", uts.machine);
+            break;
+        case 'o':
+        {
+            char* dom = xgetdomainname();
+
+            fputs(dom ? dom : "unknown_domain", ie->output);
+            free(dom);
+            break;
+        }
+        case 'O':
+        {
+            char*           dom  = NULL;
+            char*           host = xgethostname();
+            struct addrinfo hints, *info = NULL;
+
+            memset(&hints, 0, sizeof(hints));
+            hints.ai_flags = AI_CANONNAME;
+
+            if (host && getaddrinfo(host, NULL, &hints, &info) == 0 && info)
+            {
+                char* canon;
+
+                if (info->ai_canonname
+                    && (canon = strchr(info->ai_canonname, '.')))
+                    dom = canon + 1;
+            }
+            fputs(dom ? dom : "unknown_domain", ie->output);
+            if (info) freeaddrinfo(info);
+            free(host);
+            break;
+        }
+        case 'd':
+        case 't':
+        {
+            time_t    now;
+            struct tm tm;
+
+            time(&now);
+            localtime_r(&now, &tm);
+
+            if (c == 'd') /* ISO 8601 */
+                fprintf(ie->output, "%s %s %d  %d",
+                        nl_langinfo(ABDAY_1 + tm.tm_wday),
+                        nl_langinfo(ABMON_1 + tm.tm_mon), tm.tm_mday,
+                        tm.tm_year < 70 ? tm.tm_year + 2000
+                                        : tm.tm_year + 1900);
+            else
+                fprintf(ie->output, "%02d:%02d:%02d", tm.tm_hour, tm.tm_min,
+                        tm.tm_sec);
+            break;
+        }
+        case 'l': fprintf(ie->output, "%s", op->tty); break;
+        case 'b':
+        {
+            const speed_t speed = cfgetispeed(tp);
+            int           i;
+
+            for (i = 0; speedtab[i].speed; i++)
+            {
+                if (speedtab[i].code == speed)
+                {
+                    fprintf(ie->output, "%ld", speedtab[i].speed);
+                    break;
+                }
+            }
+            break;
+        }
+        case 'S':
+        {
+            char *var = NULL, varname[64];
+
+            /* \S{varname} */
+            if (get_escape_argument(fp, varname, sizeof(varname)))
+            {
+                var = read_os_release(op, varname);
+                if (var)
+                {
+                    if (strcmp(varname, "ANSI_COLOR") == 0)
+                        fprintf(ie->output, "\033[%sm", var);
+                    else fputs(var, ie->output);
+                }
+                /* \S */
+            }
+            else if ((var = read_os_release(op, "PRETTY_NAME")))
+            {
+                fputs(var, ie->output);
+
+                /* \S and PRETTY_NAME not found */
+            }
+            else
+            {
+                uname(&uts);
+                fputs(uts.sysname, ie->output);
+            }
+
+            free(var);
+
+            break;
+        }
+        case 'u':
+        case 'U':
+        {
+            int           users = 0;
+            struct utmpx* ut;
+            setutxent();
+            while ((ut = getutxent()))
+                if (ut->ut_type == USER_PROCESS) users++;
+            endutxent();
+            if (c == 'U')
+                fprintf(ie->output, P_("%d user", "%d users", users), users);
+            else fprintf(ie->output, "%d ", users);
+            break;
+        }
 #if defined(RTMGRP_IPV4_IFADDR) && defined(RTMGRP_IPV6_IFADDR)
-	case '4':
-	case '6':
-	{
-		sa_family_t family = c == '4' ? AF_INET : AF_INET6;
-		struct ifaddrs *addrs = NULL;
-		char iface[128];
-
-		if (getifaddrs(&addrs))
-			break;
-
-		if (get_escape_argument(fp, iface, sizeof(iface)))
-			output_iface_ip(ie, addrs, iface, family);
-		else
-			output_iface_ip(ie, addrs, NULL, family);
-
-		freeifaddrs(addrs);
-
-		if (c == '4')
-			netlink_groups |= RTMGRP_IPV4_IFADDR;
-		else
-			netlink_groups |= RTMGRP_IPV6_IFADDR;
-		break;
-	}
-#endif
-	default:
-		putc(c, ie->output);
-		break;
-	}
+        case '4':
+        case '6':
+        {
+            sa_family_t     family = c == '4' ? AF_INET : AF_INET6;
+            struct ifaddrs* addrs  = NULL;
+            char            iface[128];
+
+            if (getifaddrs(&addrs)) break;
+
+            if (get_escape_argument(fp, iface, sizeof(iface)))
+                output_iface_ip(ie, addrs, iface, family);
+            else output_iface_ip(ie, addrs, NULL, family);
+
+            freeifaddrs(addrs);
+
+            if (c == '4') netlink_groups |= RTMGRP_IPV4_IFADDR;
+            else netlink_groups |= RTMGRP_IPV6_IFADDR;
+            break;
+        }
+#endif
+        default: putc(c, ie->output); break;
+    }
 }
 
-static void init_special_char(char* arg, struct options *op)
+static void init_special_char(char* arg, struct options* op)
 {
-	char ch, *p, *q;
-	int i;
-
-	op->initstring = malloc(strlen(arg) + 1);
-	if (!op->initstring)
-		log_err(_("failed to allocate memory: %m"));
-
-	/*
-	 * Copy optarg into op->initstring decoding \ddd octal
-	 * codes into chars.
-	 */
-	q = op->initstring;
-	p = arg;
-	while (*p) {
-		/* The \\ is converted to \ */
-		if (*p == '\\') {
-			p++;
-			if (*p == '\\') {
-				ch = '\\';
-				p++;
-			} else {
-				/* Handle \000 - \177. */
-				ch = 0;
-				for (i = 1; i <= 3; i++) {
-					if (*p >= '0' && *p <= '7') {
-						ch <<= 3;
-						ch += *p - '0';
-						p++;
-					} else {
-						break;
-					}
-				}
-			}
-			*q++ = ch;
-		} else
-			*q++ = *p++;
-	}
-	*q = '\0';
+    char ch, *p, *q;
+    int  i;
+
+    op->initstring = malloc(strlen(arg) + 1);
+    if (!op->initstring) log_err(_("failed to allocate memory: %m"));
+
+    /*
+     * Copy optarg into op->initstring decoding \ddd octal
+     * codes into chars.
+     */
+    q = op->initstring;
+    p = arg;
+    while (*p)
+    {
+        /* The \\ is converted to \ */
+        if (*p == '\\')
+        {
+            p++;
+            if (*p == '\\')
+            {
+                ch = '\\';
+                p++;
+            }
+            else
+            {
+                /* Handle \000 - \177. */
+                ch = 0;
+                for (i = 1; i <= 3; i++)
+                {
+                    if (*p >= '0' && *p <= '7')
+                    {
+                        ch <<= 3;
+                        ch += *p - '0';
+                        p++;
+                    }
+                    else { break; }
+                }
+            }
+            *q++ = ch;
+        }
+        else *q++ = *p++;
+    }
+    *q = '\0';
 }
 
 /*
@@ -2902,32 +2896,29 @@ static void init_special_char(char* arg, struct options *op)
  *
  * Returns the final @dest length or -1 in case of error.
  */
-static ssize_t append(char *dest, size_t len, const char  *sep, const char *src)
+static ssize_t append(char* dest, size_t len, const char* sep, const char* src)
 {
-	size_t dsz = 0, ssz = 0, sz;
-	char *p;
-
-	if (!dest || !len || !src)
-		return -1;
-
-	if (*dest)
-		dsz = strlen(dest);
-	if (dsz && sep)
-		ssz = strlen(sep);
-	sz = strlen(src);
-
-	if (dsz + ssz + sz + 1 > len)
-		return -1;
-
-	p = dest + dsz;
-	if (ssz) {
-		memcpy(p, sep, ssz);
-		p += ssz;
-	}
-	memcpy(p, src, sz);
-	*(p + sz) = '\0';
-
-	return dsz + ssz + sz;
+    size_t dsz = 0, ssz = 0, sz;
+    char*  p;
+
+    if (!dest || !len || !src) return -1;
+
+    if (*dest) dsz = strlen(dest);
+    if (dsz && sep) ssz = strlen(sep);
+    sz = strlen(src);
+
+    if (dsz + ssz + sz + 1 > len) return -1;
+
+    p = dest + dsz;
+    if (ssz)
+    {
+        memcpy(p, sep, ssz);
+        p += ssz;
+    }
+    memcpy(p, src, sz);
+    *(p + sz) = '\0';
+
+    return dsz + ssz + sz;
 }
 
 /*
@@ -2937,34 +2928,28 @@ static ssize_t append(char *dest, size_t len, const char  *sep, const char *src)
  */
 static void check_username(const char* nm)
 {
-	const char *p = nm;
-	if (!nm)
-		goto err;
-	if (strlen(nm) > 42)
-		goto err;
-	while (isspace(*p))
-		p++;
-	if (*p == '-')
-		goto err;
-	return;
+    const char* p = nm;
+    if (!nm) goto err;
+    if (strlen(nm) > 42) goto err;
+    while (isspace(*p)) p++;
+    if (*p == '-') goto err;
+    return;
 err:
-	errno = EPERM;
-	log_err(_("checkname failed: %m"));
+    errno = EPERM;
+    log_err(_("checkname failed: %m"));
 }
 
 static void reload_agettys(void)
 {
 #ifdef AGETTY_RELOAD
-	int fd = open(AGETTY_RELOAD_FILENAME, O_CREAT|O_CLOEXEC|O_WRONLY,
-					      S_IRUSR|S_IWUSR);
-	if (fd < 0)
-		err(EXIT_FAILURE, _("cannot open %s"), AGETTY_RELOAD_FILENAME);
-
-	if (futimens(fd, NULL) < 0 || close(fd) < 0)
-		err(EXIT_FAILURE, _("cannot touch file %s"),
-		    AGETTY_RELOAD_FILENAME);
+    int fd = open(AGETTY_RELOAD_FILENAME, O_CREAT | O_CLOEXEC | O_WRONLY,
+                  S_IRUSR | S_IWUSR);
+    if (fd < 0) err(EXIT_FAILURE, _("cannot open %s"), AGETTY_RELOAD_FILENAME);
+
+    if (futimens(fd, NULL) < 0 || close(fd) < 0)
+        err(EXIT_FAILURE, _("cannot touch file %s"), AGETTY_RELOAD_FILENAME);
 #else
-	/* very unusual */
-	errx(EXIT_FAILURE, _("--reload is unsupported on your system"));
+    /* very unusual */
+    errx(EXIT_FAILURE, _("--reload is unsupported on your system"));
 #endif
 }
-- 
2.49.0

