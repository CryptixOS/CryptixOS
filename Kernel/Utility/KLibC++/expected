/*
 * Created by v1tr10l7 on 07.12.2024.
 * Copyright (c) 2024-2024, Szymon Zemke <v1tr10l7@proton.me>
 *
 * SPDX-License-Identifier: GPL-3
 */
#pragma once

// NOTE(v1tr10l7): A lot of this code comes from glibcxx

// <expected> -*- C++ -*-

// Copyright The GNU Toolchain Authors.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/expected
 *  This is a Standard C++ Library header.
 */
#define __glibcxx_want_expected
#define __glibcxx_want_freestanding_expected
#include <bits/version.h>

#include <bits/exception.h>     // exception
#include <bits/invoke.h>        // __invoke
#include <bits/stl_construct.h> // construct_at
#include <bits/utility.h>       // in_place_t
#include <initializer_list>
#include <cassert>

namespace std
{
    template <typename T, typename E>
    class expected;

    template <typename E>
    class unexpected;

    struct unexpect_t
    {
        explicit unexpect_t() = default;
    };

    inline constexpr unexpect_t unexpect{};

    namespace __expected
    {
        template <typename T>
        constexpr bool __is_expected = false;
        template <typename T, typename E>
        constexpr bool __is_expected<expected<T, E>> = true;

        template <typename T>
        constexpr bool __is_unexpected = false;
        template <typename T>
        constexpr bool __is_unexpected<unexpected<T>> = true;

        template <typename F, typename T>
        using __result = remove_cvref_t<invoke_result_t<F&&, T&&>>;
        template <typename F, typename T>
        using __result_xform = remove_cv_t<invoke_result_t<F&&, T&&>>;
        template <typename F>
        using __result0 = remove_cvref_t<invoke_result_t<F&&>>;
        template <typename F>
        using __result0_xform = remove_cv_t<invoke_result_t<F&&>>;

        template <typename E>
        concept __can_be_unexpected = is_object_v<E> && (!is_array_v<E>)
                                   && (!__expected::__is_unexpected<E>)
                                   && (!is_const_v<E>) && (!is_volatile_v<E>);

        // Tag types for in-place construction from an invocation result.
        struct _in_place_inv
        {
        };
        struct _unexpect_inv
        {
        };
    } // namespace __expected

    template <typename E>
    class unexpected
    {
        static_assert(__expected::__can_be_unexpected<E>);

      public:
        constexpr unexpected(const unexpected&) = default;
        constexpr unexpected(unexpected&&)      = default;

        template <typename Err = E>
            requires(!is_same_v<remove_cvref_t<Err>, unexpected>)
                 && (!is_same_v<remove_cvref_t<Err>, in_place_t>)
                 && is_constructible_v<E, Err>
        constexpr explicit unexpected(Err&& e) noexcept(
            is_nothrow_constructible_v<E, Err>)
            : _unexpected(std::forward<Err>(e))
        {
        }

        template <typename... Args>
            requires is_constructible_v<E, Args...>
        constexpr explicit unexpected(in_place_t, Args&&... __args) noexcept(
            is_nothrow_constructible_v<E, Args...>)
            : _unexpected(std::forward<Args>(__args)...)
        {
        }

        template <typename U, typename... Args>
            requires is_constructible_v<E, initializer_list<U>&, Args...>
        constexpr explicit unexpected(
            in_place_t, initializer_list<U> __il,
            Args&&... __args) noexcept(is_nothrow_constructible_v<E,
                                                                  initializer_list<
                                                                      U>&,
                                                                  Args...>)
            : _unexpected(__il, std::forward<Args>(__args)...)
        {
        }

        constexpr unexpected& operator=(const unexpected&) = default;
        constexpr unexpected& operator=(unexpected&&)      = default;

        [[nodiscard]]
        constexpr const E& error() const& noexcept
        {
            return _unexpected;
        }

        [[nodiscard]]
        constexpr E& error() & noexcept
        {
            return _unexpected;
        }

        [[nodiscard]]
        constexpr const E&& error() const&& noexcept
        {
            return std::move(_unexpected);
        }

        [[nodiscard]]
        constexpr E&& error() && noexcept
        {
            return std::move(_unexpected);
        }

        constexpr void
        swap(unexpected& __other) noexcept(is_nothrow_swappable_v<E>)
            requires is_swappable_v<E>
        {
            using std::swap;
            swap(_unexpected, __other._unexpected);
        }

        template <typename Err>
        [[nodiscard]]
        friend constexpr bool operator==(const unexpected&      x,
                                         const unexpected<Err>& y)
        {
            return x._unexpected == y.error();
        }

        friend constexpr void swap(unexpected& x,
                                   unexpected& y) noexcept(noexcept(x.swap(y)))
            requires is_swappable_v<E>
        {
            x.swap(y);
        }

      private:
        E _unexpected;
    };

    template <typename E>
    unexpected(E) -> unexpected<E>;

    namespace __expected
    {
        template <typename T>
        struct _Guard
        {
            static_assert(is_nothrow_move_constructible_v<T>);

            constexpr explicit _Guard(T& x)
                : _M_guarded(__builtin_addressof(x))
                , _M_tmp(std::move(x)) // nothrow
            {
                std::destroy_at(_M_guarded);
            }

            constexpr ~_Guard()
            {
                if (_M_guarded) [[unlikely]]
                    std::construct_at(_M_guarded, std::move(_M_tmp));
            }

            _Guard(const _Guard&)                  = delete;
            _Guard&       operator=(const _Guard&) = delete;

            constexpr T&& release() noexcept
            {
                _M_guarded = nullptr;
                return std::move(_M_tmp);
            }

          private:
            T* _M_guarded;
            T  _M_tmp;
        };

        // reinit-expected helper from [expected.object.assign]
        template <typename T, typename U, typename _Vp>
        constexpr void
        __reinit(T* __newval, U* __oldval,
                 _Vp&& __arg) noexcept(is_nothrow_constructible_v<T, _Vp>)
        {
            if constexpr (is_nothrow_constructible_v<T, _Vp>)
            {
                std::destroy_at(__oldval);
                std::construct_at(__newval, std::forward<_Vp>(__arg));
            }
            else if constexpr (is_nothrow_move_constructible_v<T>)
            {
                T __tmp(std::forward<_Vp>(__arg)); // might throw
                std::destroy_at(__oldval);
                std::construct_at(__newval, std::move(__tmp));
            }
            else
            {
                _Guard<U> __guard(*__oldval);
                std::construct_at(__newval,
                                  std::forward<_Vp>(__arg)); // might throw
                __guard.release();
            }
        }
    } // namespace __expected

    template <typename T, typename E>
    class expected
    {
        static_assert(!is_reference_v<T>);
        static_assert(!is_function_v<T>);
        static_assert(!is_same_v<remove_cv_t<T>, in_place_t>);
        static_assert(!is_same_v<remove_cv_t<T>, unexpect_t>);
        static_assert(!__expected::__is_unexpected<remove_cv_t<T>>);
        static_assert(__expected::__can_be_unexpected<E>);

        template <typename U, typename Err, typename _Unex = unexpected<E>>
        static constexpr bool __cons_from_expected
            = __or_v<is_constructible<T, expected<U, Err>&>,
                     is_constructible<T, expected<U, Err>>,
                     is_constructible<T, const expected<U, Err>&>,
                     is_constructible<T, const expected<U, Err>>,
                     is_convertible<expected<U, Err>&, T>,
                     is_convertible<expected<U, Err>, T>,
                     is_convertible<const expected<U, Err>&, T>,
                     is_convertible<const expected<U, Err>, T>,
                     is_constructible<_Unex, expected<U, Err>&>,
                     is_constructible<_Unex, expected<U, Err>>,
                     is_constructible<_Unex, const expected<U, Err>&>,
                     is_constructible<_Unex, const expected<U, Err>>>;

        template <typename U, typename Err>
        constexpr static bool __explicit_conv
            = __or_v<__not_<is_convertible<U, T>>,
                     __not_<is_convertible<Err, E>>>;

        template <typename U>
        static constexpr bool __same_val = is_same_v<typename U::value_type, T>;

        template <typename U>
        static constexpr bool __same_err = is_same_v<typename U::error_type, E>;

      public:
        using value_type      = T;
        using error_type      = E;
        using unexpected_type = unexpected<E>;

        template <typename U>
        using rebind = expected<U, error_type>;

        constexpr expected() noexcept(is_nothrow_default_constructible_v<T>)
            requires is_default_constructible_v<T>
            : _value()
            , _has_value(true)
        {
        }

        expected(const expected&) = default;

        constexpr expected(const expected& x) noexcept(
            __and_v<is_nothrow_copy_constructible<T>,
                    is_nothrow_copy_constructible<E>>)
            requires is_copy_constructible_v<T> && is_copy_constructible_v<E>
                  && (!is_trivially_copy_constructible_v<T>
                      || !is_trivially_copy_constructible_v<E>)
            : _has_value(x._has_value)
        {
            if (_has_value)
                std::construct_at(__builtin_addressof(_value), x._value);
            else
                std::construct_at(__builtin_addressof(_unexpected),
                                  x._unexpected);
        }

        expected(expected&&) = default;

        constexpr expected(expected&& x) noexcept(
            __and_v<is_nothrow_move_constructible<T>,
                    is_nothrow_move_constructible<E>>)
            requires is_move_constructible_v<T> && is_move_constructible_v<E>
                  && (!is_trivially_move_constructible_v<T>
                      || !is_trivially_move_constructible_v<E>)
            : _has_value(x._has_value)
        {
            if (_has_value)
                std::construct_at(__builtin_addressof(_value),
                                  std::move(x)._value);
            else
                std::construct_at(__builtin_addressof(_unexpected),
                                  std::move(x)._unexpected);
        }

        template <typename U, typename _Gr>
            requires is_constructible_v<T, const U&>
                  && is_constructible_v<E, const _Gr&>
                  && (!__cons_from_expected<U, _Gr>)
        constexpr explicit(__explicit_conv<const U&, const _Gr&>)
            expected(const expected<U, _Gr>& x) noexcept(
                __and_v<is_nothrow_constructible<T, const U&>,
                        is_nothrow_constructible<E, const _Gr&>>)
            : _has_value(x._has_value)
        {
            if (_has_value)
                std::construct_at(__builtin_addressof(_value), x._value);
            else
                std::construct_at(__builtin_addressof(_unexpected),
                                  x._unexpected);
        }

        template <typename U, typename _Gr>
            requires is_constructible_v<T, U> && is_constructible_v<E, _Gr>
                  && (!__cons_from_expected<U, _Gr>)
        constexpr explicit(__explicit_conv<U, _Gr>)
            expected(expected<U, _Gr>&& x) noexcept(
                __and_v<is_nothrow_constructible<T, U>,
                        is_nothrow_constructible<E, _Gr>>)
            : _has_value(x._has_value)
        {
            if (_has_value)
                std::construct_at(__builtin_addressof(_value),
                                  std::move(x)._value);
            else
                std::construct_at(__builtin_addressof(_unexpected),
                                  std::move(x)._unexpected);
        }

        template <typename U = T>
            requires(!is_same_v<remove_cvref_t<U>, expected>)
                     && (!is_same_v<remove_cvref_t<U>, in_place_t>)
                     && (!__expected::__is_unexpected<remove_cvref_t<U>>)
                     && is_constructible_v<T, U>
        constexpr explicit(!is_convertible_v<U, T>)
            expected(U&& __v) noexcept(is_nothrow_constructible_v<T, U>)
            : _value(std::forward<U>(__v))
            , _has_value(true)
        {
        }

        template <typename _Gr = E>
            requires is_constructible_v<E, const _Gr&>
        constexpr explicit(!is_convertible_v<const _Gr&, E>)
            expected(const unexpected<_Gr>& __u) noexcept(
                is_nothrow_constructible_v<E, const _Gr&>)
            : _unexpected(__u.error())
            , _has_value(false)
        {
        }

        template <typename _Gr = E>
            requires is_constructible_v<E, _Gr>
        constexpr explicit(!is_convertible_v<_Gr, E>) expected(
            unexpected<_Gr>&& __u) noexcept(is_nothrow_constructible_v<E, _Gr>)
            : _unexpected(std::move(__u).error())
            , _has_value(false)
        {
        }

        template <typename... Args>
            requires is_constructible_v<T, Args...>
        constexpr explicit expected(in_place_t, Args&&... __args) noexcept(
            is_nothrow_constructible_v<T, Args...>)
            : _value(std::forward<Args>(__args)...)
            , _has_value(true)
        {
        }

        template <typename U, typename... Args>
            requires is_constructible_v<T, initializer_list<U>&, Args...>
        constexpr explicit expected(
            in_place_t, initializer_list<U> __il,
            Args&&... __args) noexcept(is_nothrow_constructible_v<T,
                                                                  initializer_list<
                                                                      U>&,
                                                                  Args...>)
            : _value(__il, std::forward<Args>(__args)...)
            , _has_value(true)
        {
        }

        template <typename... Args>
            requires is_constructible_v<E, Args...>
        constexpr explicit expected(unexpect_t, Args&&... __args) noexcept(
            is_nothrow_constructible_v<E, Args...>)
            : _unexpected(std::forward<Args>(__args)...)
            , _has_value(false)
        {
        }

        template <typename U, typename... Args>
            requires is_constructible_v<E, initializer_list<U>&, Args...>
        constexpr explicit expected(
            unexpect_t, initializer_list<U> __il,
            Args&&... __args) noexcept(is_nothrow_constructible_v<E,
                                                                  initializer_list<
                                                                      U>&,
                                                                  Args...>)
            : _unexpected(__il, std::forward<Args>(__args)...)
            , _has_value(false)
        {
        }

        constexpr ~expected() = default;

        constexpr ~expected()
            requires(!is_trivially_destructible_v<T>)
                 || (!is_trivially_destructible_v<E>)
        {
            if (_has_value) std::destroy_at(__builtin_addressof(_value));
            else std::destroy_at(__builtin_addressof(_unexpected));
        }

        expected&           operator=(const expected&) = delete;
        constexpr expected& operator=(const expected& x) noexcept(
            __and_v<is_nothrow_copy_constructible<T>,
                    is_nothrow_copy_constructible<E>,
                    is_nothrow_copy_assignable<T>,
                    is_nothrow_copy_assignable<E>>)
            requires is_copy_assignable_v<T> && is_copy_constructible_v<T>
                  && is_copy_assignable_v<E> && is_copy_constructible_v<E>
                  && (is_nothrow_move_constructible_v<T>
                      || is_nothrow_move_constructible_v<E>)
        {
            if (x._has_value) this->_assign_value(x._value);
            else this->_M_assign_unex(x._unexpected);
            return *this;
        }

        constexpr expected& operator=(expected&& x) noexcept(
            __and_v<is_nothrow_move_constructible<T>,
                    is_nothrow_move_constructible<E>,
                    is_nothrow_move_assignable<T>,
                    is_nothrow_move_assignable<E>>)
            requires is_move_assignable_v<T> && is_move_constructible_v<T>
                  && is_move_assignable_v<E> && is_move_constructible_v<E>
                  && (is_nothrow_move_constructible_v<T>
                      || is_nothrow_move_constructible_v<E>)
        {
            if (x._has_value) _assign_value(std::move(x._value));
            else _M_assign_unex(std::move(x._unexpected));
            return *this;
        }

        template <typename U = T>
            requires(!is_same_v<expected, remove_cvref_t<U>>)
                 && (!__expected::__is_unexpected<remove_cvref_t<U>>)
                 && is_constructible_v<T, U> && is_assignable_v<T&, U>
                 && (is_nothrow_constructible_v<T, U>
                     || is_nothrow_move_constructible_v<T>
                     || is_nothrow_move_constructible_v<E>)
        constexpr expected& operator=(U&& __v)
        {
            _assign_value(std::forward<U>(__v));
            return *this;
        }

        template <typename _Gr>
            requires is_constructible_v<E, const _Gr&>
                  && is_assignable_v<E&, const _Gr&>
                  && (is_nothrow_constructible_v<E, const _Gr&>
                      || is_nothrow_move_constructible_v<T>
                      || is_nothrow_move_constructible_v<E>)
        constexpr expected& operator=(const unexpected<_Gr>& e)
        {
            _M_assign_unex(e.error());
            return *this;
        }

        template <typename _Gr>
            requires is_constructible_v<E, _Gr> && is_assignable_v<E&, _Gr>
                  && (is_nothrow_constructible_v<E, _Gr>
                      || is_nothrow_move_constructible_v<T>
                      || is_nothrow_move_constructible_v<E>)
        constexpr expected& operator=(unexpected<_Gr>&& e)
        {
            _M_assign_unex(std::move(e).error());
            return *this;
        }

        // modifiers

        template <typename... Args>
            requires is_nothrow_constructible_v<T, Args...>
        constexpr T& emplace(Args&&... __args) noexcept
        {
            if (_has_value) std::destroy_at(__builtin_addressof(_value));
            else
            {
                std::destroy_at(__builtin_addressof(_unexpected));
                _has_value = true;
            }
            std::construct_at(__builtin_addressof(_value),
                              std::forward<Args>(__args)...);
            return _value;
        }

        template <typename U, typename... Args>
            requires is_nothrow_constructible_v<T, initializer_list<U>&,
                                                Args...>
        constexpr T& emplace(initializer_list<U> __il,
                             Args&&... __args) noexcept
        {
            if (_has_value) std::destroy_at(__builtin_addressof(_value));
            else
            {
                std::destroy_at(__builtin_addressof(_unexpected));
                _has_value = true;
            }
            std::construct_at(__builtin_addressof(_value), __il,
                              std::forward<Args>(__args)...);
            return _value;
        }

        // swap
        constexpr void swap(expected& x) noexcept(
            __and_v<is_nothrow_move_constructible<T>,
                    is_nothrow_move_constructible<E>, is_nothrow_swappable<T&>,
                    is_nothrow_swappable<E&>>)
            requires is_swappable_v<T> && is_swappable_v<E>
                  && is_move_constructible_v<T> && is_move_constructible_v<E>
                  && (is_nothrow_move_constructible_v<T>
                      || is_nothrow_move_constructible_v<E>)
        {
            if (_has_value)
            {
                if (x._has_value)
                {
                    using std::swap;
                    swap(_value, x._value);
                }
                else this->_M_swap_val_unex(x);
            }
            else
            {
                if (x._has_value) x._M_swap_val_unex(*this);
                else
                {
                    using std::swap;
                    swap(_unexpected, x._unexpected);
                }
            }
        }

        // observers

        [[nodiscard]]
        constexpr const T* operator->() const noexcept
        {
            assert(_has_value);
            return __builtin_addressof(_value);
        }

        [[nodiscard]]
        constexpr T* operator->() noexcept
        {
            assert(_has_value);
            return __builtin_addressof(_value);
        }

        [[nodiscard]]
        constexpr const T& operator*() const& noexcept
        {
            assert(_has_value);
            return _value;
        }

        [[nodiscard]]
        constexpr T& operator*() & noexcept
        {
            assert(_has_value);
            return _value;
        }

        [[nodiscard]]
        constexpr const T&& operator*() const&& noexcept
        {
            assert(_has_value);
            return std::move(_value);
        }

        [[nodiscard]]
        constexpr T&& operator*() && noexcept
        {
            assert(_has_value);
            return std::move(_value);
        }

        [[nodiscard]]
        constexpr explicit operator bool() const noexcept
        {
            return _has_value;
        }

        [[nodiscard]]
        constexpr bool has_value() const noexcept
        {
            return _has_value;
        }

        constexpr const T& value() const&
        {
            if (_has_value) [[likely]]
                return _value;
            assert(false);
        }

        constexpr T& value() &
        {
            if (_has_value) [[likely]]
                return _value;
            assert(false);
        }

        constexpr const T&& value() const&&
        {
            if (_has_value) [[likely]]
                return std::move(_value);
            assert(false);
        }

        constexpr T&& value() &&
        {
            if (_has_value) [[likely]]
                return std::move(_value);
            assert(false);
        }

        constexpr const E& error() const& noexcept
        {
            assert(!_has_value);
            return _unexpected;
        }

        constexpr E& error() & noexcept
        {
            assert(!_has_value);
            return _unexpected;
        }

        constexpr const E&& error() const&& noexcept
        {
            assert(!_has_value);
            return std::move(_unexpected);
        }

        constexpr E&& error() && noexcept
        {
            assert(!_has_value);
            return std::move(_unexpected);
        }

        template <typename U>
        constexpr T value_or(U&& __v) const& noexcept(
            __and_v<is_nothrow_copy_constructible<T>,
                    is_nothrow_convertible<U, T>>)
        {
            static_assert(is_copy_constructible_v<T>);
            static_assert(is_convertible_v<U, T>);

            if (_has_value) return _value;
            return static_cast<T>(std::forward<U>(__v));
        }

        template <typename U>
        constexpr T
        value_or(U&& __v) && noexcept(__and_v<is_nothrow_move_constructible<T>,
                                              is_nothrow_convertible<U, T>>)
        {
            static_assert(is_move_constructible_v<T>);
            static_assert(is_convertible_v<U, T>);

            if (_has_value) return std::move(_value);
            return static_cast<T>(std::forward<U>(__v));
        }

        template <typename _Gr = E>
        constexpr E error_or(_Gr&& e) const&
        {
            static_assert(is_copy_constructible_v<E>);
            static_assert(is_convertible_v<_Gr, E>);

            if (_has_value) return std::forward<_Gr>(e);
            return _unexpected;
        }

        template <typename _Gr = E>
        constexpr E error_or(_Gr&& e) &&
        {
            static_assert(is_move_constructible_v<E>);
            static_assert(is_convertible_v<_Gr, E>);

            if (_has_value) return std::forward<_Gr>(e);
            return std::move(_unexpected);
        }

        // monadic operations

        template <typename F>
            requires is_constructible_v<E, E&>
        constexpr auto and_then(F&& f) &
        {
            using U = __expected::__result<F, T&>;
            static_assert(
                __expected::__is_expected<U>,
                "the function passed to std::expected<T, E>::and_then "
                "must return a std::expected");
            static_assert(
                is_same_v<typename U::error_type, E>,
                "the function passed to std::expected<T, E>::and_then "
                "must return a std::expected with the same error_type");

            if (has_value())
                return std::__invoke(std::forward<F>(f), _value);
            else return U(unexpect, _unexpected);
        }

        template <typename F>
            requires is_constructible_v<E, const E&>
        constexpr auto and_then(F&& f) const&
        {
            using U = __expected::__result<F, const T&>;
            static_assert(
                __expected::__is_expected<U>,
                "the function passed to std::expected<T, E>::and_then "
                "must return a std::expected");
            static_assert(
                is_same_v<typename U::error_type, E>,
                "the function passed to std::expected<T, E>::and_then "
                "must return a std::expected with the same error_type");

            if (has_value())
                return std::__invoke(std::forward<F>(f), _value);
            else return U(unexpect, _unexpected);
        }

        template <typename F>
            requires is_constructible_v<E, E>
        constexpr auto and_then(F&& f) &&
        {
            using U = __expected::__result<F, T&&>;
            static_assert(
                __expected::__is_expected<U>,
                "the function passed to std::expected<T, E>::and_then "
                "must return a std::expected");
            static_assert(
                is_same_v<typename U::error_type, E>,
                "the function passed to std::expected<T, E>::and_then "
                "must return a std::expected with the same error_type");

            if (has_value())
                return std::__invoke(std::forward<F>(f), std::move(_value));
            else return U(unexpect, std::move(_unexpected));
        }

        template <typename F>
            requires is_constructible_v<E, const E>
        constexpr auto and_then(F&& f) const&&
        {
            using U = __expected::__result<F, const T&&>;
            static_assert(
                __expected::__is_expected<U>,
                "the function passed to std::expected<T, E>::and_then "
                "must return a std::expected");
            static_assert(
                is_same_v<typename U::error_type, E>,
                "the function passed to std::expected<T, E>::and_then "
                "must return a std::expected with the same error_type");

            if (has_value())
                return std::__invoke(std::forward<F>(f), std::move(_value));
            else return U(unexpect, std::move(_unexpected));
        }

        template <typename F>
            requires is_constructible_v<T, T&>
        constexpr auto or_else(F&& f) &
        {
            using _Gr = __expected::__result<F, E&>;
            static_assert(__expected::__is_expected<_Gr>,
                          "the function passed to std::expected<T, E>::or_else "
                          "must return a std::expected");
            static_assert(
                is_same_v<typename _Gr::value_type, T>,
                "the function passed to std::expected<T, E>::or_else "
                "must return a std::expected with the same value_type");

            if (has_value()) return _Gr(in_place, _value);
            else return std::__invoke(std::forward<F>(f), _unexpected);
        }

        template <typename F>
            requires is_constructible_v<T, const T&>
        constexpr auto or_else(F&& f) const&
        {
            using _Gr = __expected::__result<F, const E&>;
            static_assert(__expected::__is_expected<_Gr>,
                          "the function passed to std::expected<T, E>::or_else "
                          "must return a std::expected");
            static_assert(
                is_same_v<typename _Gr::value_type, T>,
                "the function passed to std::expected<T, E>::or_else "
                "must return a std::expected with the same value_type");

            if (has_value()) return _Gr(in_place, _value);
            else return std::__invoke(std::forward<F>(f), _unexpected);
        }

        template <typename F>
            requires is_constructible_v<T, T>
        constexpr auto or_else(F&& f) &&
        {
            using _Gr = __expected::__result<F, E&&>;
            static_assert(__expected::__is_expected<_Gr>,
                          "the function passed to std::expected<T, E>::or_else "
                          "must return a std::expected");
            static_assert(
                is_same_v<typename _Gr::value_type, T>,
                "the function passed to std::expected<T, E>::or_else "
                "must return a std::expected with the same value_type");

            if (has_value()) return _Gr(in_place, std::move(_value));
            else
                return std::__invoke(std::forward<F>(f),
                                     std::move(_unexpected));
        }

        template <typename F>
            requires is_constructible_v<T, const T>
        constexpr auto or_else(F&& f) const&&
        {
            using _Gr = __expected::__result<F, const E&&>;
            static_assert(__expected::__is_expected<_Gr>,
                          "the function passed to std::expected<T, E>::or_else "
                          "must return a std::expected");
            static_assert(
                is_same_v<typename _Gr::value_type, T>,
                "the function passed to std::expected<T, E>::or_else "
                "must return a std::expected with the same value_type");

            if (has_value()) return _Gr(in_place, std::move(_value));
            else
                return std::__invoke(std::forward<F>(f),
                                     std::move(_unexpected));
        }

        template <typename F>
            requires is_constructible_v<E, E&>
        constexpr auto transform(F&& f) &
        {
            using U    = __expected::__result_xform<F, T&>;
            using result_type = expected<U, E>;

            if (has_value())
                return result_type(
                    _in_place_inv{}, [&]()
                    { return std::__invoke(std::forward<F>(f), _value); });
            else return result_type(unexpect, _unexpected);
        }

        template <typename F>
            requires is_constructible_v<E, const E&>
        constexpr auto transform(F&& f) const&
        {
            using U    = __expected::__result_xform<F, const T&>;
            using result_type = expected<U, E>;

            if (has_value())
                return result_type(
                    _in_place_inv{}, [&]()
                    { return std::__invoke(std::forward<F>(f), _value); });
            else return result_type(unexpect, _unexpected);
        }

        template <typename F>
            requires is_constructible_v<E, E>
        constexpr auto transform(F&& f) &&
        {
            using U    = __expected::__result_xform<F, T>;
            using result_type = expected<U, E>;

            if (has_value())
                return result_type(_in_place_inv{},
                            [&]() {
                                return std::__invoke(std::forward<F>(f),
                                                     std::move(_value));
                            });
            else return result_type(unexpect, std::move(_unexpected));
        }

        template <typename F>
            requires is_constructible_v<E, const E>
        constexpr auto transform(F&& f) const&&
        {
            using U    = __expected::__result_xform<F, const T>;
            using result_type = expected<U, E>;

            if (has_value())
                return result_type(_in_place_inv{},
                            [&]() {
                                return std::__invoke(std::forward<F>(f),
                                                     std::move(_value));
                            });
            else return result_type(unexpect, std::move(_unexpected));
        }

        template <typename F>
            requires is_constructible_v<T, T&>
        constexpr auto transform_error(F&& f) &
        {
            using _Gr  = __expected::__result_xform<F, E&>;
            using result_type = expected<T, _Gr>;

            if (has_value()) return result_type(in_place, _value);
            else
                return result_type(_unexpect_inv{},
                            [&]() {
                                return std::__invoke(std::forward<F>(f),
                                                     _unexpected);
                            });
        }

        template <typename F>
            requires is_constructible_v<T, const T&>
        constexpr auto transform_error(F&& f) const&
        {
            using _Gr  = __expected::__result_xform<F, const E&>;
            using result_type = expected<T, _Gr>;

            if (has_value()) return result_type(in_place, _value);
            else
                return result_type(_unexpect_inv{},
                            [&]() {
                                return std::__invoke(std::forward<F>(f),
                                                     _unexpected);
                            });
        }

        template <typename F>
            requires is_constructible_v<T, T>
        constexpr auto transform_error(F&& f) &&
        {
            using _Gr  = __expected::__result_xform<F, E&&>;
            using result_type = expected<T, _Gr>;

            if (has_value()) return result_type(in_place, std::move(_value));
            else
                return result_type(_unexpect_inv{},
                            [&]() {
                                return std::__invoke(std::forward<F>(f),
                                                     std::move(_unexpected));
                            });
        }

        template <typename F>
            requires is_constructible_v<T, const T>
        constexpr auto transform_error(F&& f) const&&
        {
            using _Gr  = __expected::__result_xform<F, const E&&>;
            using result_type = expected<T, _Gr>;

            if (has_value()) return result_type(in_place, std::move(_value));
            else
                return result_type(_unexpect_inv{},
                            [&]() {
                                return std::__invoke(std::forward<F>(f),
                                                     std::move(_unexpected));
                            });
        }

        // equality operators

        template <typename U, typename _Er2>
            requires(!is_void_v<U>)
        friend constexpr bool operator==(const expected&          x,
                                         const expected<U, _Er2>& y)
        // FIXME: noexcept(noexcept(bool(*x == *y))
        // && noexcept(bool(x.error() == y.error())))
        {
            if (x.has_value()) return y.has_value() && bool(*x == *y);
            else return !y.has_value() && bool(x.error() == y.error());
        }

        template <typename U>
        friend constexpr bool operator==(const expected& x, const U& __v)
        // FIXME: noexcept(noexcept(bool(*x == __v)))
        {
            return x.has_value() && bool(*x == __v);
        }

        template <typename _Er2>
        friend constexpr bool operator==(const expected&         x,
                                         const unexpected<_Er2>& e)
        // FIXME: noexcept(noexcept(bool(x.error() == e.error())))
        {
            return !x.has_value() && bool(x.error() == e.error());
        }

        friend constexpr void swap(expected& x,
                                   expected& y) noexcept(noexcept(x.swap(y)))
            requires requires { x.swap(y); }
        {
            x.swap(y);
        }

      private:
        template <typename, typename>
        friend class expected;

        template <typename _Vp>
        constexpr void _assign_value(_Vp&& __v)
        {
            if (_has_value) _value = std::forward<_Vp>(__v);
            else
            {
                __expected::__reinit(__builtin_addressof(_value),
                                     __builtin_addressof(_unexpected),
                                     std::forward<_Vp>(__v));
                _has_value = true;
            }
        }

        template <typename _Vp>
        constexpr void _M_assign_unex(_Vp&& __v)
        {
            if (_has_value)
            {
                __expected::__reinit(__builtin_addressof(_unexpected),
                                     __builtin_addressof(_value),
                                     std::forward<_Vp>(__v));
                _has_value = false;
            }
            else _unexpected = std::forward<_Vp>(__v);
        }

        // Swap two expected objects when only one has a value.
        // Precondition: this->_has_value && !__rhs._has_value
        constexpr void _M_swap_val_unex(expected& __rhs) noexcept(
            __and_v<is_nothrow_move_constructible<E>,
                    is_nothrow_move_constructible<T>>)
        {
            if constexpr (is_nothrow_move_constructible_v<E>)
            {
                __expected::_Guard<E> __guard(__rhs._unexpected);
                std::construct_at(__builtin_addressof(__rhs._value),
                                  std::move(_value)); // might throw
                __rhs._has_value = true;
                std::destroy_at(__builtin_addressof(_value));
                std::construct_at(__builtin_addressof(_unexpected),
                                  __guard.release());
                _has_value = false;
            }
            else
            {
                __expected::_Guard<T> __guard(_value);
                std::construct_at(__builtin_addressof(_unexpected),
                                  std::move(__rhs._unexpected)); // might throw
                _has_value = false;
                std::destroy_at(__builtin_addressof(__rhs._unexpected));
                std::construct_at(__builtin_addressof(__rhs._value),
                                  __guard.release());
                __rhs._has_value = true;
            }
        }

        using _in_place_inv = __expected::_in_place_inv;
        using _unexpect_inv = __expected::_unexpect_inv;

        template <typename F>
        explicit constexpr expected(_in_place_inv, F&& __fn)
            : _value(std::forward<F>(__fn)())
            , _has_value(true)
        {
        }

        template <typename F>
        explicit constexpr expected(_unexpect_inv, F&& __fn)
            : _unexpected(std::forward<F>(__fn)())
            , _has_value(false)
        {
        }

        union
        {
            T _value;
            E _unexpected;
        };

        bool _has_value;
    };

    // Partial specialization for std::expected<cv void, E>
    template <typename T, typename E>
        requires is_void_v<T>
    class expected<T, E>
    {
        static_assert(__expected::__can_be_unexpected<E>);

        template <typename U, typename Err, typename _Unex = unexpected<E>>
        static constexpr bool __cons_from_expected
            = __or_v<is_constructible<_Unex, expected<U, Err>&>,
                     is_constructible<_Unex, expected<U, Err>>,
                     is_constructible<_Unex, const expected<U, Err>&>,
                     is_constructible<_Unex, const expected<U, Err>>>;

        template <typename U>
        static constexpr bool __same_val = is_same_v<typename U::value_type, T>;

        template <typename U>
        static constexpr bool __same_err = is_same_v<typename U::error_type, E>;

      public:
        using value_type      = T;
        using error_type      = E;
        using unexpected_type = unexpected<E>;

        template <typename U>
        using rebind = expected<U, error_type>;

        constexpr expected() noexcept
            : _void()
            , _has_value(true)
        {
        }

        expected(const expected&) = default;

        constexpr expected(const expected& x) noexcept(
            is_nothrow_copy_constructible_v<E>)
            requires is_copy_constructible_v<E>
                      && (!is_trivially_copy_constructible_v<E>)
            : _void()
            , _has_value(x._has_value)
        {
            if (!_has_value)
                std::construct_at(__builtin_addressof(_unexpected),
                                  x._unexpected);
        }

        expected(expected&&) = default;

        constexpr expected(expected&& x) noexcept(
            is_nothrow_move_constructible_v<E>)
            requires is_move_constructible_v<E>
                      && (!is_trivially_move_constructible_v<E>)
            : _void()
            , _has_value(x._has_value)
        {
            if (!_has_value)
                std::construct_at(__builtin_addressof(_unexpected),
                                  std::move(x)._unexpected);
        }

        template <typename U, typename _Gr>
            requires is_void_v<U> && is_constructible_v<E, const _Gr&>
                      && (!__cons_from_expected<U, _Gr>)
        constexpr explicit(!is_convertible_v<const _Gr&, E>)
            expected(const expected<U, _Gr>& x) noexcept(
                is_nothrow_constructible_v<E, const _Gr&>)
            : _void()
            , _has_value(x._has_value)
        {
            if (!_has_value)
                std::construct_at(__builtin_addressof(_unexpected),
                                  x._unexpected);
        }

        template <typename U, typename _Gr>
            requires is_void_v<U> && is_constructible_v<E, _Gr>
                      && (!__cons_from_expected<U, _Gr>)
        constexpr explicit(!is_convertible_v<_Gr, E>) expected(
            expected<U, _Gr>&& x) noexcept(is_nothrow_constructible_v<E, _Gr>)
            : _void()
            , _has_value(x._has_value)
        {
            if (!_has_value)
                std::construct_at(__builtin_addressof(_unexpected),
                                  std::move(x)._unexpected);
        }

        template <typename _Gr = E>
            requires is_constructible_v<E, const _Gr&>
        constexpr explicit(!is_convertible_v<const _Gr&, E>)
            expected(const unexpected<_Gr>& __u) noexcept(
                is_nothrow_constructible_v<E, const _Gr&>)
            : _unexpected(__u.error())
            , _has_value(false)
        {
        }

        template <typename _Gr = E>
            requires is_constructible_v<E, _Gr>
        constexpr explicit(!is_convertible_v<_Gr, E>) expected(
            unexpected<_Gr>&& __u) noexcept(is_nothrow_constructible_v<E, _Gr>)
            : _unexpected(std::move(__u).error())
            , _has_value(false)
        {
        }

        constexpr explicit expected(in_place_t) noexcept
            : expected()
        {
        }

        template <typename... Args>
            requires is_constructible_v<E, Args...>
        constexpr explicit expected(unexpect_t, Args&&... __args) noexcept(
            is_nothrow_constructible_v<E, Args...>)
            : _unexpected(std::forward<Args>(__args)...)
            , _has_value(false)
        {
        }

        template <typename U, typename... Args>
            requires is_constructible_v<E, initializer_list<U>&, Args...>
        constexpr explicit expected(
            unexpect_t, initializer_list<U> __il,
            Args&&... __args) noexcept(is_nothrow_constructible_v<E,
                                                                  initializer_list<
                                                                      U>&,
                                                                  Args...>)
            : _unexpected(__il, std::forward<Args>(__args)...)
            , _has_value(false)
        {
        }

        constexpr ~expected() = default;

        constexpr ~expected()
            requires(!is_trivially_destructible_v<E>)
        {
            if (!_has_value) std::destroy_at(__builtin_addressof(_unexpected));
        }

        // assignment

        expected&           operator=(const expected&) = delete;

        constexpr expected& operator=(const expected& x) noexcept(
            __and_v<is_nothrow_copy_constructible<E>,
                    is_nothrow_copy_assignable<E>>)
            requires is_copy_constructible_v<E> && is_copy_assignable_v<E>
        {
            if (x._has_value) emplace();
            else _M_assign_unex(x._unexpected);
            return *this;
        }

        constexpr expected& operator=(expected&& x) noexcept(
            __and_v<is_nothrow_move_constructible<E>,
                    is_nothrow_move_assignable<E>>)
            requires is_move_constructible_v<E> && is_move_assignable_v<E>
        {
            if (x._has_value) emplace();
            else _M_assign_unex(std::move(x._unexpected));
            return *this;
        }

        template <typename _Gr>
            requires is_constructible_v<E, const _Gr&>
                  && is_assignable_v<E&, const _Gr&>
        constexpr expected& operator=(const unexpected<_Gr>& e)
        {
            _M_assign_unex(e.error());
            return *this;
        }

        template <typename _Gr>
            requires is_constructible_v<E, _Gr> && is_assignable_v<E&, _Gr>
        constexpr expected& operator=(unexpected<_Gr>&& e)
        {
            _M_assign_unex(std::move(e.error()));
            return *this;
        }

        // modifiers

        constexpr void emplace() noexcept
        {
            if (!_has_value)
            {
                std::destroy_at(__builtin_addressof(_unexpected));
                _has_value = true;
            }
        }

        // swap
        constexpr void swap(expected& x) noexcept(
            __and_v<is_nothrow_swappable<E&>, is_nothrow_move_constructible<E>>)
            requires is_swappable_v<E> && is_move_constructible_v<E>
        {
            if (_has_value)
            {
                if (!x._has_value)
                {
                    std::construct_at(__builtin_addressof(_unexpected),
                                      std::move(x._unexpected)); // might throw
                    std::destroy_at(__builtin_addressof(x._unexpected));
                    _has_value   = false;
                    x._has_value = true;
                }
            }
            else
            {
                if (x._has_value)
                {
                    std::construct_at(__builtin_addressof(x._unexpected),
                                      std::move(_unexpected)); // might throw
                    std::destroy_at(__builtin_addressof(_unexpected));
                    _has_value   = true;
                    x._has_value = false;
                }
                else
                {
                    using std::swap;
                    swap(_unexpected, x._unexpected);
                }
            }
        }

        // observers

        [[nodiscard]]
        constexpr explicit operator bool() const noexcept
        {
            return _has_value;
        }

        [[nodiscard]]
        constexpr bool has_value() const noexcept
        {
            return _has_value;
        }

        constexpr void operator*() const noexcept
        {
            assert(_has_value);
        }

        constexpr void value() const&
        {
            if (_has_value) [[likely]]
                return;
            assert(false);
        }

        constexpr void value() &&
        {
            if (_has_value) [[likely]]
                return;
            assert(false);
        }

        constexpr const E& error() const& noexcept
        {
            assert(!_has_value);
            return _unexpected;
        }

        constexpr E& error() & noexcept
        {
            assert(!_has_value);
            return _unexpected;
        }

        constexpr const E&& error() const&& noexcept
        {
            assert(!_has_value);
            return std::move(_unexpected);
        }

        constexpr E&& error() && noexcept
        {
            assert(!_has_value);
            return std::move(_unexpected);
        }

        template <typename _Gr = E>
        constexpr E error_or(_Gr&& e) const&
        {
            static_assert(is_copy_constructible_v<E>);
            static_assert(is_convertible_v<_Gr, E>);

            if (_has_value) return std::forward<_Gr>(e);
            return _unexpected;
        }

        template <typename _Gr = E>
        constexpr E error_or(_Gr&& e) &&
        {
            static_assert(is_move_constructible_v<E>);
            static_assert(is_convertible_v<_Gr, E>);

            if (_has_value) return std::forward<_Gr>(e);
            return std::move(_unexpected);
        }

        template <typename F>
            requires is_constructible_v<E, E&>
        constexpr auto and_then(F&& f) &
        {
            using U = __expected::__result0<F>;
            static_assert(__expected::__is_expected<U>);
            static_assert(is_same_v<typename U::error_type, E>);

            if (has_value()) return std::__invoke(std::forward<F>(f));
            else return U(unexpect, _unexpected);
        }

        template <typename F>
            requires is_constructible_v<E, const E&>
        constexpr auto and_then(F&& f) const&
        {
            using U = __expected::__result0<F>;
            static_assert(__expected::__is_expected<U>);
            static_assert(is_same_v<typename U::error_type, E>);

            if (has_value()) return std::__invoke(std::forward<F>(f));
            else return U(unexpect, _unexpected);
        }

        template <typename F>
            requires is_constructible_v<E, E>
        constexpr auto and_then(F&& f) &&
        {
            using U = __expected::__result0<F>;
            static_assert(__expected::__is_expected<U>);
            static_assert(is_same_v<typename U::error_type, E>);

            if (has_value()) return std::__invoke(std::forward<F>(f));
            else return U(unexpect, std::move(_unexpected));
        }

        template <typename F>
            requires is_constructible_v<E, const E>
        constexpr auto and_then(F&& f) const&&
        {
            using U = __expected::__result0<F>;
            static_assert(__expected::__is_expected<U>);
            static_assert(is_same_v<typename U::error_type, E>);

            if (has_value()) return std::__invoke(std::forward<F>(f));
            else return U(unexpect, std::move(_unexpected));
        }

        template <typename F>
        constexpr auto or_else(F&& f) &
        {
            using _Gr = __expected::__result<F, E&>;
            static_assert(__expected::__is_expected<_Gr>);
            static_assert(is_same_v<typename _Gr::value_type, T>);

            if (has_value()) return _Gr();
            else return std::__invoke(std::forward<F>(f), _unexpected);
        }

        template <typename F>
        constexpr auto or_else(F&& f) const&
        {
            using _Gr = __expected::__result<F, const E&>;
            static_assert(__expected::__is_expected<_Gr>);
            static_assert(is_same_v<typename _Gr::value_type, T>);

            if (has_value()) return _Gr();
            else return std::__invoke(std::forward<F>(f), _unexpected);
        }

        template <typename F>
        constexpr auto or_else(F&& f) &&
        {
            using _Gr = __expected::__result<F, E&&>;
            static_assert(__expected::__is_expected<_Gr>);
            static_assert(is_same_v<typename _Gr::value_type, T>);

            if (has_value()) return _Gr();
            else
                return std::__invoke(std::forward<F>(f),
                                     std::move(_unexpected));
        }

        template <typename F>
        constexpr auto or_else(F&& f) const&&
        {
            using _Gr = __expected::__result<F, const E&&>;
            static_assert(__expected::__is_expected<_Gr>);
            static_assert(is_same_v<typename _Gr::value_type, T>);

            if (has_value()) return _Gr();
            else
                return std::__invoke(std::forward<F>(f),
                                     std::move(_unexpected));
        }

        template <typename F>
            requires is_constructible_v<E, E&>
        constexpr auto transform(F&& f) &
        {
            using U    = __expected::__result0_xform<F>;
            using result_type = expected<U, E>;

            if (has_value())
                return result_type(_in_place_inv{}, std::forward<F>(f));
            else return result_type(unexpect, _unexpected);
        }

        template <typename F>
            requires is_constructible_v<E, const E&>
        constexpr auto transform(F&& f) const&
        {
            using U    = __expected::__result0_xform<F>;
            using result_type = expected<U, E>;

            if (has_value())
                return result_type(_in_place_inv{}, std::forward<F>(f));
            else return result_type(unexpect, _unexpected);
        }

        template <typename F>
            requires is_constructible_v<E, E>
        constexpr auto transform(F&& f) &&
        {
            using U    = __expected::__result0_xform<F>;
            using result_type = expected<U, E>;

            if (has_value())
                return result_type(_in_place_inv{}, std::forward<F>(f));
            else return result_type(unexpect, std::move(_unexpected));
        }

        template <typename F>
            requires is_constructible_v<E, const E>
        constexpr auto transform(F&& f) const&&
        {
            using U    = __expected::__result0_xform<F>;
            using result_type = expected<U, E>;

            if (has_value())
                return result_type(_in_place_inv{}, std::forward<F>(f));
            else return result_type(unexpect, std::move(_unexpected));
        }

        template <typename F>
        constexpr auto transform_error(F&& f) &
        {
            using _Gr  = __expected::__result_xform<F, E&>;
            using result_type = expected<T, _Gr>;

            if (has_value()) return result_type();
            else
                return result_type(_unexpect_inv{},
                            [&]() {
                                return std::__invoke(std::forward<F>(f),
                                                     _unexpected);
                            });
        }

        template <typename F>
        constexpr auto transform_error(F&& f) const&
        {
            using _Gr  = __expected::__result_xform<F, const E&>;
            using result_type = expected<T, _Gr>;

            if (has_value()) return result_type();
            else
                return result_type(_unexpect_inv{},
                            [&]() {
                                return std::__invoke(std::forward<F>(f),
                                                     _unexpected);
                            });
        }

        template <typename F>
        constexpr auto transform_error(F&& f) &&
        {
            using _Gr  = __expected::__result_xform<F, E&&>;
            using result_type = expected<T, _Gr>;

            if (has_value()) return result_type();
            else
                return result_type(_unexpect_inv{},
                            [&]() {
                                return std::__invoke(std::forward<F>(f),
                                                     std::move(_unexpected));
                            });
        }

        template <typename F>
        constexpr auto transform_error(F&& f) const&&
        {
            using _Gr  = __expected::__result_xform<F, const E&&>;
            using result_type = expected<T, _Gr>;

            if (has_value()) return result_type();
            else
                return result_type(_unexpect_inv{},
                            [&]() {
                                return std::__invoke(std::forward<F>(f),
                                                     std::move(_unexpected));
                            });
        }

        template <typename U, typename _Er2>
            requires is_void_v<U>
        friend constexpr bool operator==(const expected&          x,
                                         const expected<U, _Er2>& y)
        {
            if (x.has_value()) return y.has_value();
            else return !y.has_value() && bool(x.error() == y.error());
        }

        template <typename _Er2>
        friend constexpr bool operator==(const expected&         x,
                                         const unexpected<_Er2>& e)
        {
            return !x.has_value() && bool(x.error() == e.error());
        }

        friend constexpr void swap(expected& x,
                                   expected& y) noexcept(noexcept(x.swap(y)))
            requires requires { x.swap(y); }
        {
            x.swap(y);
        }

      private:
        template <typename, typename>
        friend class expected;

        template <typename _Vp>
        constexpr void _M_assign_unex(_Vp&& __v)
        {
            if (_has_value)
            {
                std::construct_at(__builtin_addressof(_unexpected),
                                  std::forward<_Vp>(__v));
                _has_value = false;
            }
            else _unexpected = std::forward<_Vp>(__v);
        }

        using _in_place_inv = __expected::_in_place_inv;
        using _unexpect_inv = __expected::_unexpect_inv;

        template <typename F>
        explicit constexpr expected(_in_place_inv, F&& __fn)
            : _void()
            , _has_value(true)
        {
            std::forward<F>(__fn)();
        }

        template <typename F>
        explicit constexpr expected(_unexpect_inv, F&& __fn)
            : _unexpected(std::forward<F>(__fn)())
            , _has_value(false)
        {
        }

        union
        {
            struct
            {
            } _void;
            E _unexpected;
        };

        bool _has_value;
    };

} // namespace std
